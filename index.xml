<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>home</title>
    <link>https://elecbrandy.github.io/</link>
    <description>Recent content on home</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 31 Dec 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://elecbrandy.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[AI] 01. NLP의 과거와 오늘</title>
      <link>https://elecbrandy.github.io/posts/ai/2024_winter_llm/llm_1/</link>
      <pubDate>Tue, 31 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/ai/2024_winter_llm/llm_1/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /한권으로 끝내는 LLM 파인튜닝&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;NLP: Natural Language Processing&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;2024 겨울방학을 맞아, 위키북스의 &lt;code&gt;한권으로 끝내는 LLM 파인튜닝&lt;/code&gt; 스터디를 통해 지난 2023 데이터 청년 캠퍼스, 2024 AI 레드팀 컨퍼런스 등에서 맛보았던 LLM을 체험해보는 시간을 가져보기로 했다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-자연어-처리와-인공지능의-발전-과정&#34;&gt;2. 자연어 처리와 인공지능의 발전 과정&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2-1-인공지능의-시작&#34;&gt;2-1. 인공지능의 시작&lt;/h3&gt;&#xA;&lt;p&gt;초기 기계 번역 기술은 컴퓨팅 기술의 한계로 인해 많은 어려움을 겪었다. 그러나 새로운 전환점을 맞이하며 인공지능 연구의 서막이 열리게 된다. 1950년, 앨런 튜링은 &lt;em&gt;Computing Machinery and Intelligence&lt;/em&gt; 논문에서 “기계가 생각할 수 있을까?”라는 질문을 던졌다. 이는 현대 인공지능의 기초를 이루는 중요한 개념으로 이어졌다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[AI] 02. GPT</title>
      <link>https://elecbrandy.github.io/posts/ai/2024_winter_llm/llm_2/</link>
      <pubDate>Tue, 31 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/ai/2024_winter_llm/llm_2/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /한권으로 끝내는 LLM 파인튜닝&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;NLP: Natural Language Processing&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;2024 겨울방학을 맞아, 위키북스의 &lt;code&gt;한권으로 끝내는 LLM 파인튜닝&lt;/code&gt; 스터디를 통해 지난 2023 데이터 청년 캠퍼스, 2024 AI 레드팀 컨퍼런스 등에서 맛보았던 LLM을 체험해보는 시간을 가져보기로 했다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-runpod&#34;&gt;2. Runpod&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2-1-인공지능의-시작&#34;&gt;2-1. 인공지능의 시작&lt;/h3&gt;&#xA;&lt;p&gt;결국 초기 단계에서 컴퓨팅 기술의 한께로 어려움을 겪었던 기계 번역 기술은 새로운 전환점을 맞이한다. 엘런 튜링은 Computing Machinery and Intelligence 논문에서 기계가 생각할수 있을까라는 질문을 던졌다. 이때 튜링의 개념은 현대 인공지능과 직접적으로 연결된다. 이 논문은 약 24000 이상 인용될 정도로 인공지능 분야에 많은 영향을 미쳤고 인공지능 연구의 시작점이 된다. &lt;strong&gt;기게가 인간과 구별되지 않는 방식으로 행동할 수 있다면 그 기계는 &amp;lsquo;생각하고 있다&amp;rsquo;고 볼 수 있다고&lt;/strong&gt; 주장한 튜링. 이 주장을 바탕으로 설계한 실험이 바로 튜링 테스트 이다. 질문자, 응답자, 기계응답자가 참여하는 이 실험은, 만약 질문자가 기계를 인간으로 착각하게 할정도로 기계가 인간과 유사하게 응답할수있다면 그 기꼐가 튜링테스트를 통과했다고 간주함.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[알고리즘] Linear-time selection</title>
      <link>https://elecbrandy.github.io/posts/cs101/algorithm/lineartime_selection/</link>
      <pubDate>Fri, 11 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/algorithm/lineartime_selection/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /algorithm&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-선형-시간-선택-알고리즘-linear-time-selection&#34;&gt;1. 선형 시간 선택 알고리즘 (Linear-Time Selection)&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;https://i.imgur.com/sW8twRl.png&#34; width=&#34;700&#34;&gt;&#xA;&lt;p&gt;&lt;code&gt;선형 시간 선택 알고리즘&lt;/code&gt;은 정렬되지 않은 데이터에서 원하는 순서의 요소(예: k번째로 작은 요소)를 선형 시간 내에 찾는 알고리즘이다. 일반적으로 정렬 알고리즘을 사용하여 데이터를 정렬한 후 원하는 요소를 찾을 수 있지만, 이는 보통 $O(n log n)$ 의 시간 복잡도를 갖는다. 그러나 선형 시간 선택 알고리즘은 정렬되지 않은 상태에서 $O(n)$ 의 시간 복잡도로 원하는 요소를 찾을 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[알고리즘] Merge Sort</title>
      <link>https://elecbrandy.github.io/posts/cs101/algorithm/merge_sort/</link>
      <pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/algorithm/merge_sort/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /algorithm&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-병합-정렬-merge-sort&#34;&gt;1. 병합 정렬 (Merge Sort)&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;https://i.imgur.com/FUWkCRp.png&#34; width=&#34;700&#34;&gt;&#xA;&lt;p&gt;&lt;code&gt;병합 정렬&lt;/code&gt;은 분할 정복(Divide and Conquer) 알고리즘의 한 종류로, 데이터를 작은 부분으로 분할하고, 정렬된 부분을 병합하여 전체 데이터를 정렬하는 방식으로 동작한다. 이 알고리즘은 리스트를 반으로 나누어 재귀적으로 각 부분 리스트를 정렬한 후, 정렬된 부분 리스트들을 합쳐서 전체 리스트를 정렬한다.&lt;/p&gt;&#xA;&lt;p&gt;병합 정렬은 다음과 같은 단계로 이루어진다:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;분할(Divide):&lt;/strong&gt; 리스트를 중간 지점에서 두 부분으로 분할한다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;정복(Conquer):&lt;/strong&gt; 각 부분 리스트를 재귀적으로 병합 정렬을 이용하여 정렬한다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;병합(Combine):&lt;/strong&gt; 두 개의 정렬된 부분 리스트를 하나의 정렬된 리스트로 병합한다.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-구현-분석&#34;&gt;2. 구현 분석&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2-1-구현&#34;&gt;2-1. 구현&lt;/h3&gt;&#xA;&lt;details&gt;&#xA;&lt;summary&gt;MergeSort Code&lt;/summary&gt;&#xA;&lt;div markdown=&#34;1&#34;&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mergeSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;arr, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; right) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; right) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;mergeSort(arr, left, mid);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;mergeSort(arr, mid &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, right);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;merge(arr, left, mid, right);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;merge&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;arr, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mid, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; right) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i, j, k;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; left_len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; right_len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; mid;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; L[left_len], R[right_len];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; left_len; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;L[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr[left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; i];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; right_len; j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;R[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr[m &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; j];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; left_len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; right_len) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (L[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; R[j]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;arr[k] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; L[i];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;arr[k] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; R[j];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;k&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; left_len) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;arr[k] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; L[i];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;k&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; right_len) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;arr[k] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; R[j];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;k&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&#xA;&lt;/details&gt;&#xA;&lt;h3 id=&#34;2-2-mergesort&#34;&gt;2-2. mergeSort&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mergeSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;arr, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; left, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; right) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;/* 재귀 종료 조건 */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; right) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;/* mid index 계산 */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;/* 분할 재귀 호출 */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;mergeSort(arr, left, mid);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;mergeSort(arr, mid &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, right);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;/* 정렬, 병합 */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;merge(arr, left, mid, right);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;주 함수 &lt;code&gt;void mergeSort(int *arr, int left, int right)&lt;/code&gt;는 정렬 대상 배열, 좌측 끝 인덱스, 우측 끝 인덱스를 받는다. 이때 좌측, 우측 끝 인덱스를 받는 이유는 한 재귀 호출 안에서 다루는 배열의 범위가 어디서 부터 어디인지 알기 위함이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[알고리즘] 재귀적 분석</title>
      <link>https://elecbrandy.github.io/posts/cs101/algorithm/analysis_recurrence_relation/</link>
      <pubDate>Mon, 30 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/algorithm/analysis_recurrence_relation/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /algorithm&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-재귀적-접근-방법&#34;&gt;1. 재귀적 접근 방법&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;재귀적 접근 방법&lt;/strong&gt;(recursive analysis)은 알고리즘이 &lt;strong&gt;재귀적으로 동작&lt;/strong&gt;할 때 그 성능을 분석하는 방법이다. 재귀적 알고리즘은 문제를 더 작은 하위 문제로 나누고, 각 하위 문제를 재귀적으로 해결하는 방식으로 동작한다. 재귀적 분석은 하위 문제들이 어떻게 구성되고 합쳐지는지에 따라 &lt;strong&gt;전체 성능&lt;/strong&gt;을 평가하는 데 집중한다.&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-1-재귀적-접근-방법의-핵심&#34;&gt;1-1. 재귀적 접근 방법의 핵심&lt;/h3&gt;&#xA;&lt;p&gt;재귀적 분석의 핵심은 **재귀 관계식(recurrence relation)**을 세우는 것이다. 재귀 관계식은 알고리즘의 실행 시간이나 자원 사용량이 작은 하위 문제들에 의해 어떻게 정의되는지를 나타내는 수식이다. 이를 해결함으로써 알고리즘의 성능을 분석할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[알고리즘] 점근적 분석</title>
      <link>https://elecbrandy.github.io/posts/cs101/algorithm/analysis_asymptotic_notation/</link>
      <pubDate>Sun, 29 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/algorithm/analysis_asymptotic_notation/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /algorithm&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-점근적-접근-방법&#34;&gt;1. 점근적 접근 방법&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;점근적 접근 방법&lt;/strong&gt;(asymptotic analysis)은 알고리즘의 성능이 입력 크기 &lt;code&gt;n&lt;/code&gt;이 &lt;strong&gt;매우 커질 때&lt;/strong&gt;(즉, 무한에 가까울 때) 어떻게 변하는지를 분석하는 방법이다. 이는 작은 입력 크기에서 발생하는 미세한 차이들을 무시하고, 하드웨어, 언어 등의 특정 요인에서 벗어나 추상화하는 과정을 통해 알고리즘이 &lt;strong&gt;입력 크기가 커짐에 따라 성능이 어떻게 변화하는지&lt;/strong&gt;에 집중한다. 점근적 분석을 통해 상수 시간이나 작은 차이를 배제하고, 입력 크기와 관련된 &lt;strong&gt;성능 경향&lt;/strong&gt;을 평가할 수 있다! 물론 &lt;code&gt;n&lt;/code&gt;이 큰 경우에만 의미가 있는 한계가 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[알고리즘] Insertion Sort</title>
      <link>https://elecbrandy.github.io/posts/cs101/algorithm/insertion_sort/</link>
      <pubDate>Sat, 21 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/algorithm/insertion_sort/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /algorithm&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-insertion-sort&#34;&gt;1. Insertion sort&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;https://i.imgur.com/sW8twRl.png&#34; width=&#34;700&#34;&gt;&#xA;&lt;p&gt;&lt;code&gt;Insertion sort&lt;/code&gt;(삽입 정렬)는 말 그대로 정렬된 배열에 새로운 요소를 삽입하여 정렬을 확장해 나가는 알고리즘이다. 배열을 처리할 때, 전체 배열 중 왼쪽 부분은 이미 정렬된 상태이고, 오른쪽 부분은 아직 정렬되지 않은 상태로 남아 있다. 삽입 정렬은 이 정렬되지 않은 부분에서 하나씩 요소를 가져와서, 정렬된 배열의 어느 위치에 삽입해야 할지 결정하는 방식으로 동작한다.&lt;/p&gt;&#xA;&lt;p&gt;이 알고리즘에서 두 개의 주요 루프가 존재한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[알고리즘] Selection Sort</title>
      <link>https://elecbrandy.github.io/posts/cs101/algorithm/selection_sort/</link>
      <pubDate>Sat, 21 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/algorithm/selection_sort/</guid>
      <description>&lt;br&gt;&#xA;&lt;h2 id=&#34;1-selection-sort&#34;&gt;1. Selection sort&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;https://i.imgur.com/YJvMRgL.png&#34; width=&#34;700&#34;&gt;&#xA;&lt;p&gt;&lt;code&gt;Selection sort&lt;/code&gt;(선택 정렬)는 배열에서 가장 작은(또는 가장 큰) 요소를 찾아서 순서대로 정렬해 나가는 단순한 정렬 알고리즘이다. 배열을 처리할 때, 정렬되지 않은 부분에서 최소값을 찾아 정렬된 부분의 끝에 위치시킴으로써 정렬을 확장해 나간다.&lt;/p&gt;&#xA;&lt;p&gt;이 알고리즘에서는 두 개의 주요 루프가 존재한다.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;첫 번째 루프&lt;/strong&gt;는 배열의 모든 요소를 차례로 선택하는 루프로, 인덱스 0부터 배열의 끝(n-1)까지 반복된다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;두 번째 루프&lt;/strong&gt;는 현재 선택된 인덱스부터 배열의 끝까지 탐색하여 최소값의 인덱스를 찾는 과정이다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-구현-분석&#34;&gt;2. 구현 분석&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;selectionSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;arr, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; N &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;// 루프_1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; minIndex &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; N; j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;// 루프_2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (arr[j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; arr[minIndex]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;minIndex &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; j;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;swap(arr[i], arr[minIndex]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&#xA;&lt;h3 id=&#34;2-1-루프-1&#34;&gt;2-1. 루프 [1]&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; N &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이 부분은 배열의 첫 번째 요소부터 마지막에서 두 번째 요소까지 순차적으로 선택하는 루프이다. 각 반복에서 현재 위치 &lt;code&gt;i&lt;/code&gt;부터 배열의 끝까지 중에서 최소값을 찾아 현재 위치에 놓는다. 이때, 마지막 요소는 비교 대상이 되지만, 마지막에는 이미 모든 요소가 정렬되었기 때문에 &lt;code&gt;i&lt;/code&gt;는 &lt;code&gt;N - 2&lt;/code&gt;까지만 반복하면 된다. 하지만 코드에서는 &lt;code&gt;i &amp;lt; N - 1&lt;/code&gt;로 되어 있어 마지막에서 두 번째 요소까지 선택한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[알고리즘] 알고리즘 분석</title>
      <link>https://elecbrandy.github.io/posts/cs101/algorithm/analysis/</link>
      <pubDate>Fri, 20 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/algorithm/analysis/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /algorithm&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-알고리즘-분석&#34;&gt;1. 알고리즘 분석&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;어떤 알고리즘이 있을 때, 우리는 이 알고리즘을 어떻게 분석하는게 좋을까? 바로 &lt;strong&gt;구현 / 정확성 / 효율성&lt;/strong&gt; 세 가지 핵심 요소를 통해 대상 알고리즘을 효과적으로 분석할 수 있다.&lt;/p&gt;&#xA;&lt;h4 id=&#34;구현&#34;&gt;구현&lt;/h4&gt;&#xA;&lt;p&gt;구현은 알고리즘이 어떻게 구조화되고 작성되었는지를 의미하며, 코드 레벨에서의 설계와 구현 방식에 대한 부분이다.&lt;/p&gt;&#xA;&lt;h4 id=&#34;정확성&#34;&gt;정확성&lt;/h4&gt;&#xA;&lt;p&gt;정확성은 알고리즘이 기대한 대로 정확하게 동작하는지 평가하는 요소로, 원하는 결과를 항상 도출해낼 수 있는지 증명하는 것이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[자료구조] Queue</title>
      <link>https://elecbrandy.github.io/posts/cs101/datastructure/queue/</link>
      <pubDate>Thu, 19 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/datastructure/queue/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /dataStructure&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;Queue&lt;/strong&gt;(큐)는 선형 자료구조로, 데이터가 삽입된 순서대로 처리되는 &lt;strong&gt;FIFO(First In First Out)&lt;/strong&gt; 방식이다. 즉, 먼저 들어온 데이터가 먼저 나가는 구조이다. 큐는 컴퓨터 시스템에서 작업 예약, 데이터 버퍼링 등 다양한 분야에서 활용된다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-큐의-개념과-종류&#34;&gt;2. 큐의 개념과 종류&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;큐는 한쪽 끝에서는 삽입이, 반대쪽 끝에서는 삭제가 이루어지는 구조이다. 기본적인 큐 외에도 다양한 변형이 존재한다.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;원형 큐(Circular Queue)&lt;/strong&gt;: 마지막 위치가 첫 위치와 연결되어 원형으로 구성된 큐이다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;우선순위 큐(Priority Queue)&lt;/strong&gt;: 각 요소에 우선순위가 부여되어, 높은 우선순위의 요소가 먼저 처리되는 큐이다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;덱(Deque)&lt;/strong&gt;: 양쪽 끝에서 삽입과 삭제가 모두 가능한 큐이다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;3-큐의-구현&#34;&gt;3. 큐의 구현&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;큐는 배열이나 연결 리스트를 이용하여 구현할 수 있다. 여기서는 &lt;code&gt;C&lt;/code&gt; 언어를 사용하여 배열 기반의 큐를 구현해보고, &lt;code&gt;C++&lt;/code&gt;의 STL에서 제공하는 &lt;code&gt;queue&lt;/code&gt;의 사용법을 알아보겠다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[cs101] 부동소수점</title>
      <link>https://elecbrandy.github.io/posts/cs101/etc/radixpoint/</link>
      <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/etc/radixpoint/</guid>
      <description>&lt;!-- &lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /42cursus&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_0/libft/&#34;&gt;libft&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/ft_printf/&#34;&gt;ft_printf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/get_next_line/&#34;&gt;get_next_line&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/born2beroot/&#34;&gt;born2beroot&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/pipex/&#34;&gt;pipex&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/fdf/&#34;&gt;fdf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/push_swap/&#34;&gt;push_swap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/minishell/&#34;&gt;minishell&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/philosopher/&#34;&gt;philosopher&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_4/netpractice/&#34;&gt;netpractice&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA; --&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;정수(Integer)&lt;/strong&gt; 는 우리가 흔히 알고 있는 0, 1, 2, 3과 같은 숫자이다. 컴퓨터에서 정수는 정확하게 표현된다. 예를 들어, 숫자 &amp;lsquo;2&amp;rsquo;는 항상 2로 저장되며, 더하거나 빼도 그 값이 정확하게 맞는다. 즉, 정수는 &lt;strong&gt;정확성(Accuracy)&lt;/strong&gt; 이 매우 뛰어나다. 예를 들어, 2 + 1 = 3이 정확하게 나온다.&lt;/p&gt;&#xA;&lt;p&gt;하지만 정수는 소수점 값을 표현할 수 없기 때문에 &lt;strong&gt;정밀도(Precision)&lt;/strong&gt; 가 떨어진다. 예를 들어, 5 ÷ 2는 2.5이지만, 정수는 소수점을 버리고 2만 저장한다. 이처럼 정수는 소수점 이하의 값들을 무시하기 때문에 작은 차이들을 정확하게 표현하기 어렵다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[자료구조] Stack</title>
      <link>https://elecbrandy.github.io/posts/cs101/datastructure/stack/</link>
      <pubDate>Wed, 11 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/datastructure/stack/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /dataStructure&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;https://media.geeksforgeeks.org/wp-content/uploads/20240606180735/Stack-representation-in-Data-Structures-(1).webp&#34; width=&#34;700&#34;&gt;&#xA;&lt;p&gt;Stack은 &lt;strong&gt;LIFO(Last in, First Out)&lt;/strong&gt; 방식으로 작동하는 선형 자료구조이다. 즉, 가장 마지막에 삽입된 데이터가 가장 먼저 삭제되는 구조인 것! Stack의 입/출력은 오로지 Stack의 꼭대기에서만 이루어진다. 갑자기 중간에 있는 데이터를 삭제하거나 끼워넣을 수 없으며, 맨 아래 데이터에 접근하기 위해서는 그 위에 있는 데이터를 모두 걷어내야한다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-stack의-구현&#34;&gt;2. StacK의 구현&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;여러 환경에서 이미 Stack은 구현되어있는 자료구조이지만, 공부를 위해서 직접 구현해보자. 일단은 &lt;code&gt;C&lt;/code&gt;를 이용해 Array로 구현해보고, &lt;code&gt;C++&lt;/code&gt;의 STL에 속한 Stack 자료구조 사용법을 익혀보자. Linked List를 통해서도 Stack을 구현할 수 있으며, 전체용량을 관리하기 쉽다는 이점이 있다. &lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/list&#34;&gt; Linked List &lt;/a&gt; 의 여러 규칙에 규칙을 더해주기만 하면 만들 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[자료구조] List</title>
      <link>https://elecbrandy.github.io/posts/cs101/datastructure/list/</link>
      <pubDate>Tue, 10 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/datastructure/list/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /dataStructure&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;List는 순서가 있는 데이터의 집합을 나타내는 가장 기초적인 자료구조 중 하나로, 배열(array)과의 근본적인 차이는 동적 크기 변화와 복잡한 데이터 구조를 지원하는 것이다. List는 CS에서 다양한 형태로 존재하며, 대표적으로 배열 리스트(Array List)와 연결 리스트(Linked List)가 존재한다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-array-list&#34;&gt;2. Array List&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vec;  &lt;span style=&#34;color:#75715e&#34;&gt;// 동적 크기를 갖는 배열 리스트&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;vec.push_back(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);      &lt;span style=&#34;color:#75715e&#34;&gt;// 새로운 요소 추가&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Array List&lt;/strong&gt;는 연속적인 메모리 공간에 데이터를 저장하는 방식이다. 이는 인덱스를 통한 빠른 접근 속도(시간 복잡도 &lt;code&gt;O(1)&lt;/code&gt;)가 특징이지만, 크기를 미리 지정해야 하는 제약이 있다. 만약 리스트가 가득 차면 새로운 더 큰 메모리 공간을 할당하고, 기존 요소를 복사하는 과정을 거쳐야하며 이 복사 작업의 평균 시간 복잡도는 &lt;code&gt;O(n)&lt;/code&gt;이다. 대표적인 예시로 &lt;code&gt;vector&lt;/code&gt;를 들 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[OOP] 캡슐화</title>
      <link>https://elecbrandy.github.io/posts/cs101/oop/capsule/</link>
      <pubDate>Mon, 02 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/oop/capsule/</guid>
      <description>&lt;details&gt;&#xA;&lt;summary&gt;&lt;strong&gt;📂 : OPP 모아보기&lt;/strong&gt;&lt;/summary&gt;&#xA;&lt;div markdown=&#34;1&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/opp/capsule&#34;&gt; &lt;strong&gt;[0]&lt;/strong&gt; : 캡슐화 &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/opp/&#34;&gt; &lt;strong&gt;[1]&lt;/strong&gt; : Stack &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/opp/&#34;&gt; &lt;strong&gt;[2]&lt;/strong&gt; : Queue &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;/details&gt;&#xA;&lt;br&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;??? : Class는 붕어빵 틀, instance는 붕어빵&amp;hellip;?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;객체지향-이전의-세계&#34;&gt;객체지향 이전의 세계&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;객체지향이란 무엇일까? 인터넷에 검색해보면 &amp;ldquo;객체를 지향하는 프로그래밍&amp;quot;이라는 복잡한 설명과 함께, &amp;ldquo;클래스는 붕어빵 틀이고 인스턴스는 그 틀로 찍어낸 붕어빵이다&amp;hellip;&amp;rdquo; 같은 비유를 흔히 보게 된다. 그런데 이런 설명만으로는 객체지향의 본질을 파악하기 어렵다. 그렇다면 객체지향을 공부하기 전에, 이 개념이 왜 등장하게 되었는지 먼저 살펴보자.&lt;/p&gt;&#xA;&lt;p&gt;42과정을 진행하면서 처음으로 접하게 되는 언어는 C이다. C는 대표적인 절차지향 언어로, 프로그램을 일련의 명령과 함수로 구성해 나가는 방식이다. 처음엔 간단한 프로그램을 짜는 데 어려움이 없었고, 몇몇 과제는 금방 끝났다. 하지만 과제가 점점 복잡해지고, 코드의 규모가 커질수록 문제들이 발생하기 시작했다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] netpractice</title>
      <link>https://elecbrandy.github.io/posts/42cursus/circle_4/netpractice/</link>
      <pubDate>Thu, 15 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/circle_4/netpractice/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /42cursus&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_0/libft/&#34;&gt;libft&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/ft_printf/&#34;&gt;ft_printf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/get_next_line/&#34;&gt;get_next_line&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/born2beroot/&#34;&gt;born2beroot&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/pipex/&#34;&gt;pipex&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/fdf/&#34;&gt;fdf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/push_swap/&#34;&gt;push_swap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/minishell/&#34;&gt;minishell&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/philosopher/&#34;&gt;philosopher&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_4/netpractice/&#34;&gt;netpractice&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;This document is a System Administration related exercise.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 n번째로 수행한 과제로, 교육 인터페이스상에서 소규모 네트워크를 구성하는 과제이다. 네트워킹 문제를 해결하여 네트워크가 실행되도록 만들어야 한다. 총 10개의 문제를 완료하고, Git 저장소에 제출하는 것이 최종 목표이다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-개념-정리&#34;&gt;2. 개념 정리&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2-1-네트워크란&#34;&gt;2-1. 네트워크란?&lt;/h3&gt;&#xA;&lt;p&gt;네트워크는 두 대 이상의 컴퓨터 시스템이 서로 연결되어 데이터를 교환할 수 있는 구조를 의미한다. 이 연결은 다양한 방법으로 이루어질 수 있으며, 물리적 케이블, 무선 신호, 또는 혼합된 방식으로 네트워크를 구성할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] pipex</title>
      <link>https://elecbrandy.github.io/posts/42cursus/circle_2/pipex/</link>
      <pubDate>Wed, 28 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/circle_2/pipex/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /42cursus&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_0/libft/&#34;&gt;libft&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/ft_printf/&#34;&gt;ft_printf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/get_next_line/&#34;&gt;get_next_line&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/born2beroot/&#34;&gt;born2beroot&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/pipex/&#34;&gt;pipex&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/fdf/&#34;&gt;fdf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/push_swap/&#34;&gt;push_swap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/minishell/&#34;&gt;minishell&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/philosopher/&#34;&gt;philosopher&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_4/netpractice/&#34;&gt;netpractice&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Cristina: &amp;ldquo;Go dance salsa somewhere :)&amp;rdquo;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 다섯번째로 수행한 과제로, UNIX 동작 원리를 프로그래밍을 통해 상세히 파헤쳐보는 과제이다. Shell에서의 파이프를 구현하는 과제이며 Redriection, File discriptor, Process, Pipe, Fork 등을 공부할 수 있다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-pipex-명세서&#34;&gt;2. pipex 명세서&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2-1-mandatory-part&#34;&gt;2-1. Mandatory part&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;pipex&lt;/code&gt;는 &lt;code&gt;./pipex file1 cmd1 cmd2 file2&lt;/code&gt; 형태로 실행된다.&lt;/li&gt;&#xA;&lt;li&gt;file1과 file2는 파일 이름이다.&lt;/li&gt;&#xA;&lt;li&gt;cmd1과 cmd2는 매개 변수가 존재하는 쉘 명령어이다.&lt;/li&gt;&#xA;&lt;li&gt;프로그램은 &lt;code&gt;&amp;lt; file1 cmd1 | cmd2 &amp;gt; file2&lt;/code&gt; 명령과 동일하게 작동해야 한다.&lt;/li&gt;&#xA;&lt;li&gt;즉, file1을 input으로 받아 cmd1를 실행하고, 그 결과를 파이프를 통해 cmd2로 넘긴 후 output인 file2로 내보낸다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-2-bonus-part&#34;&gt;2-2. Bonus part&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Bonus part&lt;/code&gt; 에서는 다중 파이프와 here_doc를 구현해야 한다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;다중 파이프&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pipex : &lt;code&gt;./pipex file1 cmd1 cmd2 cmd3 ... cmdn file2&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;bash : &lt;code&gt;&amp;lt; file1 cmd1 | cmd2 | cmd3 ... | cmdn &amp;gt; file2&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;here_doc&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pipex : &lt;code&gt;./pipex here_doc LIMITER cmd cmd1 file&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;bash : &lt;code&gt;cmd &amp;lt;&amp;lt; LIMITER | cmd1 &amp;gt;&amp;gt; file&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;3-개념-정리&#34;&gt;3. 개념 정리&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;3-1-redirection&#34;&gt;3-1. Redirection&lt;/h3&gt;&#xA;&lt;p&gt;redirection은 shell에서 입력과 출력의 흐름을 재지정하는 프로세스이다. 기본적으로 커맨드는 표준 입력(stdin), 표준 출력(stdout), 그리고 표준 에러(stderr)라는 세 가지 주요 통신 채널을 사용한다. 리디렉션을 사용하면 이러한 통신 채널을 파일이나 다른 프로그램으로 전환할 수 있다. 유닉스 및 리눅스 기반 시스템에서 매우 강력한 도구로 시스템 관리, 스크립팅 및 데이터 관리에 유용하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] push_swap</title>
      <link>https://elecbrandy.github.io/posts/42cursus/circle_2/push_swap/</link>
      <pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/circle_2/push_swap/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /42cursus&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_0/libft/&#34;&gt;libft&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/ft_printf/&#34;&gt;ft_printf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/get_next_line/&#34;&gt;get_next_line&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/born2beroot/&#34;&gt;born2beroot&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/pipex/&#34;&gt;pipex&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/fdf/&#34;&gt;fdf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/push_swap/&#34;&gt;push_swap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/minishell/&#34;&gt;minishell&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/philosopher/&#34;&gt;philosopher&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_4/netpractice/&#34;&gt;netpractice&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Because Swap_push isn’t as natural&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 네번째로 수행한 과제로, 스택에 있는 데이터를 한정된 명령어를 이용하여 최대한 적은 횟수 내에 정렬하는 것을 목표로 하는 과제이다.&#xA;상당히 아이러니한 과제이다. 스택이라고 명시되어있지만, 과제에서 요구하는 구조는 스택과는 거리가 멀고, 명령어도 한정되어있다.&lt;/p&gt;&#xA;&lt;p&gt;또한 정렬 시 복잡도를 고려하는 것이 아니라 명령어 갯수만 어떻게든 줄여서 출력하면 ok를 받을 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] born2beroot</title>
      <link>https://elecbrandy.github.io/posts/42cursus/circle_1/born2beroot/</link>
      <pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/circle_1/born2beroot/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /42cursus&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_0/libft/&#34;&gt;libft&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/ft_printf/&#34;&gt;ft_printf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/get_next_line/&#34;&gt;get_next_line&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/born2beroot/&#34;&gt;born2beroot&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/pipex/&#34;&gt;pipex&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/fdf/&#34;&gt;fdf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/push_swap/&#34;&gt;push_swap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/minishell/&#34;&gt;minishell&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/philosopher/&#34;&gt;philosopher&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_4/netpractice/&#34;&gt;netpractice&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;YOU CAN DO ANYTHING YOU WANT TO DO, VIRTUAL MACHINE, THIS IS YOUR WORLD&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 네번째로 수행한 과제로, 가상머신에 리눅스를 설치하고 공부하는 과정이다. 가상머신에 리눅스(Debian or Rocky)를 설치하고, LVM를 통한 파티션 설정과 기타 여러가지 기능을 직접 실습한다. 요구사항이 상당히 많고 처음 접한다면 배워야할 개념도 상당히 많다. 리눅스 설치는 하다보면 10번 넘게 하다보니&amp;hellip; 중요한 개념 위주로만 정리했다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>File Descriptor</title>
      <link>https://elecbrandy.github.io/posts/cs101/etc/filedescriptor/</link>
      <pubDate>Sun, 24 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/etc/filedescriptor/</guid>
      <description>&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;리눅스 시스템에서는 모든 것이 파일로 취급된다. 파일뿐만 아니라 디바이스, 네트워크 연결, 디렉터리, 프로세스 역시 파일처럼 다룬다. 이때 시스템이 이러한 파일에 접근할 때 **파일 디스크립터(File Descriptor)**라는 개념을 사용한다. 파일 디스크립터는 비음수 정수(0 ~ OPEN_MAX)로, 운영 체제가 프로세스마다 부여하는 값이다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;파일 디스크립터는 프로세스에서 열린 파일들을 관리하는 테이블의 인덱스&lt;/strong&gt;이다. 예를 들어, 일반적으로 표준 입력(0), 표준 출력(1), 표준 오류(2)가 기본적으로 할당된다. FD 테이블의 각 항목은 파일 디스크립터에 대한 플래그와 파일 테이블을 가리키는 포인터를 포함하고 있으며, 이 포인터를 통해 시스템은 파일을 참조할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LVM</title>
      <link>https://elecbrandy.github.io/posts/cs101/etc/lvm/</link>
      <pubDate>Wed, 20 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/etc/lvm/</guid>
      <description>&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;LVM&lt;/strong&gt;은 Linux Volume Manager의 약어로, Linux에서 복잡한 스토리지 구성을 효율적으로 관리하기 위한 시스템이다. 물리적 디스크를 하나의 논리적 볼륨으로 결합할 수 있고, 볼륨의 크기를 쉽게 조정 가능하다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-lvm의-구성&#34;&gt;2. LVM의 구성&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;PV&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Physical Volume&lt;/li&gt;&#xA;&lt;li&gt;LVM에서 블록장치에 접근하기 위해서 PV로 초기화가 필요&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;PE&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Physical Extent&lt;/li&gt;&#xA;&lt;li&gt;PV를 구성하는 일정한 크기의 블록으로 LVM2에서 기본 크기가 4MB&lt;/li&gt;&#xA;&lt;li&gt;LV의 LE와 1:1로 대응&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;VG&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Volume Group&lt;/li&gt;&#xA;&lt;li&gt;PV들의 집합으로 LV를 할당할 수 있는 공간&lt;/li&gt;&#xA;&lt;li&gt;PV로 초기화된 장치들은 VG로 통합됨&lt;/li&gt;&#xA;&lt;li&gt;사용자는 VG 안에서 유연성 높게 공간을 쪼개 LV 생성 가능&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LV&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Logical Volume&lt;/li&gt;&#xA;&lt;li&gt;사용자가 최종적으로 다루게 되는 논리적 스토리지&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LV의 유형&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Linear LV&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;선형으로 PV를 모아 LV로 만드는 방법&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Striped LV&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;대량의 순차적 읽기/쓰기 작업의 경우 효율적으로 높일 수 있음&lt;/li&gt;&#xA;&lt;li&gt;선형이 아니라 여러 PV에 번갈아가며 기록하는 방법&lt;/li&gt;&#xA;&lt;li&gt;결국 분산기록이며, 읽고 쓰기가 병렬로 실행 가능&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Mirrored LV&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;블록 장치에 저장된 데이터의 복사본을 다른 블록 장치에 저장하는 방식&lt;/li&gt;&#xA;&lt;li&gt;백업에 용이함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LE&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;LV를 구성하는 일정한 크기의 블록으로 PE와 마찬가지로 4MB&lt;/li&gt;&#xA;&lt;li&gt;각각의 LV들은 PE들과 1:1로 맵핑됨&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;3-기존방식-vs-lvm&#34;&gt;3. 기존방식 vs LVM&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;3-1-기존-방식&#34;&gt;3-1. 기존 방식&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;File system이 물리적 블록장치와 직접 상호작용&lt;/li&gt;&#xA;&lt;li&gt;마운트된 파티션의 용량이 가득 차 이동 시&#xA;&lt;ul&gt;&#xA;&lt;li&gt;추가 디스크 장착&lt;/li&gt;&#xA;&lt;li&gt;추가된 디스크에 파티션 생성 및 포맷&lt;/li&gt;&#xA;&lt;li&gt;새로운 마운트 포인트(b)를 만들고 추가한 파티션 마운트&lt;/li&gt;&#xA;&lt;li&gt;기존 데이터를 (b)에 이동&lt;/li&gt;&#xA;&lt;li&gt;기존 파티션 언마운트 후 새 포인트와 연결&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;3-2-lvm-방식&#34;&gt;3-2. LVM 방식&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;File system이 LVM이 만든 가상의 블록 장치에 상호작용함&lt;/li&gt;&#xA;&lt;li&gt;실제 블록 장치를 추상화하여 더 유연한 접근이 가능함&lt;/li&gt;&#xA;&lt;li&gt;마운트된 파티션의 용량이 가득 차 이동 시&#xA;&lt;ul&gt;&#xA;&lt;li&gt;추가 디스크 장착&lt;/li&gt;&#xA;&lt;li&gt;추가 디스크에 Partition을 만들고 pv 초기화&lt;/li&gt;&#xA;&lt;li&gt;pv를 vg에 추가하고 해당 논리 볼륨 사이즈 증가&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;4-reference&#34;&gt;4. Reference&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://tech.cloud.nongshim.co.kr/2018/11/23/lvmlogical-volume-manager-1-%EA%B0%9C%EB%85%90/&#34;&gt;https://tech.cloud.nongshim.co.kr/2018/11/23/lvmlogical-volume-manager-1-%EA%B0%9C%EB%85%90/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://nayoungs.tistory.com/entry/Linux-LVMLogical-Volume-Manage-PV-VG-LV&#34;&gt;https://nayoungs.tistory.com/entry/Linux-LVMLogical-Volume-Manage-PV-VG-LV&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>[42cursus] get_next_line</title>
      <link>https://elecbrandy.github.io/posts/42cursus/circle_1/get_next_line/</link>
      <pubDate>Mon, 18 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/circle_1/get_next_line/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /42cursus&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_0/libft/&#34;&gt;libft&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/ft_printf/&#34;&gt;ft_printf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/get_next_line/&#34;&gt;get_next_line&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/born2beroot/&#34;&gt;born2beroot&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/pipex/&#34;&gt;pipex&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/fdf/&#34;&gt;fdf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/push_swap/&#34;&gt;push_swap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/minishell/&#34;&gt;minishell&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/philosopher/&#34;&gt;philosopher&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_4/netpractice/&#34;&gt;netpractice&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Reading a line on a fd is way too tedious&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 세번째로 수행한 과제로, 파일 디스크립터로부터 읽혀진 - 개행으로 끝나는 한 줄을 반환하는 함수를 만드는 과제이다. 즉 파일 하나를 연 다음, 파일 내용에서 개행으로 끝나는 줄 하나를 반환해야한다. 파일을 열고, 지정된 &lt;strong&gt;BUFFER_SIZE&lt;/strong&gt; 만큼 &lt;code&gt;read&lt;/code&gt;함수를 통해 파일을 읽다가 개행문자 &lt;code&gt;\n&lt;/code&gt;이 나타나면 개행문자 전까지만 반환한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] ft_printf</title>
      <link>https://elecbrandy.github.io/posts/42cursus/circle_1/ft_printf/</link>
      <pubDate>Wed, 15 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/circle_1/ft_printf/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /42cursus&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_0/libft/&#34;&gt;libft&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/ft_printf/&#34;&gt;ft_printf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/get_next_line/&#34;&gt;get_next_line&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/born2beroot/&#34;&gt;born2beroot&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/pipex/&#34;&gt;pipex&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/fdf/&#34;&gt;fdf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/push_swap/&#34;&gt;push_swap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/minishell/&#34;&gt;minishell&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/philosopher/&#34;&gt;philosopher&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_4/netpractice/&#34;&gt;netpractice&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;putnbr and putstr aren’t enough&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 두번째로 수행한 과제로, 말 그대로 C언어의 &lt;code&gt;printf&lt;/code&gt; 함수를 재현하는 과제이다. bonus는 수행하지 않았고, 기본적인 내용만 구현하다보니 생각보다 난이도가 쉬웠던 것 같다. libc의 &lt;code&gt;printf&lt;/code&gt; 함수를 재구현해야 하며, 실제 &lt;code&gt;printf&lt;/code&gt;처럼 버퍼 관리를 수행해서는 안 된다. 서식 지정자 &lt;code&gt;cspdiuxX%&lt;/code&gt;를 구현해야한다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-ft_printf-명세서&#34;&gt;2. ft_printf 명세서&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;PROTOTYPE&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;int ft_printf(const char *str, ...);&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;PARAMETER&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;const char *str&lt;/code&gt; : format 이라는 이름의 문자열 상수 (서식 문자열)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;...&lt;/code&gt; : 생략 기호로, 두번째 이후 인수부터는 인수의 개수와 타입을 점검하지 않으며, 컴파일러는 이후의 인수에 대해서 개수, 타입에 상관없이 그대로 함수에 넘겨줌&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;DESCRIPTION&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;%c&lt;/code&gt; 단일 문자를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%s&lt;/code&gt; 문자열을 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%p&lt;/code&gt; void * 포인터 인수는 16진수 형식으로 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%d&lt;/code&gt; 십진수(기본 10)를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%i&lt;/code&gt; 기본 10의 정수를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%u&lt;/code&gt; 부호 없는 10진수(베이스 10)를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%x&lt;/code&gt; 16진수(베이스 16) 소문자 형식으로 숫자를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%X&lt;/code&gt; 16진수(베이스 16) 대문자 형식으로 숫자를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%%&lt;/code&gt; 백분율 기호를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;External functs&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;malloc, free, write&lt;/li&gt;&#xA;&lt;li&gt;va_start, va_arg, va_copy, va_end&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RETURN VALUES&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;em&gt;Upon successful return, these functions return the number of characters printed (excluding the null byte used to end output to strings).&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;성공적으로 반환되면, 이 함수들은 인쇄된 문자 수를 반환합니다.(출력을 끝내는 데 사용되는 널 바이트 제외) 문자열을 반환함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;3-개념-정리&#34;&gt;3. 개념 정리&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;3-1-가변인자&#34;&gt;3-1. 가변인자&lt;/h3&gt;&#xA;&lt;p&gt;가변인자 다루는 것에 중점을 둔 과제인 만큼, &lt;code&gt;va_&lt;/code&gt; 함수를 통해 가변인자를 통제하는 방법을 알아야한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] libft</title>
      <link>https://elecbrandy.github.io/posts/42cursus/circle_0/libft/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/circle_0/libft/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /42cursus&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_0/libft/&#34;&gt;libft&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/ft_printf/&#34;&gt;ft_printf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/get_next_line/&#34;&gt;get_next_line&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_1/born2beroot/&#34;&gt;born2beroot&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/pipex/&#34;&gt;pipex&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/fdf/&#34;&gt;fdf&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_2/push_swap/&#34;&gt;push_swap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/minishell/&#34;&gt;minishell&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_3/philosopher/&#34;&gt;philosopher&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/42cursus/circle_4/netpractice/&#34;&gt;netpractice&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Your very first own library&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 첫번째로 만나는 과제로 앞으로 본과정에서 사용할 라이브러리를 만드는 것이 목표이다.&#xA;이후 과제를 수행하며 자주 사용할 함수들이 몇가지 있기 때문에 최대한 범용성 높게 - 커스텀하기 쉽게 만드는 것을 목표로 했다.&#xA;항상 느끼는 것이지만 &lt;code&gt;norm&lt;/code&gt; 규칙의 첫번째 목표는 카뎃이 다른 카뎃의 코드를 보았을 때 최소한의 일관성을 유지하여 쉽게 읽을 수 있게 하는 것&amp;hellip; 이고&#xA;두번째는 코드 길이를 적당히 조절함으로써 자연스럽게 모듈화를 하게 하는 것. 그 이상의 의미는 두지 않기로 했다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>컴파일 언어의 빌드</title>
      <link>https://elecbrandy.github.io/posts/cs101/etc/compile_0/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/etc/compile_0/</guid>
      <description>&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;무엇인가를 빌드한다는 것은 어떤 것일까? 내가 만든 프로그램을 컴퓨터가 읽는 과정은 어떻게 될까?&lt;/p&gt;&#xA;&lt;p&gt;빌드는 소스 코드를 컴파일, 어셈블, 링크하는 일련의 과정을 통해 기계가 실행할 수 있는 실행 파일로 변환하는 과정이다. 이번에는 흔히 &lt;code&gt;C&lt;/code&gt; 처럼 소스 코드가 실행되기 전에 컴파일러를 통해 기계어로 변환된 후 실행되는 프로그래밍 언어(&lt;strong&gt;컴파일 언어&lt;/strong&gt;)의 빌드 과정을 알아보자!&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-빌드-과정&#34;&gt;2. 빌드 과정&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2-1-preprocessing-전처리&#34;&gt;2-1. Preprocessing (전처리)&lt;/h3&gt;&#xA;&lt;p&gt;전처리는 **전처리기(&lt;code&gt;cpp&lt;/code&gt;)**에 의해 수행된다. 이 단계에서는 소스 코드가 컴파일되기 전에 미리 준비해야 하는 작업들이 처리된다. 주요 작업은 다음과 같다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>2023 데이터 청년 캠퍼스</title>
      <link>https://elecbrandy.github.io/posts/ai/dataonair/</link>
      <pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/ai/dataonair/</guid>
      <description>&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;2023 데이터 청년 캠퍼스 경제/금융분야 페이크 뉴스 탐지 시스템 구축을 주제로&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;3학년 여름방학에 데이터와 코딩 관련 경험을 해보고자 과학기술정보통신부와 한국데이터산업진흥원에서 국내 대학교와 함께 운영하는 &lt;strong&gt;2023 데이터 청년 캠퍼스&lt;/strong&gt;에 신청했다. 사실 그렇게 전공이라고 보기에 애매한 상황에서 붙을 수 있을까 고민했는데, 다행히 선발되어 상명대학교 데이터융합과정 (빅데이터 분석 기반 금융분야 비즈니스 인사이트 역량제고 과정)에 참여하게 되었다. 크게 4주 동안의 집체교육, 이후 6주 동안의 프로젝트 기간으로 구성되어있으며 집체교육 동안에는 파이썬 기초부터 ~ 딥러닝(&amp;hellip;의 형상을 하고있는 무언가)를 공부하게된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>사용성테스트 101</title>
      <link>https://elecbrandy.github.io/posts/uiux/ut101/</link>
      <pubDate>Tue, 01 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/uiux/ut101/</guid>
      <description>&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;유저들은 우리 서비스를 &lt;em&gt;잘&lt;/em&gt; 이용하고 있을까?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;심혈을 기울여 만든 기능 혹은 버튼을 유저들은 잘 이용하고 있을까? 혹은 이번에 새로 리뉴얼한 메인 화면 구성은 기획자의 의도대로 유저들에게 더 나은 경험을 제공하고 있을까? 이러한 궁금증을 풀기 위해서는 실제 유저가 어떻게 행동하는지 즉각적으로 확인할 수 있는 사용성 테스트가 효과적이다. 사용성 테스트는 &amp;ldquo;어떤 것을 유저가 좋아할까?&amp;ldquo;라는 질답을 넘어 &amp;ldquo;어떤 것이 효과적인가?&amp;ldquo;를 겨냥하고 있다.&lt;/p&gt;&#xA;&lt;p&gt;또한 단순히 UI로는 특정 기능을 다음에 사용할 것인지, 얼마나 많은 사람이 해당 기능을 좋아할지, 얼마나 사용률이 증가할지 알 수 없기 때문에 사용성 테스트를 통해 빈 공간을 보완하는 작업이 필요하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>유저리서치 101</title>
      <link>https://elecbrandy.github.io/posts/uiux/ux101/</link>
      <pubDate>Sun, 17 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/uiux/ux101/</guid>
      <description>&lt;br&gt;&#xA;&lt;h2 id=&#34;1-ux리서치에-대한-오해와-진실&#34;&gt;1. UX리서치에 대한 오해와 진실&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;ldquo;우리 서비스 좋죠?&amp;rdquo; 금지! &amp;ldquo;왜 해당 기능을 사용 안하시나요?&amp;rdquo; 금지!&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;리서치를 통해 매번 놀랍고 새로운 발견? 그것보다는 개선에 도움을 줄 수 있음&lt;/li&gt;&#xA;&lt;li&gt;사용자에 대한 일반적인 정보를 수집? 그것보다는 구체적인 연구 목표를 정의해야함&lt;/li&gt;&#xA;&lt;li&gt;어설픈 사용자 조사를 하는 것 보다 어떤 사용자 조사도 하지 않는 것이 더 좋음&lt;/li&gt;&#xA;&lt;li&gt;사용자의 답변을… 믿으면 안됨. A를 고르고 B처럼 행동하는 유저가 한가득&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-유저-리서치-방법론&#34;&gt;2. 유저 리서치 방법론&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2-1-정성-조사&#34;&gt;2-1. 정성 조사&lt;/h3&gt;&#xA;&lt;p&gt;보통 집단을 대표할 수 있는 소규모 그룹과 기초적 원인, 동기에 대한 질적인 이해 목적으로 진행한다. 단, 표본 수 자체가 적어 신뢰도에 문제가 있을 수 있음!&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
