<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on Elecbrandy</title>
    <link>https://elecbrandy.github.io/tags/c/</link>
    <description>Recent content in C on Elecbrandy</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 15 Aug 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://elecbrandy.github.io/tags/c/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[42cursus] netpractice</title>
      <link>https://elecbrandy.github.io/posts/42cursus/circle_4/netpractice/</link>
      <pubDate>Thu, 15 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/circle_4/netpractice/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;This document is a System Administration related exercise.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;소개&#34;&gt;소개&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;https://i.imgur.com/UCUbHvr.png&#34; width=&#34;700&#34;&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 n번째로 수행한 과제로, 교육 인터페이스상에서 소규모 네트워크를 구성하는 과제이다. 네트워킹 문제를 해결하여 네트워크가 실행되도록 만들어야 한다. 총 10개의 문제를 완료하고, Git 저장소에 제출하는 것이 최종 목표이다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;개념-정리&#34;&gt;개념 정리&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;네트워크란&#34;&gt;네트워크란?&lt;/h2&gt;&#xA;&lt;p&gt;네트워크는 두 대 이상의 컴퓨터 시스템이 서로 연결되어 데이터를 교환할 수 있는 구조를 의미한다. 이 연결은 다양한 방법으로 이루어질 수 있으며, 물리적 케이블, 무선 신호, 또는 혼합된 방식으로 네트워크를 구성할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] pipex</title>
      <link>https://elecbrandy.github.io/posts/42cursus/circle_2/pipex/</link>
      <pubDate>Wed, 28 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/circle_2/pipex/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Cristina: &amp;ldquo;Go dance salsa somewhere :)&amp;rdquo;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;소개&#34;&gt;소개&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 다섯번째로 수행한 과제로, UNIX 동작 원리를 프로그래밍을 통해 상세히 파헤쳐보는 과제이다.&#xA;Shell에서의 파이프를 구현하는 과제이며 Redriection, File discriptor, Process, Pipe, Fork 등을 공부할 수 있다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;pipex-명세서&#34;&gt;pipex 명세서&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;mandatory-part&#34;&gt;Mandatory part&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;pipex&lt;/code&gt;는 &lt;code&gt;./pipex file1 cmd1 cmd2 file2&lt;/code&gt; 형태로 실행된다.&lt;/li&gt;&#xA;&lt;li&gt;file1과 file2는 파일 이름이다.&lt;/li&gt;&#xA;&lt;li&gt;cmd1과 cmd2는 매개 변수가 존재하는 쉘 명령어이다.&lt;/li&gt;&#xA;&lt;li&gt;프로그램은 &lt;code&gt;&amp;lt; file1 cmd1 | cmd2 &amp;gt; file2&lt;/code&gt; 명령과 동일하게 작동해야 한다.&lt;/li&gt;&#xA;&lt;li&gt;즉, file1을 input으로 받아 cmd1를 실행하고, 그 결과를 파이프를 통해 cmd2로 넘긴 후 output인 file2로 내보낸다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;bonus-part&#34;&gt;Bonus part&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Bonus part&lt;/strong&gt;에서는 다중 파이프와 here_doc를 구현해야 한다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;다중 파이프&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pipex : &lt;code&gt;./pipex file1 cmd1 cmd2 cmd3 ... cmdn file2&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;bash : &lt;code&gt;&amp;lt; file1 cmd1 | cmd2 | cmd3 ... | cmdn &amp;gt; file2&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;here_doc&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pipex : &lt;code&gt;./pipex here_doc LIMITER cmd cmd1 file&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;bash : &lt;code&gt;cmd &amp;lt;&amp;lt; LIMITER | cmd1 &amp;gt;&amp;gt; file&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;개념-정리&#34;&gt;개념 정리&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;redirection&#34;&gt;Redirection&lt;/h2&gt;&#xA;&lt;p&gt;redirection은 shell에서 입력과 출력의 흐름을 재지정하는 프로세스이다. 기본적으로 커맨드는 표준 입력(stdin), 표준 출력(stdout), 그리고 표준 에러(stderr)라는 세 가지 주요 통신 채널을 사용한다. 리디렉션을 사용하면 이러한 통신 채널을 파일이나 다른 프로그램으로 전환할 수 있다. 유닉스 및 리눅스 기반 시스템에서 매우 강력한 도구로 시스템 관리, 스크립팅 및 데이터 관리에 유용하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] push_swap</title>
      <link>https://elecbrandy.github.io/posts/42cursus/circle_2/push_swap/</link>
      <pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/circle_2/push_swap/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Because Swap_push isn’t as natural&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;소개&#34;&gt;소개&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 네번째로 수행한 과제로, 스택에 있는 데이터를 한정된 명령어를 이용하여 최대한 적은 횟수 내에 정렬하는 것을 목표로 하는 과제이다.&#xA;상당히 아이러니한 과제이다. 스택이라고 명시되어있지만, 과제에서 요구하는 구조는 스택과는 거리가 멀고, 명령어도 한정되어있다.&lt;/p&gt;&#xA;&lt;p&gt;또한 정렬 시 복잡도를 고려하는 것이 아니라 명령어 갯수만 어떻게든 줄여서 출력하면 ok를 받을 수 있다.&lt;/p&gt;&#xA;&lt;p&gt;그렇다보니 가장 많이 쓰이는 방법이 그리디 알고리즘를 통해 모든 정렬 경우의 수를 먼저 체크하고, 명령어 수를 최적화하여 이후에 출력하는 것이다.&#xA;정렬 시 사용한 명령어 개수에 따라 점수가 달라질 수 있다. (&lt;strong&gt;기수 정렬&lt;/strong&gt;도 하나의 방법!)&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] born2beroot</title>
      <link>https://elecbrandy.github.io/posts/42cursus/circle_1/born2beroot/</link>
      <pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/circle_1/born2beroot/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;YOU CAN DO ANYTHING YOU WANT TO DO, VIRTUAL MACHINE, THIS IS YOUR WORLD&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;소개&#34;&gt;소개&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;https://user-images.githubusercontent.com/87311268/221544778-c85cb3d8-32f4-4919-aa1c-0db54b33b38a.jpg&#34; width=&#34;700&#34;&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 네번째로 수행한 과제로, 가상머신에 리눅스를 설치하고 공부하는 과정이다.&lt;/p&gt;&#xA;&lt;p&gt;가상머신에 리눅스(Debian or Rocky)를 설치하고, LVM를 통한 파티션 설정과 기타 여러가지 기능을 직접 실습한다. 백문불여일견. 요구사항이 상당히 많고 처음 접한다면 배워야할 개념도 상당히 많다&amp;hellip; 화이팅!&#xA;리눅스 설치는 하다보면 100번이라도 해야만 하는 상황이기 때문에 중요한 개념 위주로만 정리했다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;개념-정리&#34;&gt;개념 정리&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;운영체제&#34;&gt;운영체제&lt;/h2&gt;&#xA;&lt;p&gt;Operating System은 응용 프로그램 또는 사용자에게 컴퓨터 자원을 사용할 수 있는 인터페이스를 제공하고, 그 결과를 돌려주는 시스템 소프트웨어이다. CPU, Memory, 저장장치 등의 하드웨어를 관리하고 Process 관리, 자원 접근 및 할당, 파일 시스템을 관리한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>File descriptor</title>
      <link>https://elecbrandy.github.io/posts/cs101/filedescriptor/</link>
      <pubDate>Sun, 24 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/filedescriptor/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;운영 체제에서 파일이나 입출력 자원을 식별하기 위해 사용하는&amp;hellip;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;p&gt;&lt;code&gt;Libft&lt;/code&gt; 과제에 이어 &lt;code&gt;get_next_line&lt;/code&gt; 과제를 진행하던 중 파일 디스크립터 개념을 만나게 되어 정리했다. 결국은 파일에게 접근하기 위한 번호이자 거창하게는 파일 포인터 개념으로 이해하고 넘어가자.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;file-descripot&#34;&gt;File Descripot&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;리눅스 시스템에서는 모든 것이 파일&#xA;&lt;ul&gt;&#xA;&lt;li&gt;객체, 행동, 디바이스, 네트워크 연결, 디렉터리, 프로세스 등등&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;이때 시스템이 이 파일들에게 접근 시 File Descriptor라는 개념을 이용함&lt;/li&gt;&#xA;&lt;li&gt;File Descriptor는 Non-negative Integer 값을 가짐(0 ~ OPEN_MAX)&lt;/li&gt;&#xA;&lt;li&gt;Process에서 열린 파일의 목록을 관리하는 테이블의 인덱스! (0, 1, 2는 기본 할당)&lt;/li&gt;&#xA;&lt;li&gt;FD 테이블의 각 항목은 FD 플래그와 파일 테이블로의 포인터와 같음&lt;/li&gt;&#xA;&lt;li&gt;이 포인터를 이용하여 FD 를 통해 시스템의 파일을 참조!&lt;/li&gt;&#xA;&lt;li&gt;Process는 이런 FD 테이블과 파일 테이블의 정보를 직접 고칠 수 없으며, 반드시 커널을 통해서 수정을 해야함&lt;/li&gt;&#xA;&lt;li&gt;프로그램에서 FD 참조시 index를 사용할 수도 있고, POSIX 명을 사용할 수도 있음&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;fd와-열려-있는-파일의-관계&#34;&gt;FD와 열려 있는 파일의 관계&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;각 프로세스별로 커널은 &lt;code&gt;open file descriptor table&lt;/code&gt; 을 가짐&lt;/li&gt;&#xA;&lt;li&gt;테이블의 각 엔트리는 하나의 FD에 대한 동작 제어 플래그, 열린 파일을 가리키는 참조를 담고 있음&lt;/li&gt;&#xA;&lt;li&gt;특히 &lt;code&gt;open file descriptor table&lt;/code&gt; 현재 파일의 Offset, flag, 접근 모드 ,i/o 관련 설정, 파일의 i-node 객체를 가리키는 정보를 담고 있음&lt;/li&gt;&#xA;&lt;li&gt;같은 &lt;code&gt;open file descripton&lt;/code&gt; 을 가르키는 2개의 FD가 Offset 값을 공유함&#xA;&lt;ul&gt;&#xA;&lt;li&gt;간단한 예시&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;file.txt&lt;/code&gt; 열고 두 개의 파일 디스크립터를 얻는다.&lt;/li&gt;&#xA;&lt;li&gt;FD1을 이용해서 파일 처음으로 이동한다. (offset 0)&lt;/li&gt;&#xA;&lt;li&gt;FD2을 이용해서 파일 어딘가로 이동한다. (offset 100)&lt;/li&gt;&#xA;&lt;li&gt;FD1과 FD2는 동일한 파일 &lt;code&gt;file.txt&lt;/code&gt;를 가리키지만 FD1은 파일의 처음 / FD2는 파일의 어딘가를  가리킨다.&lt;/li&gt;&#xA;&lt;li&gt;이렇게 동시에 한 파일을 여러 위치에서 읽고 쓸 수 있다.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;정리&#34;&gt;정리&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;file.txt&lt;/code&gt; 를 열면 OS는 &lt;code&gt;open file descriptor table&lt;/code&gt;에 해당 항목을 추가한다.&lt;/li&gt;&#xA;&lt;li&gt;이때 인덱스는 &lt;code&gt;file.txt&lt;/code&gt; 를 가르킨다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;file.txt&lt;/code&gt; 를 닫으면 테이블에서 해당 인덱스가 사라진다.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=EqndHT606Tw&#34;&gt;https://www.youtube.com/watch?v=EqndHT606Tw&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=btT4HDKNIOw&#34;&gt;https://www.youtube.com/watch?v=btT4HDKNIOw&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dev-ahn.tistory.com/96&#34;&gt;https://dev-ahn.tistory.com/96&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;div class=&#34;alert&#34;&gt;&#xA;    &lt;span&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/CS101&#34;&gt; CS101 &lt;/a&gt;&lt;/span&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;</description>
    </item>
    <item>
      <title>[42cursus] get_next_line</title>
      <link>https://elecbrandy.github.io/posts/42cursus/circle_1/get_next_line/</link>
      <pubDate>Mon, 18 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/circle_1/get_next_line/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Reading a line on a fd is way too tedious&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;소개&#34;&gt;소개&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;https://imgur.com/2R4ZmUq.png&#34; width=&#34;700&#34;&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 세번째로 수행한 과제로, 파일 디스크립터로부터 읽혀진 - 개행으로 끝나는 한 줄을 반환하는 함수를 만드는 과제이다. 즉 파일 하나를 연 다음, 파일 내용에서 개행으로 끝나는 줄 하나를 반환해야한다. 파일을 열고, 지정된 &lt;strong&gt;BUFFER_SIZE&lt;/strong&gt; 만큼 &lt;code&gt;read&lt;/code&gt;함수를 통해 파일을 읽다가 개행문자 &lt;code&gt;\n&lt;/code&gt;이 나타나면 개행문자 전까지만 반환한다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;get_next_line-명세서&#34;&gt;get_next_line 명세서&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;PROTOTYPE&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;char *get_next_line(int fd);&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;PARAMETER&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;int fd&lt;/code&gt; : 읽어들일 파일의 디스크립터&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;DESCRIPTION&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Mandatory part&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;호출마다 한 번에 한 줄씩 파일 디스크립터가 가리키는 파일을 읽어온다.&lt;/li&gt;&#xA;&lt;li&gt;더 이상 읽어올 것이 없거나 에러가 발생하면 &lt;code&gt;NULL&lt;/code&gt;을 반환한다.&lt;/li&gt;&#xA;&lt;li&gt;파일 끝에 도달하였고, 개행문자 &lt;code&gt;\n&lt;/code&gt;이 존재하지 않을 때를 제외하고 반환하는 문자열에는 &lt;code&gt;\n&lt;/code&gt;이 포함되어야 한다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Bonus part&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;정적 변수를 하나만 사용하여 개발해야한다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;get_next_line()&lt;/code&gt; 이 여러 개의 파일 디스크립터를 한번에 관리해야 한다.&lt;/li&gt;&#xA;&lt;li&gt;한번 호출하여 3, 4, 5 그 이후 다시 4, 5 등등을 읽을 수 있어야 한다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;External functs&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;read, malloc, free&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RETURN VALUES&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;한 줄을 제대로 읽은 정상작동의 경우 읽은 라인을 반환한다.&lt;/li&gt;&#xA;&lt;li&gt;비정상작동의 경우 &lt;code&gt;NULL&lt;/code&gt;을 반환한다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;개념-정리&#34;&gt;개념 정리&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;연결리스트와-open_max&#34;&gt;연결리스트와 OPEN_MAX&lt;/h2&gt;&#xA;&lt;p&gt;본 과제를 &lt;strong&gt;BONUS&lt;/strong&gt;까지 수행한다면, 즉 동시에 여러 파일 디스크립터를 감안하는 프로그램을 만들고 싶다면 크게 두가지 방법이 존재한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] ft_printf</title>
      <link>https://elecbrandy.github.io/posts/42cursus/circle_1/ft_printf/</link>
      <pubDate>Wed, 15 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/circle_1/ft_printf/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;putnbr and putstr aren’t enough&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;소개&#34;&gt;소개&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 두번째로 수행한 과제로, 말 그대로 C언어의 &lt;code&gt;printf&lt;/code&gt; 함수를 재현하는 과제이다. bonus는 수행하지 않았고, 기본적인 내용만 구현하다보니 생각보다 난이도가 쉬웠던 것 같다. libc의 &lt;code&gt;printf&lt;/code&gt; 함수를 재구현해야 하며, 실제 &lt;code&gt;printf&lt;/code&gt;처럼 버퍼 관리를 수행해서는 안 된다. 서식 지정자 &lt;code&gt;cspdiuxX%&lt;/code&gt;를 구현해야한다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;ft_printf-명세서&#34;&gt;ft_printf 명세서&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;PROTOTYPE&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;int ft_printf(const char *str, ...);&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;PARAMETER&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;const char *str&lt;/code&gt; : format 이라는 이름의 문자열 상수 (서식 문자열)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;...&lt;/code&gt; : 생략 기호로, 두번째 이후 인수부터는 인수의 개수와 타입을 점검하지 않으며, 컴파일러는 이후의 인수에 대해서 개수, 타입에 상관없이 그대로 함수에 넘겨줌&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;DESCRIPTION&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;%c&lt;/code&gt; 단일 문자를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%s&lt;/code&gt; 문자열을 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%p&lt;/code&gt; void * 포인터 인수는 16진수 형식으로 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%d&lt;/code&gt; 십진수(기본 10)를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%i&lt;/code&gt; 기본 10의 정수를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%u&lt;/code&gt; 부호 없는 10진수(베이스 10)를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%x&lt;/code&gt; 16진수(베이스 16) 소문자 형식으로 숫자를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%X&lt;/code&gt; 16진수(베이스 16) 대문자 형식으로 숫자를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%%&lt;/code&gt; 백분율 기호를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;External functs&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;malloc, free, write&lt;/li&gt;&#xA;&lt;li&gt;va_start, va_arg, va_copy, va_end&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RETURN VALUES&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;em&gt;Upon successful return, these functions return the number of characters printed (excluding the null byte used to end output to strings).&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;성공적으로 반환되면, 이 함수들은 인쇄된 문자 수를 반환합니다.(출력을 끝내는 데 사용되는 널 바이트 제외) 문자열을 반환함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;개념-정리&#34;&gt;개념 정리&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;가변인자&#34;&gt;가변인자&lt;/h2&gt;&#xA;&lt;p&gt;가변인자 다루는 것에 중점을 둔 과제인 만큼, &lt;code&gt;va_&lt;/code&gt; 함수를 통해 가변인자를 통제하는 방법을 알아야한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] libft</title>
      <link>https://elecbrandy.github.io/posts/42cursus/circle_0/libft/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/circle_0/libft/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Your very first own library&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;소개&#34;&gt;소개&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 첫번째로 만나는 과제로 앞으로 본과정에서 사용할 라이브러리를 만드는 것이 목표이다.&#xA;이후 과제를 수행하며 자주 사용할 함수들이 몇가지 있기 때문에 최대한 범용성 높게 - 커스텀하기 쉽게 만드는 것을 목표로 했다.&#xA;항상 느끼는 것이지만 &lt;code&gt;norm&lt;/code&gt; 규칙의 첫번째 목표는 카뎃이 다른 카뎃의 코드를 보았을 때 최소한의 일관성을 유지하여 쉽게 읽을 수 있게 하는 것&amp;hellip; 이고&#xA;두번째는 코드 길이를 적당히 조절함으로써 자연스럽게 모듈화를 하게 하는 것. 그 이상의 의미는 두지 않기로 했다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>C build</title>
      <link>https://elecbrandy.github.io/posts/cs101/buildc/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/buildc/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;컴파일 언어(compiled language)는 코드가 실행되기 전 컴파일러를 거쳐서 기계어로 모두 변환되어 실행되는 프로그래밍 언어이다.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-preprocess&#34;&gt;1. Preprocess&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;전처리기 &lt;strong&gt;cpp&lt;/strong&gt; 에 의해 수행&lt;/li&gt;&#xA;&lt;li&gt;header inclusion&#xA;&lt;ul&gt;&#xA;&lt;li&gt;헤더 파일에 정의된 변수와 함수를 포함하는 과정&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;macro expansion&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;#define&lt;/code&gt; 같은 매크로 등을 소스코드로 변경&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;.c&lt;/code&gt;&lt;/strong&gt; -&amp;gt; &lt;strong&gt;&lt;code&gt;.i&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-complie&#34;&gt;2. Complie&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;컴파일러 &lt;strong&gt;ccl&lt;/strong&gt; 에 의해 수행&lt;/li&gt;&#xA;&lt;li&gt;c언어 코드를 어셈블리어로 변환&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;.i&lt;/code&gt;&lt;/strong&gt; -&amp;gt; &lt;strong&gt;&lt;code&gt;.s&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;3-assemble&#34;&gt;3. Assemble&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;어셈블러 &lt;strong&gt;as&lt;/strong&gt; 에 의해 수행&lt;/li&gt;&#xA;&lt;li&gt;어셈블리어를 바이너리 형태로 변환 (목적 파일 생성)&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;.s&lt;/code&gt;&lt;/strong&gt; -&amp;gt; &lt;strong&gt;&lt;code&gt;.o&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;4-link&#34;&gt;4. Link&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;여러 목적파일과 라이브러리들을 모아 실행 가능한 단일 파일로 결합&lt;/li&gt;&#xA;&lt;li&gt;정적 라이브러리도 함께 결합됨&#xA;&lt;ul&gt;&#xA;&lt;li&gt;라이브러리는 이미 컴파일 되어있으므로 링크만 하면 바로 사용 가능&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;빌드 과정의 마지막 단계로서, 실행 파일이 생성되면 프로그램이 &lt;strong&gt;빌드&lt;/strong&gt;되었다고 함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;5-runtime&#34;&gt;5. &lt;strong&gt;Runtime&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;목적 파일 처럼 중간 과정을 거치는 이유?&#xA;&lt;ul&gt;&#xA;&lt;li&gt;소스를 각기 다른 언어로 작성했을 수도 있음&lt;/li&gt;&#xA;&lt;li&gt;한 파일에 모든 함수나 기능을 넣는 것이 비효율적이고 불가능에 가까움&lt;/li&gt;&#xA;&lt;li&gt;결국 쪼개진 각기 다른 여러 파일을 잘 합치기 위함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;div class=&#34;alert&#34;&gt;&#xA;    &lt;span&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/CS101&#34;&gt; CS101 &lt;/a&gt;&lt;/span&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;</description>
    </item>
    <item>
      <title>Makefile</title>
      <link>https://elecbrandy.github.io/posts/cs101/makefile/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/makefile/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;The script that automates software build processes with the make utility&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;p&gt;&lt;code&gt;Makefile&lt;/code&gt; 은 소프트웨어 개발 과정에서 빌드를 자동화하는 강력한 도구이다. 복잡한 빌드 단계를 단순하고 반복 가능하게 만들어 주는 것이 핵심 기능이다. 프로그래머들에게 시간을 절약하고 오류를 줄여주는 데 큰 도움을 준다.&#xA;&lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;makefile&#34;&gt;Makefile&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Makefile&lt;/code&gt; 이란 자동화, 의존성 관리, 효율성, 모듈성, 표준화를 목적으로 함&#xA;&lt;ul&gt;&#xA;&lt;li&gt;자동화&#xA;&lt;ul&gt;&#xA;&lt;li&gt;복잡한 빌드 명령어를 자동화하여 개발자가 빌드 프로세스를 쉽게 반복&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;의존성 관리&#xA;&lt;ul&gt;&#xA;&lt;li&gt;소스 파일과 헤더 파일 간의 의존성을 추적하여 변경 시에만 관련 파일을 재컴파일&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;효율성&#xA;&lt;ul&gt;&#xA;&lt;li&gt;전체 프로젝트를 빌드하는 대신 변경된 부분만 빌드하여 시간과 자원을 절약&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;모듈성&#xA;&lt;ul&gt;&#xA;&lt;li&gt;빌드 프로세스를 여러 단계로 분리하여 복잡성을 관리해 유지보수가 용이&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;표준화&#xA;&lt;ul&gt;&#xA;&lt;li&gt;일관된 빌드 절차로 다른 개발자가 쉽게 이해하고 사용할 수 있음&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Makefile&lt;/code&gt; 의 기본적 구성&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;target&lt;/code&gt; : 하나의 실행 가능 파일&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;dependency&lt;/code&gt; : 하나의 대상과 그것이 의존하는 소스파일&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;rule&lt;/code&gt; : 의존 파일들로부터 대상 파일을 생성하는 방법을 정의&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;예시&#34;&gt;예시&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Makefile&#34; data-lang=&#34;Makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CC &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cc&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CFLAGS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; -Wall -Wextra -Werror&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;INS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; .&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; libft.a&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;cc&lt;/code&gt; 컴파일러와 &lt;code&gt;-Wall -Wextra -Werror&lt;/code&gt; 옵션을 이용할 예정&lt;/li&gt;&#xA;&lt;li&gt;헤더파일을 검색할 곳은 &lt;code&gt;.&lt;/code&gt; 즉 현재 폴더&lt;/li&gt;&#xA;&lt;li&gt;최종으로 만들 것 &lt;code&gt;libft.a&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Makefile&#34; data-lang=&#34;Makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SRCS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ~.c&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OBJS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;SRCS:.c&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;.o&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SRC_BONUS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ~~.c&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OBJS_BONUS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;SRC_BONUS:.c&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;.o&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SRCS&lt;/code&gt; 는 사용자가 설정한 &lt;code&gt;.c&lt;/code&gt; 확장자 파일을 뜻하며, &lt;code&gt;SRCS&lt;/code&gt; 에서 파생된 &lt;code&gt;.o&lt;/code&gt; 파일을 &lt;code&gt;OBJS&lt;/code&gt; 라고 정의함&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SRCS_BONUS&lt;/code&gt; 는 사용자가 설정한 &lt;code&gt;.c&lt;/code&gt; 확장자 파일을 뜻하며, &lt;code&gt;SRCS_BONUS&lt;/code&gt; 에서 파생된 &lt;code&gt;.o&lt;/code&gt; 파일을 &lt;code&gt;OBJS_BONUS&lt;/code&gt; 라고 정의함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Makefile&#34; data-lang=&#34;Makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;all &lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;NAME&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;$(NAME) &lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;OBJS&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;ar -rc $@ $^&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;$(NAME)&lt;/code&gt; 라는 의존성 파일로부터 타겟인 &lt;code&gt;all&lt;/code&gt; 을 생성(하겠음)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;$(OBJS)&lt;/code&gt; 라는 의존성 파일로부터 타겟인 &lt;code&gt;$(NAME)&lt;/code&gt; 을 생성(하겠음)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;ar&lt;/code&gt; : 아카이브 유틸리티를 의미하며 정적 라이브러리를 생성, 수정 시 사용&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-r&lt;/code&gt; : &lt;code&gt;ar&lt;/code&gt; 에 주어진 옵션으로, 라이브러리에 파일을 추가하거나 기존 파일을 대체하라는 의미&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-c&lt;/code&gt; : &lt;code&gt;ar&lt;/code&gt; 에 주어진 옵션으로, 라이브러리 생성 시 경고메세지를 억제하라는 의미&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;$@&lt;/code&gt; : 현재 타겟을 의미하는 자동 변수&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;$^&lt;/code&gt; : 현재 모든 의존성 리스트를 의미하는 자동변수&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Makefile&#34; data-lang=&#34;Makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;ifdef&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;tmp&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;OBJS &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;OBJS&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;OBJS_BONUS&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;endif&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bonus &lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;@tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; make&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;bonus&lt;/code&gt; 명령어의 경우 &lt;code&gt;tmp=1&lt;/code&gt; 경우의 &lt;code&gt;make&lt;/code&gt; 를 수행함&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;@&lt;/code&gt; 의 경우 명령어의 출력을 가려줌&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Makefile&#34; data-lang=&#34;Makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;%.o&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; %.c&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;CC&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;CFLAGS&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt; -c $&amp;lt; -o $@ -I&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;INS&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;%.c&lt;/code&gt; 라는 의존성 파일로부터 타겟인 &lt;code&gt;%.o&lt;/code&gt; 를 생성(하겠음)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;$(CC) $(CFLAGS)&lt;/code&gt; : 앞서 설정한 다양한 변수에 담긴 내용&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-c&lt;/code&gt; : 컴파일러에게 컴파일만하고 링킹을 하지 말라는 옵션 only compile&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;$&amp;lt;&lt;/code&gt; : 현재 의존성 목록에서 첫 번째 요소로, 현재 처리 중인 &lt;code&gt;.c&lt;/code&gt; 파일&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-o $@&lt;/code&gt; : 출력 파일로 , &lt;code&gt;$@&lt;/code&gt; 는 현재 타겟을 의미&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-I$(INS)&lt;/code&gt; : 컴파일러에게 include files의 위치를 알려줌&#xA;&lt;ul&gt;&#xA;&lt;li&gt;여기서 $(INS)는 include 디렉터리를 지정하는 변수!&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Makefile&#34; data-lang=&#34;Makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;clean &lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;rm -f &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;OBJS&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;OBJS_BONUS&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fclean &lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; clean&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;rm -f &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;NAME&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;re &lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; fclean all&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;clean&lt;/code&gt; 의 경우 &lt;code&gt;rm -f $(OBJS) $(OBJS_BONUS)&lt;/code&gt; 를 이행함&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;fclean&lt;/code&gt; 의 경우 &lt;code&gt;clean&lt;/code&gt; 을 의존성 파일로 가지고 있음&#xA;&lt;ul&gt;&#xA;&lt;li&gt;실행 시 &lt;code&gt;clean&lt;/code&gt; 이후 &lt;code&gt;rm -f $(NAME)&lt;/code&gt; 를 이행함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;re&lt;/code&gt; 의 경우 &lt;code&gt;fclean&lt;/code&gt; 이후  &lt;code&gt;all&lt;/code&gt; 을 이행함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Makefile&#34; data-lang=&#34;Makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.PHONY&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; all clean fclean re bonus&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;.PHONY&lt;/code&gt; 타겟은 makefile 내에서 가짜 타겟이나 특별한 타겟을 명시하기 위해 사용됨&#xA;&lt;ul&gt;&#xA;&lt;li&gt;해당 설정을 하지 않을 경우 대상 파일 내에 &lt;code&gt;clean&lt;/code&gt; 이 존재할 경우, &lt;code&gt;make clean&lt;/code&gt; 을 실행하면 단순히 해당 파일의 타임스탬프만 확인하고 아무 일도 없을 수 있음&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;relink&#34;&gt;Relink&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Relink란 소스파일이 수정되지 않은 상태에서 &lt;code&gt;make&lt;/code&gt; 명령어를 다시 실행했을 때 &lt;code&gt;.a&lt;/code&gt; 이 다시 만들어지는 것&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;../42cursus/libft.md&#34;&gt;Libft&lt;/a&gt; 에서 bonus 과제와 관련된 Relink 문제 발생&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Makefile&#34; data-lang=&#34;Makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bonus &lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;OBJS&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;OBJS_BONUS&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;ar -rsc $@ $^&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;Makefile은 타겟 파일을 만들면서 의존성파일의 타임 스탬프를 항상 확인함&lt;/li&gt;&#xA;&lt;li&gt;이때 bonus의 경우 타겟 파일이 아닌 명령어이기 때문에, make는 타임스탬프는 확인하지만 일단 주어진 명령(레시피)을 무조건 실행함&lt;/li&gt;&#xA;&lt;li&gt;타임스탬프를 비교할 파일이 없는 것과 다름없음&lt;/li&gt;&#xA;&lt;li&gt;이 과정에서 make bonus를 할 경우 relink가 계속 일어날 수 있음&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;test&#34;&gt;Test&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Makefile&#34; data-lang=&#34;Makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;OBJS&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;CC&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;CFLAGS&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt; $^ -o a.out&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&#xA;&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.gnu.org/software/make/manual/make.html#Archive-Suffix-Rules&#34;&gt;https://www.gnu.org/software/make/manual/make.html#Archive-Suffix-Rules&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/docs/ko/aix/7.2?topic=ar-command&#34;&gt;https://www.ibm.com/docs/ko/aix/7.2?topic=ar-command&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;div class=&#34;alert&#34;&gt;&#xA;    &lt;span&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/CS101&#34;&gt; CS101 &lt;/a&gt;&lt;/span&gt;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
