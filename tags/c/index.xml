<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on Elecbrandy</title>
    <link>https://elecbrandy.github.io/tags/c/</link>
    <description>Recent content in C on Elecbrandy</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 28 Feb 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://elecbrandy.github.io/tags/c/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[42cursus] pipex</title>
      <link>https://elecbrandy.github.io/posts/42cursus/pipex/</link>
      <pubDate>Wed, 28 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/pipex/</guid>
      <description>Cristina: &amp;ldquo;Go dance salsa somewhere :)&amp;rdquo;&#xA;01 소개 42서울 본과정 입과 후 다섯번째로 수행한 과제로, UNIX 동작 원리를 프로그래밍을 통해 상세히 파헤쳐보는 과제이다. Shell에서의 파이프를 구현하는 과제이며 Redriection, File discriptor, Process, Pipe, Fork 등을 공부할 수 있다.&#xA;02 PIPEX 명세서 Mandatory part pipex는 ./pipex file1 cmd1 cmd2 file2 형태로 실행된다. file1과 file2는 파일 이름이다. cmd1과 cmd2는 매개 변수가 존재하는 쉘 명령어이다. 프로그램은 &amp;lt; file1 cmd1 | cmd2 &amp;gt; file2 명령과 동일하게 작동해야 한다.</description>
    </item>
    <item>
      <title>[42cursus] push_swap</title>
      <link>https://elecbrandy.github.io/posts/42cursus/push_swap/</link>
      <pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/push_swap/</guid>
      <description>Because Swap_push isn’t as natural&#xA;01 소개 42서울 본과정 입과 후 네번째로 수행한 과제로, 스택에 있는 데이터를 한정된 명령어를 이용하여 최대한 적은 횟수 내에 정렬하는 것을 목표로 하는 과제이다. 상당히 아이러니한 과제이다. 스택이라고 명시되어있지만, 과제에서 요구하는 구조는 스택과는 거리가 멀고, 명령어도 한정되어있다. 또한 정렬 시 복잡도를 고려하는 것이 아니라 명령어 갯수만 어떻게든 줄여서 출력하면 ok를 받을 수 있다. 그렇다보니 가장 많이 쓰이는 방법이 그리디 알고리즘를 통해 모든 정렬 경우의 수를 먼저 체크하고, 명령어 수를 최적화하여 이후에 출력하는 것이다.</description>
    </item>
    <item>
      <title>[42cursus] born2beroot</title>
      <link>https://elecbrandy.github.io/posts/42cursus/born2beroot/</link>
      <pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/born2beroot/</guid>
      <description>YOU CAN DO ANYTHING YOU WANT TO DO, VIRTUAL MACHINE, THIS IS YOUR WORLD&#xA;01 소개 42서울 본과정 입과 후 네번째로 수행한 과제로, 가상머신에 리눅스를 설치하고 공부하는 과정이다. 가상머신에 리눅스(Debian or Rocky)를 설치하고, LVM를 통한 파티션 설정과 기타 여러가지 기능을 직접 실습한다. 백문불여일견. 요구사항이 상당히 많고 처음 접한다면 배워야할 개념도 상당히 많다&amp;hellip; 화이팅! 리눅스 설치는 하다보면 100번이라도 해야만 하는 상황이기 때문에 중요한 개념 위주로만 정리했다.&#xA;02 Born2beroot 개념정리 운영체제 Operating System은 응용 프로그램 또는 사용자에게 컴퓨터 자원을 사용할 수 있는 인터페이스를 제공하고, 그 결과를 돌려주는 시스템 소프트웨어이다.</description>
    </item>
    <item>
      <title>File descriptor</title>
      <link>https://elecbrandy.github.io/posts/cs101/filedescriptor/</link>
      <pubDate>Sun, 24 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/filedescriptor/</guid>
      <description>운영 체제에서 파일이나 입출력 자원을 식별하기 위해 사용하는&amp;hellip;&#xA;Libft 과제에 이어 get_next_line 과제를 진행하던 중 파일 디스크립터 개념을 만나게 되어 정리했다. 결국은 파일에게 접근하기 위한 번호이자 거창하게는 파일 포인터 개념으로 이해하고 넘어가자.&#xA;File Descripot 리눅스 시스템에서는 모든 것이 파일 객체, 행동, 디바이스, 네트워크 연결, 디렉터리, 프로세스 등등 이때 시스템이 이 파일들에게 접근 시 File Descriptor라는 개념을 이용함 File Descriptor는 Non-negative Integer 값을 가짐(0 ~ OPEN_MAX) Process에서 열린 파일의 목록을 관리하는 테이블의 인덱스!</description>
    </item>
    <item>
      <title>[42cursus] get_next_line</title>
      <link>https://elecbrandy.github.io/posts/42cursus/get_next_line/</link>
      <pubDate>Mon, 18 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/get_next_line/</guid>
      <description>Reading a line on a fd is way too tedious&#xA;01 소개 42서울 본과정 입과 후 세번째로 수행한 과제로, 파일 디스크립터로부터 읽혀진 - 개행으로 끝나는 한 줄을 반환하는 함수를 만드는 과제이다. 즉 파일 하나를 연 다음, 파일 내용에서 개행으로 끝나는 줄 하나를 반환해야한다. 파일을 열고, 지정된 BUFFER_SIZE 만큼 read함수를 통해 파일을 읽다가 개행문자 \n이 나타나면 개행문자 전까지만 반환한다.&#xA;02 GET_NEXT_LINE 명세서 PROTOTYPE char *get_next_line(int fd); PARAMETER int fd : 읽어들일 파일의 디스크립터 DESCRIPTION Mandatory part 호출마다 한 번에 한 줄씩 파일 디스크립터가 가리키는 파일을 읽어온다.</description>
    </item>
    <item>
      <title>[42cursus] ft_printf</title>
      <link>https://elecbrandy.github.io/posts/42cursus/ft_printf/</link>
      <pubDate>Wed, 15 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/ft_printf/</guid>
      <description>putnbr and putstr aren’t enough&#xA;01 소개 42서울 본과정 입과 후 두번째로 수행한 과제로, 말 그대로 C언어의 printf 함수를 재현하는 과제이다. bonus는 수행하지 않았고, 기본적인 내용만 구현하다보니 생각보다 난이도가 쉬웠던 것 같다. libc의 printf 함수를 재구현해야 하며, 실제 printf처럼 버퍼 관리를 수행해서는 안 된다. 서식 지정자 cspdiuxX%를 구현해야한다.&#xA;02 FT_PRINTF 명세서 PROTOTYPE int ft_printf(const char *str, ...); PARAMETER const char *str : format 이라는 이름의 문자열 상수 (서식 문자열) .</description>
    </item>
    <item>
      <title>[42cursus] libft</title>
      <link>https://elecbrandy.github.io/posts/42cursus/libft/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/libft/</guid>
      <description>Your very first own library&#xA;01 소개 42서울 본과정 입과 후 첫번째로 만나는 과제로 앞으로 본과정에서 사용할 라이브러리를 만드는 것이 목표이다. 이후 과제를 수행하며 자주 사용할 함수들이 몇가지 있기 때문에 최대한 범용성 높게 - 커스텀하기 쉽게 만드는 것을 목표로 했다. 항상 느끼는 것이지만 norm 규칙의 첫번째 목표는 카뎃이 다른 카뎃의 코드를 보았을 때 최소한의 일관성을 유지하여 쉽게 읽을 수 있게 하는 것&amp;hellip; 이고 두번째는 코드 길이를 적당히 조절함으로써 자연스럽게 모듈화를 하게 하는 것.</description>
    </item>
    <item>
      <title>C build</title>
      <link>https://elecbrandy.github.io/posts/cs101/buildc/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/buildc/</guid>
      <description>컴파일 언어(compiled language)는 코드가 실행되기 전 컴파일러를 거쳐서 기계어로 모두 변환되어 실행되는 프로그래밍 언어이다.&#xA;1. Preprocess 전처리기 cpp 에 의해 수행 header inclusion 헤더 파일에 정의된 변수와 함수를 포함하는 과정 macro expansion #define 같은 매크로 등을 소스코드로 변경 .c -&amp;gt; .i 2. Complie 컴파일러 ccl 에 의해 수행 c언어 코드를 어셈블리어로 변환 .i -&amp;gt; .s 3. Assemble 어셈블러 as 에 의해 수행 어셈블리어를 바이너리 형태로 변환 (목적 파일 생성) .</description>
    </item>
    <item>
      <title>Makefile</title>
      <link>https://elecbrandy.github.io/posts/cs101/makefile/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/makefile/</guid>
      <description>The script that automates software build processes with the make utility&#xA;Makefile 은 소프트웨어 개발 과정에서 빌드를 자동화하는 강력한 도구이다. 복잡한 빌드 단계를 단순하고 반복 가능하게 만들어 주는 것이 핵심 기능이다. 프로그래머들에게 시간을 절약하고 오류를 줄여주는 데 큰 도움을 준다. Makefile Makefile 이란 자동화, 의존성 관리, 효율성, 모듈성, 표준화를 목적으로 함 자동화 복잡한 빌드 명령어를 자동화하여 개발자가 빌드 프로세스를 쉽게 반복 의존성 관리 소스 파일과 헤더 파일 간의 의존성을 추적하여 변경 시에만 관련 파일을 재컴파일 효율성 전체 프로젝트를 빌드하는 대신 변경된 부분만 빌드하여 시간과 자원을 절약 모듈성 빌드 프로세스를 여러 단계로 분리하여 복잡성을 관리해 유지보수가 용이 표준화 일관된 빌드 절차로 다른 개발자가 쉽게 이해하고 사용할 수 있음 Makefile 의 기본적 구성 target : 하나의 실행 가능 파일 dependency : 하나의 대상과 그것이 의존하는 소스파일 rule : 의존 파일들로부터 대상 파일을 생성하는 방법을 정의 예시 CC = cc CFLAGS = -Wall -Wextra -Werror INS = .</description>
    </item>
  </channel>
</rss>
