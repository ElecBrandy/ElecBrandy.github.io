<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>os on home</title>
    <link>https://elecbrandy.github.io/tags/os/</link>
    <description>Recent content in os on home</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 07 Jan 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://elecbrandy.github.io/tags/os/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[CS] 명령어</title>
      <link>https://elecbrandy.github.io/posts/cs101/cs/cmd/</link>
      <pubDate>Tue, 07 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/cs/cmd/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /2025 CS STUDY&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/ai/2024winterLLm/llm_1/&#34;&gt;01. NLP의 과거와 오늘&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/ai/2024winterLLm/llm_2/&#34;&gt;02. GPT&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;컴퓨터는 명령어를 처리하는 기계이다. 즉, 명령어는 컴퓨터를 실질적으로 작동시키는 매우 중요한 정보이다. 우리가 C, C++, Java, Python과 같은 프로그래밍 언어로 만든 소스 코드는 컴퓨터 내부에서 명령어로 반환된다. 이 명령어의 정체가 무엇인지 한번 공부해보자!&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-고급-언어와-저급-언어&#34;&gt;2. 고급 언어와 저급 언어&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;컴퓨터는 C, C++, Java, Python과 같은 프로그래밍 언어를 이해할 수 없다. 이 언어들은 사람이 이해하고 작성하기 쉽게 만들어진 &lt;strong&gt;고급 언어&lt;/strong&gt; 이기 때문이다. 반대로 컴퓨터가 직접 이해하고 실행할 수 있는 언어를 &lt;strong&gt;저급 언어&lt;/strong&gt;라고 한다. 따라서 우리가 고급 언어를 사용해 열심히 프로그래밍한 결과물은 저급 언어로 변환 과정을 거쳐야 컴퓨터가 비로소 이해하고 실행할 수 있는 것이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[CS] 이진법</title>
      <link>https://elecbrandy.github.io/posts/cs101/cs/binary/</link>
      <pubDate>Tue, 07 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/cs/binary/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /2025 CS STUDY&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/ai/2024winterLLm/llm_1/&#34;&gt;01. NLP의 과거와 오늘&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/ai/2024winterLLm/llm_2/&#34;&gt;02. GPT&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;컴퓨터는 0과 1로 모든 정보를 표현하고 이해하는 이진법을 기준으로 작동한다. 이진법과 이진법 표현, 연산 등을 알아보자.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-이진법이란&#34;&gt;2. 이진법이란&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;이진법이란, 0과 1만 사용하여 숫자를 표현하는 체계를 의미한다. 컴퓨터 공학에서 0과 1을 비트(bit)라고 부르며, 이진수는 이러한 비트의 조합으로 표현된다. 우리가 저장하는 다양한 데이터들은 저장공간에 0과 1로 변환되어 저장되는 셈이다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;bit&lt;/code&gt;란 0과 1, 두가지 값만 가질 수 있는 측정 단위로 이진법으로 표현된 수에서 각각의 자릿수 하나를 비트라고 한다. 주로 데이터 처리, 저장, 전송 표현에 사용된다. &lt;code&gt;byte&lt;/code&gt;란 8개의 &lt;code&gt;bit&lt;/code&gt;가 모인 것으로 1 &lt;code&gt;byte&lt;/code&gt; 로 표현할 수 있는 경우의 수는 2^8 = &lt;strong&gt;256&lt;/strong&gt; 개이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LVM</title>
      <link>https://elecbrandy.github.io/posts/cs101/etc/lvm/</link>
      <pubDate>Wed, 20 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/etc/lvm/</guid>
      <description>&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;LVM&lt;/strong&gt;은 Linux Volume Manager의 약어로, Linux에서 복잡한 스토리지 구성을 효율적으로 관리하기 위한 시스템이다. 물리적 디스크를 하나의 논리적 볼륨으로 결합할 수 있고, 볼륨의 크기를 쉽게 조정 가능하다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-lvm의-구성&#34;&gt;2. LVM의 구성&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;PV&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Physical Volume&lt;/li&gt;&#xA;&lt;li&gt;LVM에서 블록장치에 접근하기 위해서 PV로 초기화가 필요&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;PE&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Physical Extent&lt;/li&gt;&#xA;&lt;li&gt;PV를 구성하는 일정한 크기의 블록으로 LVM2에서 기본 크기가 4MB&lt;/li&gt;&#xA;&lt;li&gt;LV의 LE와 1:1로 대응&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;VG&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Volume Group&lt;/li&gt;&#xA;&lt;li&gt;PV들의 집합으로 LV를 할당할 수 있는 공간&lt;/li&gt;&#xA;&lt;li&gt;PV로 초기화된 장치들은 VG로 통합됨&lt;/li&gt;&#xA;&lt;li&gt;사용자는 VG 안에서 유연성 높게 공간을 쪼개 LV 생성 가능&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LV&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Logical Volume&lt;/li&gt;&#xA;&lt;li&gt;사용자가 최종적으로 다루게 되는 논리적 스토리지&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LV의 유형&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Linear LV&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;선형으로 PV를 모아 LV로 만드는 방법&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Striped LV&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;대량의 순차적 읽기/쓰기 작업의 경우 효율적으로 높일 수 있음&lt;/li&gt;&#xA;&lt;li&gt;선형이 아니라 여러 PV에 번갈아가며 기록하는 방법&lt;/li&gt;&#xA;&lt;li&gt;결국 분산기록이며, 읽고 쓰기가 병렬로 실행 가능&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Mirrored LV&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;블록 장치에 저장된 데이터의 복사본을 다른 블록 장치에 저장하는 방식&lt;/li&gt;&#xA;&lt;li&gt;백업에 용이함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LE&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;LV를 구성하는 일정한 크기의 블록으로 PE와 마찬가지로 4MB&lt;/li&gt;&#xA;&lt;li&gt;각각의 LV들은 PE들과 1:1로 맵핑됨&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;3-기존방식-vs-lvm&#34;&gt;3. 기존방식 vs LVM&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;3-1-기존-방식&#34;&gt;3-1. 기존 방식&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;File system이 물리적 블록장치와 직접 상호작용&lt;/li&gt;&#xA;&lt;li&gt;마운트된 파티션의 용량이 가득 차 이동 시&#xA;&lt;ul&gt;&#xA;&lt;li&gt;추가 디스크 장착&lt;/li&gt;&#xA;&lt;li&gt;추가된 디스크에 파티션 생성 및 포맷&lt;/li&gt;&#xA;&lt;li&gt;새로운 마운트 포인트(b)를 만들고 추가한 파티션 마운트&lt;/li&gt;&#xA;&lt;li&gt;기존 데이터를 (b)에 이동&lt;/li&gt;&#xA;&lt;li&gt;기존 파티션 언마운트 후 새 포인트와 연결&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;3-2-lvm-방식&#34;&gt;3-2. LVM 방식&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;File system이 LVM이 만든 가상의 블록 장치에 상호작용함&lt;/li&gt;&#xA;&lt;li&gt;실제 블록 장치를 추상화하여 더 유연한 접근이 가능함&lt;/li&gt;&#xA;&lt;li&gt;마운트된 파티션의 용량이 가득 차 이동 시&#xA;&lt;ul&gt;&#xA;&lt;li&gt;추가 디스크 장착&lt;/li&gt;&#xA;&lt;li&gt;추가 디스크에 Partition을 만들고 pv 초기화&lt;/li&gt;&#xA;&lt;li&gt;pv를 vg에 추가하고 해당 논리 볼륨 사이즈 증가&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;4-reference&#34;&gt;4. Reference&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://tech.cloud.nongshim.co.kr/2018/11/23/lvmlogical-volume-manager-1-%EA%B0%9C%EB%85%90/&#34;&gt;https://tech.cloud.nongshim.co.kr/2018/11/23/lvmlogical-volume-manager-1-%EA%B0%9C%EB%85%90/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://nayoungs.tistory.com/entry/Linux-LVMLogical-Volume-Manage-PV-VG-LV&#34;&gt;https://nayoungs.tistory.com/entry/Linux-LVMLogical-Volume-Manage-PV-VG-LV&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
