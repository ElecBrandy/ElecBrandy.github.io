<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CS101 on Elecbrandy</title>
    <link>https://elecbrandy.github.io/tags/cs101/</link>
    <description>Recent content in CS101 on Elecbrandy</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 24 Dec 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://elecbrandy.github.io/tags/cs101/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>File descriptor</title>
      <link>https://elecbrandy.github.io/posts/cs101/filedescriptor/</link>
      <pubDate>Sun, 24 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/filedescriptor/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;운영 체제에서 파일이나 입출력 자원을 식별하기 위해 사용하는&amp;hellip;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;p&gt;&lt;code&gt;Libft&lt;/code&gt; 과제에 이어 &lt;code&gt;get_next_line&lt;/code&gt; 과제를 진행하던 중 파일 디스크립터 개념을 만나게 되어 정리했다. 결국은 파일에게 접근하기 위한 번호이자 거창하게는 파일 포인터 개념으로 이해하고 넘어가자.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;file-descripot&#34;&gt;File Descripot&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;리눅스 시스템에서는 모든 것이 파일&#xA;&lt;ul&gt;&#xA;&lt;li&gt;객체, 행동, 디바이스, 네트워크 연결, 디렉터리, 프로세스 등등&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;이때 시스템이 이 파일들에게 접근 시 File Descriptor라는 개념을 이용함&lt;/li&gt;&#xA;&lt;li&gt;File Descriptor는 Non-negative Integer 값을 가짐(0 ~ OPEN_MAX)&lt;/li&gt;&#xA;&lt;li&gt;Process에서 열린 파일의 목록을 관리하는 테이블의 인덱스! (0, 1, 2는 기본 할당)&lt;/li&gt;&#xA;&lt;li&gt;FD 테이블의 각 항목은 FD 플래그와 파일 테이블로의 포인터와 같음&lt;/li&gt;&#xA;&lt;li&gt;이 포인터를 이용하여 FD 를 통해 시스템의 파일을 참조!&lt;/li&gt;&#xA;&lt;li&gt;Process는 이런 FD 테이블과 파일 테이블의 정보를 직접 고칠 수 없으며, 반드시 커널을 통해서 수정을 해야함&lt;/li&gt;&#xA;&lt;li&gt;프로그램에서 FD 참조시 index를 사용할 수도 있고, POSIX 명을 사용할 수도 있음&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;fd와-열려-있는-파일의-관계&#34;&gt;FD와 열려 있는 파일의 관계&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;각 프로세스별로 커널은 &lt;code&gt;open file descriptor table&lt;/code&gt; 을 가짐&lt;/li&gt;&#xA;&lt;li&gt;테이블의 각 엔트리는 하나의 FD에 대한 동작 제어 플래그, 열린 파일을 가리키는 참조를 담고 있음&lt;/li&gt;&#xA;&lt;li&gt;특히 &lt;code&gt;open file descriptor table&lt;/code&gt; 현재 파일의 Offset, flag, 접근 모드 ,i/o 관련 설정, 파일의 i-node 객체를 가리키는 정보를 담고 있음&lt;/li&gt;&#xA;&lt;li&gt;같은 &lt;code&gt;open file descripton&lt;/code&gt; 을 가르키는 2개의 FD가 Offset 값을 공유함&#xA;&lt;ul&gt;&#xA;&lt;li&gt;간단한 예시&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;file.txt&lt;/code&gt; 열고 두 개의 파일 디스크립터를 얻는다.&lt;/li&gt;&#xA;&lt;li&gt;FD1을 이용해서 파일 처음으로 이동한다. (offset 0)&lt;/li&gt;&#xA;&lt;li&gt;FD2을 이용해서 파일 어딘가로 이동한다. (offset 100)&lt;/li&gt;&#xA;&lt;li&gt;FD1과 FD2는 동일한 파일 &lt;code&gt;file.txt&lt;/code&gt;를 가리키지만 FD1은 파일의 처음 / FD2는 파일의 어딘가를  가리킨다.&lt;/li&gt;&#xA;&lt;li&gt;이렇게 동시에 한 파일을 여러 위치에서 읽고 쓸 수 있다.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;정리&#34;&gt;정리&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;file.txt&lt;/code&gt; 를 열면 OS는 &lt;code&gt;open file descriptor table&lt;/code&gt;에 해당 항목을 추가한다.&lt;/li&gt;&#xA;&lt;li&gt;이때 인덱스는 &lt;code&gt;file.txt&lt;/code&gt; 를 가르킨다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;file.txt&lt;/code&gt; 를 닫으면 테이블에서 해당 인덱스가 사라진다.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=EqndHT606Tw&#34;&gt;https://www.youtube.com/watch?v=EqndHT606Tw&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=btT4HDKNIOw&#34;&gt;https://www.youtube.com/watch?v=btT4HDKNIOw&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dev-ahn.tistory.com/96&#34;&gt;https://dev-ahn.tistory.com/96&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;div class=&#34;alert&#34;&gt;&#xA;    &lt;span&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/CS101&#34;&gt; CS101 &lt;/a&gt;&lt;/span&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;</description>
    </item>
    <item>
      <title>C build</title>
      <link>https://elecbrandy.github.io/posts/cs101/buildc/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/buildc/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;컴파일 언어(compiled language)는 코드가 실행되기 전 컴파일러를 거쳐서 기계어로 모두 변환되어 실행되는 프로그래밍 언어이다.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-preprocess&#34;&gt;1. Preprocess&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;전처리기 &lt;strong&gt;cpp&lt;/strong&gt; 에 의해 수행&lt;/li&gt;&#xA;&lt;li&gt;header inclusion&#xA;&lt;ul&gt;&#xA;&lt;li&gt;헤더 파일에 정의된 변수와 함수를 포함하는 과정&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;macro expansion&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;#define&lt;/code&gt; 같은 매크로 등을 소스코드로 변경&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;.c&lt;/code&gt;&lt;/strong&gt; -&amp;gt; &lt;strong&gt;&lt;code&gt;.i&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-complie&#34;&gt;2. Complie&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;컴파일러 &lt;strong&gt;ccl&lt;/strong&gt; 에 의해 수행&lt;/li&gt;&#xA;&lt;li&gt;c언어 코드를 어셈블리어로 변환&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;.i&lt;/code&gt;&lt;/strong&gt; -&amp;gt; &lt;strong&gt;&lt;code&gt;.s&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;3-assemble&#34;&gt;3. Assemble&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;어셈블러 &lt;strong&gt;as&lt;/strong&gt; 에 의해 수행&lt;/li&gt;&#xA;&lt;li&gt;어셈블리어를 바이너리 형태로 변환 (목적 파일 생성)&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;.s&lt;/code&gt;&lt;/strong&gt; -&amp;gt; &lt;strong&gt;&lt;code&gt;.o&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;4-link&#34;&gt;4. Link&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;여러 목적파일과 라이브러리들을 모아 실행 가능한 단일 파일로 결합&lt;/li&gt;&#xA;&lt;li&gt;정적 라이브러리도 함께 결합됨&#xA;&lt;ul&gt;&#xA;&lt;li&gt;라이브러리는 이미 컴파일 되어있으므로 링크만 하면 바로 사용 가능&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;빌드 과정의 마지막 단계로서, 실행 파일이 생성되면 프로그램이 &lt;strong&gt;빌드&lt;/strong&gt;되었다고 함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;5-runtime&#34;&gt;5. &lt;strong&gt;Runtime&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;목적 파일 처럼 중간 과정을 거치는 이유?&#xA;&lt;ul&gt;&#xA;&lt;li&gt;소스를 각기 다른 언어로 작성했을 수도 있음&lt;/li&gt;&#xA;&lt;li&gt;한 파일에 모든 함수나 기능을 넣는 것이 비효율적이고 불가능에 가까움&lt;/li&gt;&#xA;&lt;li&gt;결국 쪼개진 각기 다른 여러 파일을 잘 합치기 위함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;div class=&#34;alert&#34;&gt;&#xA;    &lt;span&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/CS101&#34;&gt; CS101 &lt;/a&gt;&lt;/span&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;</description>
    </item>
    <item>
      <title>Makefile</title>
      <link>https://elecbrandy.github.io/posts/cs101/makefile/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/makefile/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;The script that automates software build processes with the make utility&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;p&gt;&lt;code&gt;Makefile&lt;/code&gt; 은 소프트웨어 개발 과정에서 빌드를 자동화하는 강력한 도구이다. 복잡한 빌드 단계를 단순하고 반복 가능하게 만들어 주는 것이 핵심 기능이다. 프로그래머들에게 시간을 절약하고 오류를 줄여주는 데 큰 도움을 준다.&#xA;&lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;makefile&#34;&gt;Makefile&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Makefile&lt;/code&gt; 이란 자동화, 의존성 관리, 효율성, 모듈성, 표준화를 목적으로 함&#xA;&lt;ul&gt;&#xA;&lt;li&gt;자동화&#xA;&lt;ul&gt;&#xA;&lt;li&gt;복잡한 빌드 명령어를 자동화하여 개발자가 빌드 프로세스를 쉽게 반복&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;의존성 관리&#xA;&lt;ul&gt;&#xA;&lt;li&gt;소스 파일과 헤더 파일 간의 의존성을 추적하여 변경 시에만 관련 파일을 재컴파일&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;효율성&#xA;&lt;ul&gt;&#xA;&lt;li&gt;전체 프로젝트를 빌드하는 대신 변경된 부분만 빌드하여 시간과 자원을 절약&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;모듈성&#xA;&lt;ul&gt;&#xA;&lt;li&gt;빌드 프로세스를 여러 단계로 분리하여 복잡성을 관리해 유지보수가 용이&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;표준화&#xA;&lt;ul&gt;&#xA;&lt;li&gt;일관된 빌드 절차로 다른 개발자가 쉽게 이해하고 사용할 수 있음&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Makefile&lt;/code&gt; 의 기본적 구성&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;target&lt;/code&gt; : 하나의 실행 가능 파일&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;dependency&lt;/code&gt; : 하나의 대상과 그것이 의존하는 소스파일&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;rule&lt;/code&gt; : 의존 파일들로부터 대상 파일을 생성하는 방법을 정의&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;예시&#34;&gt;예시&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Makefile&#34; data-lang=&#34;Makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CC &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cc&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CFLAGS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; -Wall -Wextra -Werror&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;INS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; .&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; libft.a&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
  </channel>
</rss>
