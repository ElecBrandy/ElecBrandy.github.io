<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dataStructure on home</title>
    <link>https://elecbrandy.github.io/tags/datastructure/</link>
    <description>Recent content in dataStructure on home</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 Sep 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://elecbrandy.github.io/tags/datastructure/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[자료구조] Queue</title>
      <link>https://elecbrandy.github.io/posts/cs101/datastructure/queue/</link>
      <pubDate>Thu, 19 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/datastructure/queue/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /dataStructure&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;Queue&lt;/strong&gt;(큐)는 선형 자료구조로, 데이터가 삽입된 순서대로 처리되는 &lt;strong&gt;FIFO(First In First Out)&lt;/strong&gt; 방식이다. 즉, 먼저 들어온 데이터가 먼저 나가는 구조이다. 큐는 컴퓨터 시스템에서 작업 예약, 데이터 버퍼링 등 다양한 분야에서 활용된다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-큐의-개념과-종류&#34;&gt;2. 큐의 개념과 종류&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;큐는 한쪽 끝에서는 삽입이, 반대쪽 끝에서는 삭제가 이루어지는 구조이다. 기본적인 큐 외에도 다양한 변형이 존재한다.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;원형 큐(Circular Queue)&lt;/strong&gt;: 마지막 위치가 첫 위치와 연결되어 원형으로 구성된 큐이다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;우선순위 큐(Priority Queue)&lt;/strong&gt;: 각 요소에 우선순위가 부여되어, 높은 우선순위의 요소가 먼저 처리되는 큐이다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;덱(Deque)&lt;/strong&gt;: 양쪽 끝에서 삽입과 삭제가 모두 가능한 큐이다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;3-큐의-구현&#34;&gt;3. 큐의 구현&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;큐는 배열이나 연결 리스트를 이용하여 구현할 수 있다. 여기서는 &lt;code&gt;C&lt;/code&gt; 언어를 사용하여 배열 기반의 큐를 구현해보고, &lt;code&gt;C++&lt;/code&gt;의 STL에서 제공하는 &lt;code&gt;queue&lt;/code&gt;의 사용법을 알아보겠다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[자료구조] Stack</title>
      <link>https://elecbrandy.github.io/posts/cs101/datastructure/stack/</link>
      <pubDate>Wed, 11 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/datastructure/stack/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /dataStructure&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;https://media.geeksforgeeks.org/wp-content/uploads/20240606180735/Stack-representation-in-Data-Structures-(1).webp&#34; width=&#34;700&#34;&gt;&#xA;&lt;p&gt;Stack은 &lt;strong&gt;LIFO(Last in, First Out)&lt;/strong&gt; 방식으로 작동하는 선형 자료구조이다. 즉, 가장 마지막에 삽입된 데이터가 가장 먼저 삭제되는 구조인 것! Stack의 입/출력은 오로지 Stack의 꼭대기에서만 이루어진다. 갑자기 중간에 있는 데이터를 삭제하거나 끼워넣을 수 없으며, 맨 아래 데이터에 접근하기 위해서는 그 위에 있는 데이터를 모두 걷어내야한다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-stack의-구현&#34;&gt;2. StacK의 구현&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;여러 환경에서 이미 Stack은 구현되어있는 자료구조이지만, 공부를 위해서 직접 구현해보자. 일단은 &lt;code&gt;C&lt;/code&gt;를 이용해 Array로 구현해보고, &lt;code&gt;C++&lt;/code&gt;의 STL에 속한 Stack 자료구조 사용법을 익혀보자. Linked List를 통해서도 Stack을 구현할 수 있으며, 전체용량을 관리하기 쉽다는 이점이 있다. &lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/list&#34;&gt; Linked List &lt;/a&gt; 의 여러 규칙에 규칙을 더해주기만 하면 만들 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[자료구조] List</title>
      <link>https://elecbrandy.github.io/posts/cs101/datastructure/list/</link>
      <pubDate>Tue, 10 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/datastructure/list/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /dataStructure&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-소개&#34;&gt;1. 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;List는 순서가 있는 데이터의 집합을 나타내는 가장 기초적인 자료구조 중 하나로, 배열(array)과의 근본적인 차이는 동적 크기 변화와 복잡한 데이터 구조를 지원하는 것이다. List는 CS에서 다양한 형태로 존재하며, 대표적으로 배열 리스트(Array List)와 연결 리스트(Linked List)가 존재한다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-array-list&#34;&gt;2. Array List&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vec;  &lt;span style=&#34;color:#75715e&#34;&gt;// 동적 크기를 갖는 배열 리스트&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;vec.push_back(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);      &lt;span style=&#34;color:#75715e&#34;&gt;// 새로운 요소 추가&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Array List&lt;/strong&gt;는 연속적인 메모리 공간에 데이터를 저장하는 방식이다. 이는 인덱스를 통한 빠른 접근 속도(시간 복잡도 &lt;code&gt;O(1)&lt;/code&gt;)가 특징이지만, 크기를 미리 지정해야 하는 제약이 있다. 만약 리스트가 가득 차면 새로운 더 큰 메모리 공간을 할당하고, 기존 요소를 복사하는 과정을 거쳐야하며 이 복사 작업의 평균 시간 복잡도는 &lt;code&gt;O(n)&lt;/code&gt;이다. 대표적인 예시로 &lt;code&gt;vector&lt;/code&gt;를 들 수 있다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
