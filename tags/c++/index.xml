<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Elecbrandy</title>
    <link>https://elecbrandy.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Elecbrandy</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 08 Sep 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://elecbrandy.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[42cursus] CPP MODULE 00</title>
      <link>https://elecbrandy.github.io/posts/42cursus/circle_4/cpp00/</link>
      <pubDate>Sun, 08 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/circle_4/cpp00/</guid>
      <description>&lt;p&gt;&lt;strong&gt;📂 : CPP MODULE&lt;/strong&gt; &lt;strong&gt;in circle_4&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/cppmodule/cpp00&#34;&gt; &lt;strong&gt;[00]&lt;/strong&gt; List &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/cppmodule/cpp01&#34;&gt; &lt;strong&gt;[01]&lt;/strong&gt; Stack &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/cppmodule/cpp02&#34;&gt; &lt;strong&gt;[02]&lt;/strong&gt; Queue &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/cppmodule/cpp03&#34;&gt; &lt;strong&gt;[03]&lt;/strong&gt; Heap &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/cppmodule/cpp04&#34;&gt; &lt;strong&gt;[04]&lt;/strong&gt; Tree &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;소개&#34;&gt;소개&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 n번째로 수행한 과제로, &lt;code&gt;C++&lt;/code&gt;을 통해 객체지향 프로그래밍을 공부하는 내용이다. 이 과제를 기점으로 &lt;code&gt;C&lt;/code&gt;&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;get_next_line-명세서&#34;&gt;get_next_line 명세서&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;PROTOTYPE&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;char *get_next_line(int fd);&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;PARAMETER&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;int fd&lt;/code&gt; : 읽어들일 파일의 디스크립터&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;DESCRIPTION&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Mandatory part&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;호출마다 한 번에 한 줄씩 파일 디스크립터가 가리키는 파일을 읽어온다.&lt;/li&gt;&#xA;&lt;li&gt;더 이상 읽어올 것이 없거나 에러가 발생하면 &lt;code&gt;NULL&lt;/code&gt;을 반환한다.&lt;/li&gt;&#xA;&lt;li&gt;파일 끝에 도달하였고, 개행문자 &lt;code&gt;\n&lt;/code&gt;이 존재하지 않을 때를 제외하고 반환하는 문자열에는 &lt;code&gt;\n&lt;/code&gt;이 포함되어야 한다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Bonus part&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;정적 변수를 하나만 사용하여 개발해야한다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;get_next_line()&lt;/code&gt; 이 여러 개의 파일 디스크립터를 한번에 관리해야 한다.&lt;/li&gt;&#xA;&lt;li&gt;한번 호출하여 3, 4, 5 그 이후 다시 4, 5 등등을 읽을 수 있어야 한다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;External functs&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;read, malloc, free&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RETURN VALUES&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;한 줄을 제대로 읽은 정상작동의 경우 읽은 라인을 반환한다.&lt;/li&gt;&#xA;&lt;li&gt;비정상작동의 경우 &lt;code&gt;NULL&lt;/code&gt;을 반환한다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;개념-정리&#34;&gt;개념 정리&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;연결리스트와-open_max&#34;&gt;연결리스트와 OPEN_MAX&lt;/h2&gt;&#xA;&lt;p&gt;본 과제를 &lt;strong&gt;BONUS&lt;/strong&gt;까지 수행한다면, 즉 동시에 여러 파일 디스크립터를 감안하는 프로그램을 만들고 싶다면 크게 두가지 방법이 존재한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[자료구조] Queue</title>
      <link>https://elecbrandy.github.io/posts/cs101/datastructure/__queue/</link>
      <pubDate>Thu, 05 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/datastructure/__queue/</guid>
      <description>&lt;p&gt;&lt;strong&gt;📂 : 자료구조&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/list&#34;&gt; &lt;strong&gt;[0]&lt;/strong&gt; List &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/stack&#34;&gt; &lt;strong&gt;[1]&lt;/strong&gt; Stack &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/queue&#34;&gt; &lt;strong&gt;[2]&lt;/strong&gt; Queue &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/heap&#34;&gt; &lt;strong&gt;[3]&lt;/strong&gt; Heap &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/tree&#34;&gt; &lt;strong&gt;[4]&lt;/strong&gt; Tree &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/graph&#34;&gt; &lt;strong&gt;[5]&lt;/strong&gt; Graph &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/hashtable&#34;&gt; &lt;strong&gt;[6]&lt;/strong&gt; HashTable &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;list&#34;&gt;List&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;List는 순서가 있는 데이터의 집합을 나타내는 가장 기초적인 자료구조 중 하나로, 배열(array)과의 근본적인 차이는 동적 크기 변화와 복잡한 데이터 구조를 지원하는 것이다. List는 CS에서 다양한 형태로 존재하며, 대표적으로 배열 리스트(Array List)와 연결 리스트(Linked List)가 존재한다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;array-list&#34;&gt;Array List&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vec;  &lt;span style=&#34;color:#75715e&#34;&gt;// 동적 크기를 갖는 배열 리스트&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;vec.push_back(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);      &lt;span style=&#34;color:#75715e&#34;&gt;// 새로운 요소 추가&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Array List는 연속적인 메모리 공간에 데이터를 저장하는 방식이다. 이는 인덱스를 통한 빠른 접근 속도(시간 복잡도 O(1))가 특징이지만, 크기를 미리 지정해야 하는 제약이 있다. 만약 리스트가 가득 차면 새로운 더 큰 메모리 공간을 할당하고, 기존 요소를 복사하는 과정을 거쳐야하며 이 복사 작업의 평균 시간 복잡도는 O(n)이다. 대표적인 예시로 &lt;code&gt;vector&lt;/code&gt;를 들 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[자료구조] Stack</title>
      <link>https://elecbrandy.github.io/posts/cs101/datastructure/__stack/</link>
      <pubDate>Sun, 01 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/datastructure/__stack/</guid>
      <description>&lt;p&gt;draft = true&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;📂 : 자료구조&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/list&#34;&gt; &lt;strong&gt;[0]&lt;/strong&gt; List &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/stack&#34;&gt; &lt;strong&gt;[1]&lt;/strong&gt; Stack &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/queue&#34;&gt; &lt;strong&gt;[2]&lt;/strong&gt; Queue &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/heap&#34;&gt; &lt;strong&gt;[3]&lt;/strong&gt; Heap &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/tree&#34;&gt; &lt;strong&gt;[4]&lt;/strong&gt; Tree &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/graph&#34;&gt; &lt;strong&gt;[5]&lt;/strong&gt; Graph &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/hashtable&#34;&gt; &lt;strong&gt;[6]&lt;/strong&gt; HashTable &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;stack&#34;&gt;Stack&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;https://media.geeksforgeeks.org/wp-content/uploads/20240606180735/Stack-representation-in-Data-Structures-(1).webp&#34; width=&#34;700&#34;&gt;&#xA;&lt;p&gt;Stack은 &lt;strong&gt;LIFO(Last in, First Out)&lt;/strong&gt; 방식으로 작동하는 선형 자료구조이다. 즉, 가장 마지막에 삽입된 데이터가 가장 먼저 삭제되는 구조인 것! Stack의 입/출력은 오로지 Stack의 꼭대기에서만 이루어진다. 갑자기 중간에 있는 데이터를 삭제하거나 끼워넣을 수 없으며, 맨 아래 데이터에 접근하기 위해서는 그 위에 있는 데이터를 모두 걷어내야한다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
