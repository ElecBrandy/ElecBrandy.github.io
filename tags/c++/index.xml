<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on home</title>
    <link>https://elecbrandy.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on home</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 05 Sep 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://elecbrandy.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[자료구조] Queue</title>
      <link>https://elecbrandy.github.io/posts/cs101/datastructure/__queue/</link>
      <pubDate>Thu, 05 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/datastructure/__queue/</guid>
      <description>&lt;p&gt;&lt;strong&gt;📂 : 자료구조&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/list&#34;&gt; &lt;strong&gt;[0]&lt;/strong&gt; List &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/stack&#34;&gt; &lt;strong&gt;[1]&lt;/strong&gt; Stack &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/queue&#34;&gt; &lt;strong&gt;[2]&lt;/strong&gt; Queue &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/heap&#34;&gt; &lt;strong&gt;[3]&lt;/strong&gt; Heap &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/tree&#34;&gt; &lt;strong&gt;[4]&lt;/strong&gt; Tree &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/graph&#34;&gt; &lt;strong&gt;[5]&lt;/strong&gt; Graph &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/dataStructure/hashtable&#34;&gt; &lt;strong&gt;[6]&lt;/strong&gt; HashTable &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;list&#34;&gt;List&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;List는 순서가 있는 데이터의 집합을 나타내는 가장 기초적인 자료구조 중 하나로, 배열(array)과의 근본적인 차이는 동적 크기 변화와 복잡한 데이터 구조를 지원하는 것이다. List는 CS에서 다양한 형태로 존재하며, 대표적으로 배열 리스트(Array List)와 연결 리스트(Linked List)가 존재한다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;array-list&#34;&gt;Array List&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vec;  &lt;span style=&#34;color:#75715e&#34;&gt;// 동적 크기를 갖는 배열 리스트&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;vec.push_back(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);      &lt;span style=&#34;color:#75715e&#34;&gt;// 새로운 요소 추가&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Array List는 연속적인 메모리 공간에 데이터를 저장하는 방식이다. 이는 인덱스를 통한 빠른 접근 속도(시간 복잡도 O(1))가 특징이지만, 크기를 미리 지정해야 하는 제약이 있다. 만약 리스트가 가득 차면 새로운 더 큰 메모리 공간을 할당하고, 기존 요소를 복사하는 과정을 거쳐야하며 이 복사 작업의 평균 시간 복잡도는 O(n)이다. 대표적인 예시로 &lt;code&gt;vector&lt;/code&gt;를 들 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[OOP] 캡슐화</title>
      <link>https://elecbrandy.github.io/posts/cs101/oop/capsule/</link>
      <pubDate>Mon, 02 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/oop/capsule/</guid>
      <description>&lt;details&gt;&#xA;&lt;summary&gt;&lt;strong&gt;📂 : OPP 모아보기&lt;/strong&gt;&lt;/summary&gt;&#xA;&lt;div markdown=&#34;1&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/opp/capsule&#34;&gt; &lt;strong&gt;[0]&lt;/strong&gt; : 캡슐화 &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/opp/&#34;&gt; &lt;strong&gt;[1]&lt;/strong&gt; : Stack &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/opp/&#34;&gt; &lt;strong&gt;[2]&lt;/strong&gt; : Queue &lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;/details&gt;&#xA;&lt;br&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;??? : Class는 붕어빵 틀, instance는 붕어빵&amp;hellip;?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;객체지향-이전의-세계&#34;&gt;객체지향 이전의 세계&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;객체지향이란 무엇일까? 인터넷에 검색해보면 &amp;ldquo;객체를 지향하는 프로그래밍&amp;quot;이라는 복잡한 설명과 함께, &amp;ldquo;클래스는 붕어빵 틀이고 인스턴스는 그 틀로 찍어낸 붕어빵이다&amp;hellip;&amp;rdquo; 같은 비유를 흔히 보게 된다. 그런데 이런 설명만으로는 객체지향의 본질을 파악하기 어렵다. 그렇다면 객체지향을 공부하기 전에, 이 개념이 왜 등장하게 되었는지 먼저 살펴보자.&lt;/p&gt;&#xA;&lt;p&gt;42과정을 진행하면서 처음으로 접하게 되는 언어는 C이다. C는 대표적인 절차지향 언어로, 프로그램을 일련의 명령과 함수로 구성해 나가는 방식이다. 처음엔 간단한 프로그램을 짜는 데 어려움이 없었고, 몇몇 과제는 금방 끝났다. 하지만 과제가 점점 복잡해지고, 코드의 규모가 커질수록 문제들이 발생하기 시작했다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
