<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithm on home</title>
    <link>https://elecbrandy.github.io/tags/algorithm/</link>
    <description>Recent content in algorithm on home</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 21 Sep 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://elecbrandy.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[알고리즘] 선택 정렬</title>
      <link>https://elecbrandy.github.io/posts/cs101/algorithm/insertion_sort/</link>
      <pubDate>Sat, 21 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/algorithm/insertion_sort/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /algorithm&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;구현&lt;/strong&gt; : 해당 알고리즘은 어떻게 구현 되었나?&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;정확성&lt;/strong&gt; : 해당 알고리즘이 실제로 동작하는가?&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;효율성&lt;/strong&gt; : 해당 알고리즘이 빠른가?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-insertion-sort&#34;&gt;1. Insertion sort&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;https://i.imgur.com/sW8twRl.png&#34; width=&#34;700&#34;&gt;&#xA;&lt;p&gt;&lt;code&gt;Insertion sort&lt;/code&gt;(삽입 정렬)는 말 그대로 정렬된 배열에 새로운 요소를 삽입하여 정렬을 확장해 나가는 알고리즘이다. 배열을 처리할 때, 전체 배열 중 왼쪽 부분은 이미 정렬된 상태이고, 오른쪽 부분은 아직 정렬되지 않은 상태로 남아 있다. 삽입 정렬은 이 정렬되지 않은 부분에서 하나씩 요소를 가져와서, 정렬된 배열의 어느 위치에 삽입해야 할지 결정하는 방식으로 동작한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[알고리즘] Big O</title>
      <link>https://elecbrandy.github.io/posts/cs101/algorithm/bigo/</link>
      <pubDate>Fri, 20 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/algorithm/bigo/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /algorithm&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-big-o-소개&#34;&gt;1. Big O 소개&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;Big O 표기법의 형태&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;O(1): 상수 시간, 입력 크기에 상관없이 항상 같은 시간이 걸린다.&lt;/li&gt;&#xA;&lt;li&gt;O(n): 입력 크기에 비례해서 시간이 걸린다.&lt;/li&gt;&#xA;&lt;li&gt;O(log n): 입력 크기가 증가할 때 실행 시간이 천천히 증가한다. 예를 들어, 이진 탐색 알고리즘이 이에 해당된다.&lt;/li&gt;&#xA;&lt;li&gt;O(n^2): 이중 반복문처럼, 입력 크기가 증가하면 실행 시간이 제곱으로 증가한다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;빅오표기법(Big-O)은 알고리즘이 실행되는 시간이나 메모리 사용량이 입력 크기(데이터의 양)에 따라 어떻게 변하는지 표현하는 방법이다. 주로 시간 복잡도와 공간 복잡도를 측정하는데 사용된다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
