<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithm on home</title>
    <link>https://elecbrandy.github.io/tags/algorithm/</link>
    <description>Recent content in algorithm on home</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 21 Sep 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://elecbrandy.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[알고리즘] 선택 정렬</title>
      <link>https://elecbrandy.github.io/posts/cs101/algorithm/insertion_sort/</link>
      <pubDate>Sat, 21 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/algorithm/insertion_sort/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /algorithm&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;구현&lt;/strong&gt; : 해당 알고리즘은 어떻게 구현 되었나?&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;정확성&lt;/strong&gt; : 해당 알고리즘이 실제로 동작하는가?&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;효율성&lt;/strong&gt; : 해당 알고리즘이 빠른가?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-insertion-sort&#34;&gt;1. Insertion sort&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;https://i.imgur.com/sW8twRl.png&#34; width=&#34;700&#34;&gt;&#xA;&lt;p&gt;&lt;code&gt;Insertion sort&lt;/code&gt;(삽입 정렬)는 말 그대로 정렬된 배열에 새로운 요소를 삽입하여 정렬을 확장해 나가는 알고리즘이다. 배열을 처리할 때, 전체 배열 중 왼쪽 부분은 이미 정렬된 상태이고, 오른쪽 부분은 아직 정렬되지 않은 상태로 남아 있다. 삽입 정렬은 이 정렬되지 않은 부분에서 하나씩 요소를 가져와서, 정렬된 배열의 어느 위치에 삽입해야 할지 결정하는 방식으로 동작한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[알고리즘] 알고리즘 분석</title>
      <link>https://elecbrandy.github.io/posts/cs101/algorithm/bigo/</link>
      <pubDate>Fri, 20 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/algorithm/bigo/</guid>
      <description>&lt;div class=&#34;series&#34;&gt;&#xA;  &lt;details&gt;&#xA;    &lt;summary&gt;📚 /algorithm&lt;/summary&gt;&#xA;    &lt;ul&gt;&#xA;      &#xA;      &#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/list/&#34;&gt;list&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/stack/&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/queue/&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/heap/&#34;&gt;heap&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/tree/&#34;&gt;tree&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/graph/&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;      &lt;li&gt;-&lt;a href=&#34;https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/&#34;&gt;hashTable&lt;/a&gt;&lt;/li&gt;&#xA;      &#xA;    &lt;/ul&gt;&#xA;  &lt;/details&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-알고리즘-분석&#34;&gt;1. 알고리즘 분석&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;어떤 알고리즘이 있을 때, 어떻게 분석하는게 좋을까? 우리는 &lt;strong&gt;구현 / 정확성 / 효율성&lt;/strong&gt;세 가지 핵심 요소를 통해 대상 알고리즘을 효과적으로 분석할 수 있다.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;구현&lt;/strong&gt;은 알고리즘이 어떻게 구조화되고 작성되었는지를 의미하며, 코드 레벨에서의 설계와 구현 방식에 대한 부분이다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;정확성&lt;/strong&gt;은 알고리즘이 기대한 대로 정확하게 동작하는지 평가하는 요소로, 원하는 결과를 항상 도출해낼 수 있는지 증명하는 것이다. 알고리즘의 정확한 작동을 담보하기 위해서는 적절한 증명이&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;효율성&lt;/strong&gt;은 알고리즘이 얼마나 빠르게 동작하는지를 나타내며, 이는 시간과 자원의 소비를 분석하는 중요한 지표이다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-복잡도&#34;&gt;2. 복잡도&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;복잡도는 알고리즘이 자원을 얼마나 효율적으로 사용하는지를 나타내는 개념이다. 자원에는 주로 &lt;strong&gt;시간&lt;/strong&gt;과 &lt;strong&gt;공간&lt;/strong&gt;(메모리)이 포함되며, 복잡도는 이 자원들이 입력 크기(n)에 따라 어떻게 변하는지를 수학적으로 표현한다!&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
