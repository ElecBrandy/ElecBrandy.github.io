<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>42cursus on Elecbrandy</title>
    <link>https://elecbrandy.github.io/tags/42cursus/</link>
    <description>Recent content in 42cursus on Elecbrandy</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 15 Aug 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://elecbrandy.github.io/tags/42cursus/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[42cursus] netpractice</title>
      <link>https://elecbrandy.github.io/posts/42cursus/netpractice/</link>
      <pubDate>Thu, 15 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/netpractice/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;This document is a System Administration related exercise.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;소개&#34;&gt;소개&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;https://i.imgur.com/UCUbHvr.png&#34; width=&#34;700&#34;&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 n번째로 수행한 과제로, 교육 인터페이스상에서 소규모 네트워크를 구성하는 과제이다. 네트워킹 문제를 해결하여 네트워크가 실행되도록 만들어야 한다. 총 10개의 문제를 완료하고, Git 저장소에 제출하는 것이 최종 목표이다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;개념-정리&#34;&gt;개념 정리&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;네트워크란&#34;&gt;네트워크란?&lt;/h2&gt;&#xA;&lt;p&gt;네트워크는 두 대 이상의 컴퓨터 시스템이 서로 연결되어 데이터를 교환할 수 있는 구조를 의미한다. 이 연결은 다양한 방법으로 이루어질 수 있으며, 물리적 케이블, 무선 신호, 또는 혼합된 방식으로 네트워크를 구성할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] pipex</title>
      <link>https://elecbrandy.github.io/posts/42cursus/pipex/</link>
      <pubDate>Wed, 28 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/pipex/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Cristina: &amp;ldquo;Go dance salsa somewhere :)&amp;rdquo;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;소개&#34;&gt;소개&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 다섯번째로 수행한 과제로, UNIX 동작 원리를 프로그래밍을 통해 상세히 파헤쳐보는 과제이다.&#xA;Shell에서의 파이프를 구현하는 과제이며 Redriection, File discriptor, Process, Pipe, Fork 등을 공부할 수 있다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;pipex-명세서&#34;&gt;pipex 명세서&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;mandatory-part&#34;&gt;Mandatory part&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;pipex&lt;/code&gt;는 &lt;code&gt;./pipex file1 cmd1 cmd2 file2&lt;/code&gt; 형태로 실행된다.&lt;/li&gt;&#xA;&lt;li&gt;file1과 file2는 파일 이름이다.&lt;/li&gt;&#xA;&lt;li&gt;cmd1과 cmd2는 매개 변수가 존재하는 쉘 명령어이다.&lt;/li&gt;&#xA;&lt;li&gt;프로그램은 &lt;code&gt;&amp;lt; file1 cmd1 | cmd2 &amp;gt; file2&lt;/code&gt; 명령과 동일하게 작동해야 한다.&lt;/li&gt;&#xA;&lt;li&gt;즉, file1을 input으로 받아 cmd1를 실행하고, 그 결과를 파이프를 통해 cmd2로 넘긴 후 output인 file2로 내보낸다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;bonus-part&#34;&gt;Bonus part&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Bonus part&lt;/strong&gt;에서는 다중 파이프와 here_doc를 구현해야 한다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;다중 파이프&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pipex : &lt;code&gt;./pipex file1 cmd1 cmd2 cmd3 ... cmdn file2&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;bash : &lt;code&gt;&amp;lt; file1 cmd1 | cmd2 | cmd3 ... | cmdn &amp;gt; file2&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;here_doc&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pipex : &lt;code&gt;./pipex here_doc LIMITER cmd cmd1 file&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;bash : &lt;code&gt;cmd &amp;lt;&amp;lt; LIMITER | cmd1 &amp;gt;&amp;gt; file&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;개념-정리&#34;&gt;개념 정리&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;redirection&#34;&gt;Redirection&lt;/h2&gt;&#xA;&lt;p&gt;redirection은 shell에서 입력과 출력의 흐름을 재지정하는 프로세스이다. 기본적으로 커맨드는 표준 입력(stdin), 표준 출력(stdout), 그리고 표준 에러(stderr)라는 세 가지 주요 통신 채널을 사용한다. 리디렉션을 사용하면 이러한 통신 채널을 파일이나 다른 프로그램으로 전환할 수 있다. 유닉스 및 리눅스 기반 시스템에서 매우 강력한 도구로 시스템 관리, 스크립팅 및 데이터 관리에 유용하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] push_swap</title>
      <link>https://elecbrandy.github.io/posts/42cursus/push_swap/</link>
      <pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/push_swap/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Because Swap_push isn’t as natural&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;소개&#34;&gt;소개&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 네번째로 수행한 과제로, 스택에 있는 데이터를 한정된 명령어를 이용하여 최대한 적은 횟수 내에 정렬하는 것을 목표로 하는 과제이다.&#xA;상당히 아이러니한 과제이다. 스택이라고 명시되어있지만, 과제에서 요구하는 구조는 스택과는 거리가 멀고, 명령어도 한정되어있다.&lt;/p&gt;&#xA;&lt;p&gt;또한 정렬 시 복잡도를 고려하는 것이 아니라 명령어 갯수만 어떻게든 줄여서 출력하면 ok를 받을 수 있다.&lt;/p&gt;&#xA;&lt;p&gt;그렇다보니 가장 많이 쓰이는 방법이 그리디 알고리즘를 통해 모든 정렬 경우의 수를 먼저 체크하고, 명령어 수를 최적화하여 이후에 출력하는 것이다.&#xA;정렬 시 사용한 명령어 개수에 따라 점수가 달라질 수 있다. (&lt;strong&gt;기수 정렬&lt;/strong&gt;도 하나의 방법!)&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] born2beroot</title>
      <link>https://elecbrandy.github.io/posts/42cursus/born2beroot/</link>
      <pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/born2beroot/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;YOU CAN DO ANYTHING YOU WANT TO DO, VIRTUAL MACHINE, THIS IS YOUR WORLD&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;소개&#34;&gt;소개&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;https://user-images.githubusercontent.com/87311268/221544778-c85cb3d8-32f4-4919-aa1c-0db54b33b38a.jpg&#34; width=&#34;700&#34;&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 네번째로 수행한 과제로, 가상머신에 리눅스를 설치하고 공부하는 과정이다.&lt;/p&gt;&#xA;&lt;p&gt;가상머신에 리눅스(Debian or Rocky)를 설치하고, LVM를 통한 파티션 설정과 기타 여러가지 기능을 직접 실습한다. 백문불여일견. 요구사항이 상당히 많고 처음 접한다면 배워야할 개념도 상당히 많다&amp;hellip; 화이팅!&#xA;리눅스 설치는 하다보면 100번이라도 해야만 하는 상황이기 때문에 중요한 개념 위주로만 정리했다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>File descriptor</title>
      <link>https://elecbrandy.github.io/posts/cs101/filedescriptor/</link>
      <pubDate>Sun, 24 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/filedescriptor/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;운영 체제에서 파일이나 입출력 자원을 식별하기 위해 사용하는&amp;hellip;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;p&gt;&lt;code&gt;Libft&lt;/code&gt; 과제에 이어 &lt;code&gt;get_next_line&lt;/code&gt; 과제를 진행하던 중 파일 디스크립터 개념을 만나게 되어 정리했다. 결국은 파일에게 접근하기 위한 번호이자 거창하게는 파일 포인터 개념으로 이해하고 넘어가자.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;file-descripot&#34;&gt;File Descripot&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;리눅스 시스템에서는 모든 것이 파일&#xA;&lt;ul&gt;&#xA;&lt;li&gt;객체, 행동, 디바이스, 네트워크 연결, 디렉터리, 프로세스 등등&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;이때 시스템이 이 파일들에게 접근 시 File Descriptor라는 개념을 이용함&lt;/li&gt;&#xA;&lt;li&gt;File Descriptor는 Non-negative Integer 값을 가짐(0 ~ OPEN_MAX)&lt;/li&gt;&#xA;&lt;li&gt;Process에서 열린 파일의 목록을 관리하는 테이블의 인덱스! (0, 1, 2는 기본 할당)&lt;/li&gt;&#xA;&lt;li&gt;FD 테이블의 각 항목은 FD 플래그와 파일 테이블로의 포인터와 같음&lt;/li&gt;&#xA;&lt;li&gt;이 포인터를 이용하여 FD 를 통해 시스템의 파일을 참조!&lt;/li&gt;&#xA;&lt;li&gt;Process는 이런 FD 테이블과 파일 테이블의 정보를 직접 고칠 수 없으며, 반드시 커널을 통해서 수정을 해야함&lt;/li&gt;&#xA;&lt;li&gt;프로그램에서 FD 참조시 index를 사용할 수도 있고, POSIX 명을 사용할 수도 있음&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;fd와-열려-있는-파일의-관계&#34;&gt;FD와 열려 있는 파일의 관계&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;각 프로세스별로 커널은 &lt;code&gt;open file descriptor table&lt;/code&gt; 을 가짐&lt;/li&gt;&#xA;&lt;li&gt;테이블의 각 엔트리는 하나의 FD에 대한 동작 제어 플래그, 열린 파일을 가리키는 참조를 담고 있음&lt;/li&gt;&#xA;&lt;li&gt;특히 &lt;code&gt;open file descriptor table&lt;/code&gt; 현재 파일의 Offset, flag, 접근 모드 ,i/o 관련 설정, 파일의 i-node 객체를 가리키는 정보를 담고 있음&lt;/li&gt;&#xA;&lt;li&gt;같은 &lt;code&gt;open file descripton&lt;/code&gt; 을 가르키는 2개의 FD가 Offset 값을 공유함&#xA;&lt;ul&gt;&#xA;&lt;li&gt;간단한 예시&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;file.txt&lt;/code&gt; 열고 두 개의 파일 디스크립터를 얻는다.&lt;/li&gt;&#xA;&lt;li&gt;FD1을 이용해서 파일 처음으로 이동한다. (offset 0)&lt;/li&gt;&#xA;&lt;li&gt;FD2을 이용해서 파일 어딘가로 이동한다. (offset 100)&lt;/li&gt;&#xA;&lt;li&gt;FD1과 FD2는 동일한 파일 &lt;code&gt;file.txt&lt;/code&gt;를 가리키지만 FD1은 파일의 처음 / FD2는 파일의 어딘가를  가리킨다.&lt;/li&gt;&#xA;&lt;li&gt;이렇게 동시에 한 파일을 여러 위치에서 읽고 쓸 수 있다.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;정리&#34;&gt;정리&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;file.txt&lt;/code&gt; 를 열면 OS는 &lt;code&gt;open file descriptor table&lt;/code&gt;에 해당 항목을 추가한다.&lt;/li&gt;&#xA;&lt;li&gt;이때 인덱스는 &lt;code&gt;file.txt&lt;/code&gt; 를 가르킨다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;file.txt&lt;/code&gt; 를 닫으면 테이블에서 해당 인덱스가 사라진다.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=EqndHT606Tw&#34;&gt;https://www.youtube.com/watch?v=EqndHT606Tw&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=btT4HDKNIOw&#34;&gt;https://www.youtube.com/watch?v=btT4HDKNIOw&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dev-ahn.tistory.com/96&#34;&gt;https://dev-ahn.tistory.com/96&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;div class=&#34;alert&#34;&gt;&#xA;    &lt;span&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/CS101&#34;&gt; CS101 &lt;/a&gt;&lt;/span&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;</description>
    </item>
    <item>
      <title>LVM</title>
      <link>https://elecbrandy.github.io/posts/cs101/lvm/</link>
      <pubDate>Wed, 20 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/lvm/</guid>
      <description>&lt;h1 id=&#34;lvm&#34;&gt;LVM&lt;/h1&gt;&#xA;&lt;h2 id=&#34;lvm이란&#34;&gt;LVM이란?&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Linux Volume Manager&lt;/li&gt;&#xA;&lt;li&gt;[[Linux]]에서 복잡한 스토리지 구성을 효율적으로 관리하기 위한 시스템&lt;/li&gt;&#xA;&lt;li&gt;물리적 디스크를 하나의 논리적 볼륨으로 결합할 수 있고, 볼륨의 크기를 쉽게 조정 가능&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;lvm-특징&#34;&gt;LVM 특징&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;기존 방식과 LVM 방식&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;기존 방식&#xA;&lt;ul&gt;&#xA;&lt;li&gt;[[File system]]이 물리적 블록장치와 직접 상호작용&lt;/li&gt;&#xA;&lt;li&gt;마운트된 파티션의 용량이 가득 차 이동 시&#xA;&lt;ul&gt;&#xA;&lt;li&gt;추가 디스크 장착&lt;/li&gt;&#xA;&lt;li&gt;추가된 디스크에 파티션 생성 및 포맷&lt;/li&gt;&#xA;&lt;li&gt;새로운 마운트 포인트(b)를 만들고 추가한 파티션 마운트&lt;/li&gt;&#xA;&lt;li&gt;기존 데이터를 (b)에 이동&lt;/li&gt;&#xA;&lt;li&gt;기존 파티션 언마운트 후 새 포인트와 연결&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;LVM 방식&#xA;&lt;ul&gt;&#xA;&lt;li&gt;[[File system]]이 LVM이 만든 가상의 블록 장치에 상호작용함&lt;/li&gt;&#xA;&lt;li&gt;실제 블록 장치를 추상화하여 더 유연한 접근이 가능함&lt;/li&gt;&#xA;&lt;li&gt;마운트된 파티션의 용량이 가득 차 이동 시&#xA;&lt;ul&gt;&#xA;&lt;li&gt;추가 디스크 장착&lt;/li&gt;&#xA;&lt;li&gt;추가 디스크에 Partition을 만들고 pv 초기화&lt;/li&gt;&#xA;&lt;li&gt;pv를 vg에 추가하고 해당 논리 볼륨 사이즈 증가&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;lvm-단위-구성&#34;&gt;LVM 단위 구성&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;PV&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Physical Volume&lt;/li&gt;&#xA;&lt;li&gt;LVM에서 블록장치에 접근하기 위해서 PV로 초기화가 필요&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;PE&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Physical Extent&lt;/li&gt;&#xA;&lt;li&gt;PV를 구성하는 일정한 크기의 블록으로 LVM2에서 기본 크기가 4MB&lt;/li&gt;&#xA;&lt;li&gt;LV의 LE와 1:1로 대응&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;VG&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Volume Group&lt;/li&gt;&#xA;&lt;li&gt;PV들의 집합으로 LV를 할당할 수 있는 공간&lt;/li&gt;&#xA;&lt;li&gt;PV로 초기화된 장치들은 VG로 통합됨&lt;/li&gt;&#xA;&lt;li&gt;사용자는 VG 안에서 유연성 높게 공간을 쪼개 LV 생성 가능&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LV&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Logical Volume&lt;/li&gt;&#xA;&lt;li&gt;사용자가 최종적으로 다루게 되는 논리적 스토리지&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LV의 유형&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Linear LV&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;선형으로 PV를 모아 LV로 만드는 방법&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Striped LV&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;대량의 순차적 읽기/쓰기 작업의 경우 효율적으로 높일 수 있음&lt;/li&gt;&#xA;&lt;li&gt;선형이 아니라 여러 PV에 번갈아가며 기록하는 방법&lt;/li&gt;&#xA;&lt;li&gt;결국 분산기록이며, 읽고 쓰기가 병렬로 실행 가능&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Mirrored LV&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;블록 장치에 저장된 데이터의 복사본을 다른 블록 장치에 저장하는 방식&lt;/li&gt;&#xA;&lt;li&gt;백업에 용이함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LE&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;LV를 구성하는 일정한 크기의 블록으로 PE와 마찬가지로 4MB&lt;/li&gt;&#xA;&lt;li&gt;각각의 LV들은 PE들과 1:1로 맵핑됨&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://tech.cloud.nongshim.co.kr/2018/11/23/lvmlogical-volume-manager-1-%EA%B0%9C%EB%85%90/&#34;&gt;https://tech.cloud.nongshim.co.kr/2018/11/23/lvmlogical-volume-manager-1-%EA%B0%9C%EB%85%90/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://nayoungs.tistory.com/entry/Linux-LVMLogical-Volume-Manage-PV-VG-LV&#34;&gt;https://nayoungs.tistory.com/entry/Linux-LVMLogical-Volume-Manage-PV-VG-LV&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>[42cursus] get_next_line</title>
      <link>https://elecbrandy.github.io/posts/42cursus/get_next_line/</link>
      <pubDate>Mon, 18 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/get_next_line/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Reading a line on a fd is way too tedious&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;소개&#34;&gt;소개&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;https://imgur.com/2R4ZmUq.png&#34; width=&#34;700&#34;&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 세번째로 수행한 과제로, 파일 디스크립터로부터 읽혀진 - 개행으로 끝나는 한 줄을 반환하는 함수를 만드는 과제이다. 즉 파일 하나를 연 다음, 파일 내용에서 개행으로 끝나는 줄 하나를 반환해야한다. 파일을 열고, 지정된 &lt;strong&gt;BUFFER_SIZE&lt;/strong&gt; 만큼 &lt;code&gt;read&lt;/code&gt;함수를 통해 파일을 읽다가 개행문자 &lt;code&gt;\n&lt;/code&gt;이 나타나면 개행문자 전까지만 반환한다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;get_next_line-명세서&#34;&gt;get_next_line 명세서&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;PROTOTYPE&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;char *get_next_line(int fd);&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;PARAMETER&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;int fd&lt;/code&gt; : 읽어들일 파일의 디스크립터&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;DESCRIPTION&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Mandatory part&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;호출마다 한 번에 한 줄씩 파일 디스크립터가 가리키는 파일을 읽어온다.&lt;/li&gt;&#xA;&lt;li&gt;더 이상 읽어올 것이 없거나 에러가 발생하면 &lt;code&gt;NULL&lt;/code&gt;을 반환한다.&lt;/li&gt;&#xA;&lt;li&gt;파일 끝에 도달하였고, 개행문자 &lt;code&gt;\n&lt;/code&gt;이 존재하지 않을 때를 제외하고 반환하는 문자열에는 &lt;code&gt;\n&lt;/code&gt;이 포함되어야 한다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Bonus part&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;정적 변수를 하나만 사용하여 개발해야한다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;get_next_line()&lt;/code&gt; 이 여러 개의 파일 디스크립터를 한번에 관리해야 한다.&lt;/li&gt;&#xA;&lt;li&gt;한번 호출하여 3, 4, 5 그 이후 다시 4, 5 등등을 읽을 수 있어야 한다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;External functs&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;read, malloc, free&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RETURN VALUES&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;한 줄을 제대로 읽은 정상작동의 경우 읽은 라인을 반환한다.&lt;/li&gt;&#xA;&lt;li&gt;비정상작동의 경우 &lt;code&gt;NULL&lt;/code&gt;을 반환한다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;개념-정리&#34;&gt;개념 정리&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;연결리스트와-open_max&#34;&gt;연결리스트와 OPEN_MAX&lt;/h2&gt;&#xA;&lt;p&gt;본 과제를 &lt;strong&gt;BONUS&lt;/strong&gt;까지 수행한다면, 즉 동시에 여러 파일 디스크립터를 감안하는 프로그램을 만들고 싶다면 크게 두가지 방법이 존재한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] ft_printf</title>
      <link>https://elecbrandy.github.io/posts/42cursus/ft_printf/</link>
      <pubDate>Wed, 15 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/ft_printf/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;putnbr and putstr aren’t enough&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;소개&#34;&gt;소개&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 두번째로 수행한 과제로, 말 그대로 C언어의 &lt;code&gt;printf&lt;/code&gt; 함수를 재현하는 과제이다. bonus는 수행하지 않았고, 기본적인 내용만 구현하다보니 생각보다 난이도가 쉬웠던 것 같다. libc의 &lt;code&gt;printf&lt;/code&gt; 함수를 재구현해야 하며, 실제 &lt;code&gt;printf&lt;/code&gt;처럼 버퍼 관리를 수행해서는 안 된다. 서식 지정자 &lt;code&gt;cspdiuxX%&lt;/code&gt;를 구현해야한다.&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;ft_printf-명세서&#34;&gt;ft_printf 명세서&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;PROTOTYPE&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;int ft_printf(const char *str, ...);&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;PARAMETER&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;const char *str&lt;/code&gt; : format 이라는 이름의 문자열 상수 (서식 문자열)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;...&lt;/code&gt; : 생략 기호로, 두번째 이후 인수부터는 인수의 개수와 타입을 점검하지 않으며, 컴파일러는 이후의 인수에 대해서 개수, 타입에 상관없이 그대로 함수에 넘겨줌&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;DESCRIPTION&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;%c&lt;/code&gt; 단일 문자를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%s&lt;/code&gt; 문자열을 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%p&lt;/code&gt; void * 포인터 인수는 16진수 형식으로 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%d&lt;/code&gt; 십진수(기본 10)를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%i&lt;/code&gt; 기본 10의 정수를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%u&lt;/code&gt; 부호 없는 10진수(베이스 10)를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%x&lt;/code&gt; 16진수(베이스 16) 소문자 형식으로 숫자를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%X&lt;/code&gt; 16진수(베이스 16) 대문자 형식으로 숫자를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;%%&lt;/code&gt; 백분율 기호를 인쇄&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;External functs&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;malloc, free, write&lt;/li&gt;&#xA;&lt;li&gt;va_start, va_arg, va_copy, va_end&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RETURN VALUES&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;em&gt;Upon successful return, these functions return the number of characters printed (excluding the null byte used to end output to strings).&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;성공적으로 반환되면, 이 함수들은 인쇄된 문자 수를 반환합니다.(출력을 끝내는 데 사용되는 널 바이트 제외) 문자열을 반환함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;개념-정리&#34;&gt;개념 정리&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;가변인자&#34;&gt;가변인자&lt;/h2&gt;&#xA;&lt;p&gt;가변인자 다루는 것에 중점을 둔 과제인 만큼, &lt;code&gt;va_&lt;/code&gt; 함수를 통해 가변인자를 통제하는 방법을 알아야한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[42cursus] libft</title>
      <link>https://elecbrandy.github.io/posts/42cursus/libft/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/libft/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Your very first own library&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h1 id=&#34;소개&#34;&gt;소개&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;42서울 본과정 입과 후 첫번째로 만나는 과제로 앞으로 본과정에서 사용할 라이브러리를 만드는 것이 목표이다.&#xA;이후 과제를 수행하며 자주 사용할 함수들이 몇가지 있기 때문에 최대한 범용성 높게 - 커스텀하기 쉽게 만드는 것을 목표로 했다.&#xA;항상 느끼는 것이지만 &lt;code&gt;norm&lt;/code&gt; 규칙의 첫번째 목표는 카뎃이 다른 카뎃의 코드를 보았을 때 최소한의 일관성을 유지하여 쉽게 읽을 수 있게 하는 것&amp;hellip; 이고&#xA;두번째는 코드 길이를 적당히 조절함으로써 자연스럽게 모듈화를 하게 하는 것. 그 이상의 의미는 두지 않기로 했다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>C build</title>
      <link>https://elecbrandy.github.io/posts/cs101/buildc/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/buildc/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;컴파일 언어(compiled language)는 코드가 실행되기 전 컴파일러를 거쳐서 기계어로 모두 변환되어 실행되는 프로그래밍 언어이다.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;1-preprocess&#34;&gt;1. Preprocess&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;전처리기 &lt;strong&gt;cpp&lt;/strong&gt; 에 의해 수행&lt;/li&gt;&#xA;&lt;li&gt;header inclusion&#xA;&lt;ul&gt;&#xA;&lt;li&gt;헤더 파일에 정의된 변수와 함수를 포함하는 과정&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;macro expansion&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;#define&lt;/code&gt; 같은 매크로 등을 소스코드로 변경&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;.c&lt;/code&gt;&lt;/strong&gt; -&amp;gt; &lt;strong&gt;&lt;code&gt;.i&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;2-complie&#34;&gt;2. Complie&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;컴파일러 &lt;strong&gt;ccl&lt;/strong&gt; 에 의해 수행&lt;/li&gt;&#xA;&lt;li&gt;c언어 코드를 어셈블리어로 변환&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;.i&lt;/code&gt;&lt;/strong&gt; -&amp;gt; &lt;strong&gt;&lt;code&gt;.s&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;3-assemble&#34;&gt;3. Assemble&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;어셈블러 &lt;strong&gt;as&lt;/strong&gt; 에 의해 수행&lt;/li&gt;&#xA;&lt;li&gt;어셈블리어를 바이너리 형태로 변환 (목적 파일 생성)&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;.s&lt;/code&gt;&lt;/strong&gt; -&amp;gt; &lt;strong&gt;&lt;code&gt;.o&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;4-link&#34;&gt;4. Link&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;여러 목적파일과 라이브러리들을 모아 실행 가능한 단일 파일로 결합&lt;/li&gt;&#xA;&lt;li&gt;정적 라이브러리도 함께 결합됨&#xA;&lt;ul&gt;&#xA;&lt;li&gt;라이브러리는 이미 컴파일 되어있으므로 링크만 하면 바로 사용 가능&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;빌드 과정의 마지막 단계로서, 실행 파일이 생성되면 프로그램이 &lt;strong&gt;빌드&lt;/strong&gt;되었다고 함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;5-runtime&#34;&gt;5. &lt;strong&gt;Runtime&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;목적 파일 처럼 중간 과정을 거치는 이유?&#xA;&lt;ul&gt;&#xA;&lt;li&gt;소스를 각기 다른 언어로 작성했을 수도 있음&lt;/li&gt;&#xA;&lt;li&gt;한 파일에 모든 함수나 기능을 넣는 것이 비효율적이고 불가능에 가까움&lt;/li&gt;&#xA;&lt;li&gt;결국 쪼개진 각기 다른 여러 파일을 잘 합치기 위함&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;div class=&#34;alert&#34;&gt;&#xA;    &lt;span&gt;&lt;a href=&#34;https://elecbrandy.github.io/tags/CS101&#34;&gt; CS101 &lt;/a&gt;&lt;/span&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;br&gt;</description>
    </item>
    <item>
      <title>Makefile</title>
      <link>https://elecbrandy.github.io/posts/cs101/makefile/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/makefile/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;The script that automates software build processes with the make utility&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;br&gt;&#xA;&lt;p&gt;&lt;code&gt;Makefile&lt;/code&gt; 은 소프트웨어 개발 과정에서 빌드를 자동화하는 강력한 도구이다. 복잡한 빌드 단계를 단순하고 반복 가능하게 만들어 주는 것이 핵심 기능이다. 프로그래머들에게 시간을 절약하고 오류를 줄여주는 데 큰 도움을 준다.&#xA;&lt;br&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;makefile&#34;&gt;Makefile&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Makefile&lt;/code&gt; 이란 자동화, 의존성 관리, 효율성, 모듈성, 표준화를 목적으로 함&#xA;&lt;ul&gt;&#xA;&lt;li&gt;자동화&#xA;&lt;ul&gt;&#xA;&lt;li&gt;복잡한 빌드 명령어를 자동화하여 개발자가 빌드 프로세스를 쉽게 반복&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;의존성 관리&#xA;&lt;ul&gt;&#xA;&lt;li&gt;소스 파일과 헤더 파일 간의 의존성을 추적하여 변경 시에만 관련 파일을 재컴파일&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;효율성&#xA;&lt;ul&gt;&#xA;&lt;li&gt;전체 프로젝트를 빌드하는 대신 변경된 부분만 빌드하여 시간과 자원을 절약&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;모듈성&#xA;&lt;ul&gt;&#xA;&lt;li&gt;빌드 프로세스를 여러 단계로 분리하여 복잡성을 관리해 유지보수가 용이&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;표준화&#xA;&lt;ul&gt;&#xA;&lt;li&gt;일관된 빌드 절차로 다른 개발자가 쉽게 이해하고 사용할 수 있음&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Makefile&lt;/code&gt; 의 기본적 구성&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;target&lt;/code&gt; : 하나의 실행 가능 파일&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;dependency&lt;/code&gt; : 하나의 대상과 그것이 의존하는 소스파일&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;rule&lt;/code&gt; : 의존 파일들로부터 대상 파일을 생성하는 방법을 정의&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h2 id=&#34;예시&#34;&gt;예시&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Makefile&#34; data-lang=&#34;Makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CC &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cc&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CFLAGS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; -Wall -Wextra -Werror&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;INS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; .&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NAME &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; libft.a&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
  </channel>
</rss>
