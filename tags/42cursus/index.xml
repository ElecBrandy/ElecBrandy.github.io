<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>42cursus on Elecbrandy</title>
    <link>https://elecbrandy.github.io/tags/42cursus/</link>
    <description>Recent content in 42cursus on Elecbrandy</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 11 Apr 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://elecbrandy.github.io/tags/42cursus/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>생성형 AI 레드팀 챌린지</title>
      <link>https://elecbrandy.github.io/posts/ai/airedteam/</link>
      <pubDate>Thu, 11 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/ai/airedteam/</guid>
      <description>AI 안전과 신뢰, 그리고 레드팀&#xA;01 소개 과학기술정보통신부 주최로 개최한 &amp;lsquo;생성형 AI 레드팀 챌린지&amp;rsquo;는 국내 생성형 AI 모델을 대상으로 사용자의 프롬프트 공격을 방어하기 위해 잠재적 위험 요소를 식별하기 위한 프로그램이다. 생성형 AI가 사용자의 프롬프트의 내용에 따라 부적절한 내용(인종차별, 혐오, 잘못된 정보 등)을 생성할 수 있다. 때문에 기업에서는 이를 방어하고자 레드팀을 꾸려 시스템의 취약점과 결함을 찾고자 노력하고 있으며, 정부 차원에서 받아들여&#xA;02 Born2beroot 개념정리 운영체제 Operating System은 응용 프로그램 또는 사용자에게 컴퓨터 자원을 사용할 수 있는 인터페이스를 제공하고, 그 결과를 돌려주는 시스템 소프트웨어이다.</description>
    </item>
    <item>
      <title>[42cursus] PIPEX</title>
      <link>https://elecbrandy.github.io/posts/42cursus/pipex/</link>
      <pubDate>Wed, 28 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/pipex/</guid>
      <description>Cristina: &amp;ldquo;Go dance salsa somewhere :)&amp;rdquo;&#xA;01 소개 42서울 본과정 입과 후 다섯번째로 수행한 과제로, UNIX 동작 원리를 프로그래밍을 통해 상세히 파헤쳐보는 과제이다. Shell에서의 파이프를 구현하는 과제이며 Redriection, File discriptor, Process, Pipe, Fork 등을 공부할 수 있다.&#xA;02 PIPEX 명세서 Mandatory part pipex는 ./pipex file1 cmd1 cmd2 file2 형태로 실행된다. file1과 file2는 파일 이름이다. cmd1과 cmd2는 매개 변수가 존재하는 쉘 명령어이다. 프로그램은 &amp;lt; file1 cmd1 | cmd2 &amp;gt; file2 명령과 동일하게 작동해야 한다.</description>
    </item>
    <item>
      <title>[42cursus] PUSH_SWAP</title>
      <link>https://elecbrandy.github.io/posts/42cursus/push_swap/</link>
      <pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/push_swap/</guid>
      <description>Because Swap_push isn’t as natural&#xA;01 소개 42서울 본과정 입과 후 네번째로 수행한 과제로, 스택에 있는 데이터를 한정된 명령어를 이용하여 최대한 적은 횟수 내에 정렬하는 것을 목표로 하는 과제이다. 상당히 아이러니한 과제이다. 스택이라고 명시되어있지만, 과제에서 요구하는 구조는 스택과는 거리가 멀고, 명령어도 한정되어있다. 또한 정렬 시 복잡도를 고려하는 것이 아니라 명령어 갯수만 어떻게든 줄여서 출력하면 ok를 받을 수 있다. 그렇다보니 가장 많이 쓰이는 방법이 그리디 알고리즘를 통해 모든 정렬 경우의 수를 먼저 체크하고, 명령어 수를 최적화하여 이후에 출력하는 것이다.</description>
    </item>
    <item>
      <title>[42cursus] Born2beroot</title>
      <link>https://elecbrandy.github.io/posts/42cursus/born2beroot/</link>
      <pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/born2beroot/</guid>
      <description>YOU CAN DO ANYTHING YOU WANT TO DO, VIRTUAL MACHINE, THIS IS YOUR WORLD&#xA;01 소개 42서울 본과정 입과 후 네번째로 수행한 과제로, 가상머신에 리눅스를 설치하고 공부하는 과정이다. 가상머신에 리눅스(Debian or Rocky)를 설치하고, LVM를 통한 파티션 설정과 기타 여러가지 기능을 직접 실습한다. 백문불여일견. 요구사항이 상당히 많고 처음 접한다면 배워야할 개념도 상당히 많다&amp;hellip; 화이팅! 리눅스 설치는 하다보면 100번이라도 해야만 하는 상황이기 때문에 중요한 개념 위주로만 정리했다.&#xA;02 Born2beroot 개념정리 운영체제 Operating System은 응용 프로그램 또는 사용자에게 컴퓨터 자원을 사용할 수 있는 인터페이스를 제공하고, 그 결과를 돌려주는 시스템 소프트웨어이다.</description>
    </item>
    <item>
      <title>File descriptor</title>
      <link>https://elecbrandy.github.io/posts/cs101/filedescriptor/</link>
      <pubDate>Sun, 24 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/filedescriptor/</guid>
      <description>운영 체제에서 파일이나 입출력 자원을 식별하기 위해 사용하는&amp;hellip;&#xA;Libft 과제에 이어 get_next_line 과제를 진행하던 중 파일 디스크립터 개념을 만나게 되어 정리했다. 결국은 파일에게 접근하기 위한 번호이자 거창하게는 파일 포인터 개념으로 이해하고 넘어가자.&#xA;File Descripot 리눅스 시스템에서는 모든 것이 파일 객체, 행동, 디바이스, 네트워크 연결, 디렉터리, 프로세스 등등 이때 시스템이 이 파일들에게 접근 시 File Descriptor라는 개념을 이용함 File Descriptor는 Non-negative Integer 값을 가짐(0 ~ OPEN_MAX) Process에서 열린 파일의 목록을 관리하는 테이블의 인덱스!</description>
    </item>
    <item>
      <title>LVM</title>
      <link>https://elecbrandy.github.io/posts/cs101/lvm/</link>
      <pubDate>Wed, 20 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/lvm/</guid>
      <description>LVM LVM이란? Linux Volume Manager [[Linux]]에서 복잡한 스토리지 구성을 효율적으로 관리하기 위한 시스템 물리적 디스크를 하나의 논리적 볼륨으로 결합할 수 있고, 볼륨의 크기를 쉽게 조정 가능 LVM 특징 기존 방식과 LVM 방식 기존 방식 [[File system]]이 물리적 블록장치와 직접 상호작용 마운트된 파티션의 용량이 가득 차 이동 시 추가 디스크 장착 추가된 디스크에 파티션 생성 및 포맷 새로운 마운트 포인트(b)를 만들고 추가한 파티션 마운트 기존 데이터를 (b)에 이동 기존 파티션 언마운트 후 새 포인트와 연결 LVM 방식 [[File system]]이 LVM이 만든 가상의 블록 장치에 상호작용함 실제 블록 장치를 추상화하여 더 유연한 접근이 가능함 마운트된 파티션의 용량이 가득 차 이동 시 추가 디스크 장착 추가 디스크에 Partition을 만들고 pv 초기화 pv를 vg에 추가하고 해당 논리 볼륨 사이즈 증가 LVM 단위 구성 PV Physical Volume LVM에서 블록장치에 접근하기 위해서 PV로 초기화가 필요 PE Physical Extent PV를 구성하는 일정한 크기의 블록으로 LVM2에서 기본 크기가 4MB LV의 LE와 1:1로 대응 VG Volume Group PV들의 집합으로 LV를 할당할 수 있는 공간 PV로 초기화된 장치들은 VG로 통합됨 사용자는 VG 안에서 유연성 높게 공간을 쪼개 LV 생성 가능 LV Logical Volume 사용자가 최종적으로 다루게 되는 논리적 스토리지 LV의 유형 Linear LV 선형으로 PV를 모아 LV로 만드는 방법 Striped LV 대량의 순차적 읽기/쓰기 작업의 경우 효율적으로 높일 수 있음 선형이 아니라 여러 PV에 번갈아가며 기록하는 방법 결국 분산기록이며, 읽고 쓰기가 병렬로 실행 가능 Mirrored LV 블록 장치에 저장된 데이터의 복사본을 다른 블록 장치에 저장하는 방식 백업에 용이함 LE LV를 구성하는 일정한 크기의 블록으로 PE와 마찬가지로 4MB 각각의 LV들은 PE들과 1:1로 맵핑됨 Reference https://tech.</description>
    </item>
    <item>
      <title>[42cursus] GET_NEXT_LINE</title>
      <link>https://elecbrandy.github.io/posts/42cursus/get_next_line/</link>
      <pubDate>Mon, 18 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/get_next_line/</guid>
      <description>Reading a line on a fd is way too tedious&#xA;01 소개 42서울 본과정 입과 후 세번째로 수행한 과제로, 파일 디스크립터로부터 읽혀진 - 개행으로 끝나는 한 줄을 반환하는 함수를 만드는 과제이다. 즉 파일 하나를 연 다음, 파일 내용에서 개행으로 끝나는 줄 하나를 반환해야한다. 파일을 열고, 지정된 BUFFER_SIZE 만큼 read함수를 통해 파일을 읽다가 개행문자 \n이 나타나면 개행문자 전까지만 반환한다.&#xA;02 GET_NEXT_LINE 명세서 PROTOTYPE char *get_next_line(int fd); PARAMETER int fd : 읽어들일 파일의 디스크립터 DESCRIPTION Mandatory part 호출마다 한 번에 한 줄씩 파일 디스크립터가 가리키는 파일을 읽어온다.</description>
    </item>
    <item>
      <title>[42cursus] FT_PRINTF</title>
      <link>https://elecbrandy.github.io/posts/42cursus/ft_printf/</link>
      <pubDate>Wed, 15 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/ft_printf/</guid>
      <description>putnbr and putstr aren’t enough&#xA;01 소개 42서울 본과정 입과 후 두번째로 수행한 과제로, 말 그대로 C언어의 printf 함수를 재현하는 과제이다. bonus는 수행하지 않았고, 기본적인 내용만 구현하다보니 생각보다 난이도가 쉬웠던 것 같다. libc의 printf 함수를 재구현해야 하며, 실제 printf처럼 버퍼 관리를 수행해서는 안 된다. 서식 지정자 cspdiuxX%를 구현해야한다.&#xA;02 FT_PRINTF 명세서 PROTOTYPE int ft_printf(const char *str, ...); PARAMETER const char *str : format 이라는 이름의 문자열 상수 (서식 문자열) .</description>
    </item>
    <item>
      <title>[42cursus] LIBFT</title>
      <link>https://elecbrandy.github.io/posts/42cursus/libft/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/42cursus/libft/</guid>
      <description>Your very first own library&#xA;01 소개 42서울 본과정 입과 후 첫번째로 만나는 과제로 앞으로 본과정에서 사용할 라이브러리를 만드는 것이 목표이다. 이후 과제를 수행하며 자주 사용할 함수들이 몇가지 있기 때문에 최대한 범용성 높게 - 커스텀하기 쉽게 만드는 것을 목표로 했다. 항상 느끼는 것이지만 norm 규칙의 첫번째 목표는 카뎃이 다른 카뎃의 코드를 보았을 때 최소한의 일관성을 유지하여 쉽게 읽을 수 있게 하는 것&amp;hellip; 이고 두번째는 코드 길이를 적당히 조절함으로써 자연스럽게 모듈화를 하게 하는 것.</description>
    </item>
    <item>
      <title>C build</title>
      <link>https://elecbrandy.github.io/posts/cs101/buildc/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/buildc/</guid>
      <description>컴파일 언어(compiled language)는 코드가 실행되기 전 컴파일러를 거쳐서 기계어로 모두 변환되어 실행되는 프로그래밍 언어이다.&#xA;1. Preprocess 전처리기 cpp 에 의해 수행 header inclusion 헤더 파일에 정의된 변수와 함수를 포함하는 과정 macro expansion #define 같은 매크로 등을 소스코드로 변경 .c -&amp;gt; .i 2. Complie 컴파일러 ccl 에 의해 수행 c언어 코드를 어셈블리어로 변환 .i -&amp;gt; .s 3. Assemble 어셈블러 as 에 의해 수행 어셈블리어를 바이너리 형태로 변환 (목적 파일 생성) .</description>
    </item>
    <item>
      <title>Makefile</title>
      <link>https://elecbrandy.github.io/posts/cs101/makefile/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://elecbrandy.github.io/posts/cs101/makefile/</guid>
      <description>The script that automates software build processes with the make utility&#xA;Makefile 은 소프트웨어 개발 과정에서 빌드를 자동화하는 강력한 도구이다. 복잡한 빌드 단계를 단순하고 반복 가능하게 만들어 주는 것이 핵심 기능이다. 프로그래머들에게 시간을 절약하고 오류를 줄여주는 데 큰 도움을 준다. Makefile Makefile 이란 자동화, 의존성 관리, 효율성, 모듈성, 표준화를 목적으로 함 자동화 복잡한 빌드 명령어를 자동화하여 개발자가 빌드 프로세스를 쉽게 반복 의존성 관리 소스 파일과 헤더 파일 간의 의존성을 추적하여 변경 시에만 관련 파일을 재컴파일 효율성 전체 프로젝트를 빌드하는 대신 변경된 부분만 빌드하여 시간과 자원을 절약 모듈성 빌드 프로세스를 여러 단계로 분리하여 복잡성을 관리해 유지보수가 용이 표준화 일관된 빌드 절차로 다른 개발자가 쉽게 이해하고 사용할 수 있음 Makefile 의 기본적 구성 target : 하나의 실행 가능 파일 dependency : 하나의 대상과 그것이 의존하는 소스파일 rule : 의존 파일들로부터 대상 파일을 생성하는 방법을 정의 예시 CC = cc CFLAGS = -Wall -Wextra -Werror INS = .</description>
    </item>
  </channel>
</rss>
