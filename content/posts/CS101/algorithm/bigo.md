+++
title = '[알고리즘] Big O'
date = 2024-09-20
featured_image = "https://ih1.redbubble.net/image.1502642451.8092/st,small,507x507-pad,600x600,f8f8f8.jpg"
tags = ['algorithm']
+++

{{<series title="📚 /algorithm" series="algorithm">}}

<br>

## 1. Big O 소개
____

> **Big O 표기법의 형태**
> - O(1): 상수 시간, 입력 크기에 상관없이 항상 같은 시간이 걸린다.  
> - O(n): 입력 크기에 비례해서 시간이 걸린다.  
> - O(log n): 입력 크기가 증가할 때 실행 시간이 천천히 증가한다. 예를 들어, 이진 탐색 알고리즘이 이에 해당된다.  
> - O(n^2): 이중 반복문처럼, 입력 크기가 증가하면 실행 시간이 제곱으로 증가한다.  

빅오표기법(Big-O)은 알고리즘이 실행되는 시간이나 메모리 사용량이 입력 크기(데이터의 양)에 따라 어떻게 변하는지 표현하는 방법이다. 주로 시간 복잡도와 공간 복잡도를 측정하는데 사용된다.  

**시간 복잡도** 는 입력 크기가 커질 때 알고리즘이 얼마나 오래 걸리는지를 나타낸다. 예를 들어, 배열에서 특정 값을 찾는 알고리즘이 있다고 하자. 이때, 배열에 있는 모든 요소를 하나씩 비교해야 한다면, 배열의 크기가 클수록 시간이 더 오래 걸리게 된다. 이런 경우 시간 복잡도는 O(n)이다. 여기서 n은 배열의 크기다. 즉, 입력 크기 n에 비례해서 시간이 증가한다는 의미다.  

공간 복잡도는 알고리즘이 실행될 때 필요한 메모리 공간이 입력 크기에 따라 어떻게 변하는지 나타낸다. 예를 들어, 배열을 복사하는 알고리즘은 원본 배열과 같은 크기의 메모리가 추가로 필요하므로 공간 복잡도는 O(n)이다. 하지만 단순히 변수 하나만 사용한다면 O(1)로, 입력 크기와 무관하게 일정한 메모리만 필요하다는 의미다.  

시간 복잡도와 공간 복잡도를 함께 고려하는 이유는 효율적인 알고리즘을 찾기 위해서다. 알고리즘이 빠르게 실행되더라도 너무 많은 메모리를 사용하면 비효율적일 수 있고, 메모리를 적게 사용하더라도 너무 느리면 실용적이지 않기 때문이다. 빅오표기법에서 중요한 것은 정확한 실행 시간이 아니라, 입력 크기에 따라 어떻게 변화하는지의 경향이다. 즉, O(n), O(n^2), O(log n) 같은 표현으로 _"시간이 얼마나 급격히 늘어나는가"_ 를 나타낸다.  

<br>
<br>

## 1. 알고리즘의 분석
____

어떤 한 알고리즘을 분석할때 우리는 크게 구현 정확성와 효율성에 관심을 가진다. 구현은 실제로 알고리즘이 어떤 구조로 구현이 되어있는지, 정확성은 이 알고리즘이 정말로 기대한 역할을 수행하는지 증명이 되는지 그리고 효율성을 얼마나 빠른지 이다. 이떄 빅오를 통해 우리는 알고리즘의 효율성을 평가할 수 있다.  

알고리즘의 효율성은 어떤 언어로 구현했는지, 같은 방식의 알고리즘이더라도 세부 구현 사항에 따라, 환경에 따라, 사양에 따라, 컴파일러에 따라 상당히 많은 변수에 시간이 바뀘수 있어서 다른 요인들을 제하고 좀 다른 알고리즘끼리 효율성 비교가 쉽게 빅오로 판단하기 위해 ㅂ사용한다. 이때 우리가 관심을 가지는 것은 A라는 알고리즘이 있을때 이 알고리즘이 각 케이스에 어떻게 반응하는지임. 즉, 어떤 경우에 worstcase, bestcase 그리고 average case가 나오는지 이다.물론 우리가 자장 중요하게 생각해야하는건 가장 안좋을때이겟죠.

### 2-1. 점근적 분석법
점근적 분석이랑 자료의 갯수 n값이 커질수록 이에따라 n에 관한 한 알고리즘의 복잡도가 어떻게 변화하는지 알아보는 것이다. 여기서 포커스는 n. 우리의 목표는 결국 입력사이즈 n값이 매우 커질 떄에도 빠르게 작동하는 알고리즘을 만드는것이 아니겠나. n의 증가에 따라 T가 증가하는 양상으로 성능을 비교한다. 장점으로는 추상화(하드ㅇ웨어나 언어별 이슈 적당 무시), 그리고 알고리즘을 쉽게 분석할 수있는거. 단점으로는 너무 n에만 집중하는 경향이 있는거. 어쨋든 우리는 양상에 집중해보자.


## 1. Big-O
T(n) : n에 따른 내가 만든 알고리즘의 실행시간
g(n) : 참조를 위한 함수

이때 우리가 T(n)은 O(g(n))

## 5. Reference
____
- https://www.geeksforgeeks.org/insertion-sort-algorithm/

<br>
<br>