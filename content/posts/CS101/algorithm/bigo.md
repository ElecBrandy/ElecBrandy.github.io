+++
title = '[알고리즘] 알고리즘 분석'
date = 2024-09-20
featured_image = "https://ih1.redbubble.net/image.1502642451.8092/st,small,507x507-pad,600x600,f8f8f8.jpg"
tags = ['algorithm']
+++

{{<series title="📚 /algorithm" series="algorithm">}}

<br>

## 1. 알고리즘 분석
____

어떤 알고리즘이 있을 때, 어떻게 분석하는게 좋을까? 우리는 **구현 / 정확성 / 효율성**세 가지 핵심 요소를 통해 대상 알고리즘을 효과적으로 분석할 수 있다.

- **구현**은 알고리즘이 어떻게 구조화되고 작성되었는지를 의미하며, 코드 레벨에서의 설계와 구현 방식에 대한 부분이다.  
- **정확성**은 알고리즘이 기대한 대로 정확하게 동작하는지 평가하는 요소로, 원하는 결과를 항상 도출해낼 수 있는지 증명하는 것이다. 알고리즘의 정확한 작동을 담보하기 위해서는 적절한 증명이
- **효율성**은 알고리즘이 얼마나 빠르게 동작하는지를 나타내며, 이는 시간과 자원의 소비를 분석하는 중요한 지표이다.

<br>
<br>

## 2. 복잡도
____

복잡도는 알고리즘이 자원을 얼마나 효율적으로 사용하는지를 나타내는 개념이다. 자원에는 주로 **시간**과 **공간**(메모리)이 포함되며, 복잡도는 이 자원들이 입력 크기(n)에 따라 어떻게 변하는지를 수학적으로 표현한다!

#### 시간 복잡도(Time Complexity)
시간 복잡도는 **알고리즘이 실행되는 데 걸리는 시간**이 입력 크기 n에 따라 어떻게 변하는지를 나타낸다. 입력 크기가 커질수록 알고리즘이 얼마나 더 많은 시간을 소모하는지를 분석한다.

#### 공간 복잡도(Space Complexity)
공간 복잡도는 **알고리즘이 사용하는 메모리의 양**이 입력 크기 n에 따라 어떻게 변하는지를 나타낸다. 입력 크기가 커질수록 알고리즘이 얼마나 많은 메모리를 차지하는지를 분석한다.

#### 복잡도 고려
시간 복잡도와 공간 복잡도는 모두 중요한 요소지만, 현대 컴퓨터 기술의 발전으로 **공간 복잡도**는 메모리 용량의 증가로 인해 비교적 덜 신경 쓸 수 있게 되었다. 반면, **시간 복잡도**는 여전히 알고리즘 효율성의 핵심 관심사이다. 시간 복잡도를 평가할 때, 세 가지 주요 경우를 고려해야 한다:  

- **Best Case**
    - 알고리즘이 가장 빠르게 동작하는 상황이다.
- **Average Case**
    - 일반적인 입력에서 알고리즘이 평균적으로 얼마나 효율적으로 동작하는지를 나타낸다.
- **Worst Case**
    - 알고리즘이 가장 느리게 동작할 때를 의미하며, **실제로 우리가 가장 중요하게 고려하는 부분**이다.  

대부분의 경우, **최악의 상황에서의 성능이 가장 중요한 평가 기준**이 된다. 이는 알고리즘이 가장 불리한 상황에서도 얼마나 성능을 유지할 수 있는지가 시스템의 안정성과 신뢰성에 중요한 영향을 미치기 때문이다.

<br>
<br>

## 3. 점근적 접근 방법
____

**점근적 접근 방법**(asymptotic analysis)은 알고리즘의 성능을 입력 크기 `n`이 **매우 커질 때**(즉, 무한에 가까울 때) 어떻게 변하는지를 분석하는 방법이다. 이는 작은 입력 크기에서 발생하는 미세한 차이들을 무시하고, 하드웨어, 언어 등의 특정 요인에서 벗어나 추상화하는 과정을 통해 알고리즘이 **입력 크기가 커짐에 따라 성능이 어떻게 변화하는지**에 집중한다. 점근적 분석을 통해 상수 시간이나 작은 차이를 배제하고, 입력 크기와 관련된 **성능 경향**을 평가할 수 있다! 물론 `n`이 큰 경우에만 의미가 있는 한계가 있다.

<br>

#### T(n), g(n)

점근적 분석에서 알고리즘의 성능을 표현할 때는 두 함수 `T(n)`과 `g(n)`의 관계를 사용한다.

- **T(n)**: 입력 크기 `n`에 따라 알고리즘이 실행되는 **실제 시간** 또는 **실제 자원 사용량**을 나타내는 함수다. 이것은 알고리즘의 성능을 측정하는 실제 실행 시간이나 메모리 사용량일 수 있다.
  
- **g(n)**: 알고리즘의 성능을 설명하기 위해 사용하는 **비교 함수**이다. 일반적으로는 알고리즘의 시간 복잡도 또는 공간 복잡도를 설명하기 위한 기준 함수로 사용되며, 이는 다양한 수학적 함수(`n`, `n^2`. `log n` 등)로 표현 가능하다.

우리는 이제 시간 복잡도에 집중해서, 알고리즘의 효율성을 표현하는 몇가지 기법을 알아보고자 한다.

<br>

### 3-1. Big-O
<img src="https://i.imgur.com/vcvF4yg.png" width="700">

_`T(n)`, `g(n)`을 양의 정수 함수라고 하면, 우리는 `T(n)` 을 런타임이라고 생각할 수 있다._

### 2. T(n) = O(g(n))의 의미
T(n) = O(g(n))라는 표기는 **T(n)**이 **g(n)**보다 **느리게 증가하거나, 최소한 같게 증가한다**는 것을 의미한다. 즉, 입력 크기 `n`이 커질 때, 알고리즘의 실행 시간이 `g(n)` 이라는 기준에 비해 **더 느리게** 늘어나거나 **동일한 비율로** 늘어나는 경우를 나타낸다.

### 3. 공식 설명: T(n) = O(g(n))의 조건
T(n) = O(g(n))라고 하기 위해서는 다음 조건을 만족해야 한다:

- 특정 상수 **c**와 **n0**가 존재해야 한다.
  - 여기서 **c**는 T(n)이 g(n)보다 얼마나 느리게 증가할 수 있는지를 나타내는 상수이다.
  - **n0**는 특정 **최소 입력 크기**로, 이 크기부터 조건을 만족하는 것이다.

- \( n \geq n0 \)인 모든 \( n \)에 대해 **T(n) \leq c \cdot g(n)**을 만족해야 한다. 즉, \( n0 \) 이상의 모든 입력 크기에서 **T(n)**이 **g(n)**보다 더 빠르게 증가하지 않는 경우를 나타낸다.

### 4. 예시로 설명
예를 들어, \( T(n) = 3n + 2 \)라는 알고리즘이 있다고 하자. 이 알고리즘이 **O(n)**인지 판단하려면, **g(n) = n**일 때 \( T(n) \)이 \( n \)보다 느리게 증가하는지 살펴봐야 한다.

- 상수 **c**를 4로, **n0**를 1로 설정하면, 모든 \( n \geq 1 \)에 대해 \( 3n + 2 \leq 4n \)이 성립한다.
- 이 경우, \( T(n) \)은 \( n \)보다 느리게 증가하므로 \( T(n) = O(n) \)이다.

### 요약:
- **T(n)**은 알고리즘의 실행 시간을 나타내고, **g(n)**은 이를 비교하는 기준이다.
- **T(n) = O(g(n))**은 T(n)이 g(n)보다 느리게 또는 같은 속도로 증가하는 경우를 의미한다.
- 특정 상수 **c**와 **n0**가 존재하여, **T(n)**이 \( c \cdot g(n) \)보다 커지지 않으면 **T(n)**은 **O(g(n))**이라고 표현할 수 있다.
 
<br>

### 2-1. Big-O 표기법

### 2-3. >>>
T(n): 입력 크기 n에 따른 알고리즘의 실행 시간  
g(n): 비교를 위한 기준 함수  

우리가 **T(n)은 O(g(n))**이라고 할 때, 이 말의 의미는 n이 증가할수록 **g(n)**이 최소한 **T(n)**만큼은 빠르게 증가한다는 뜻이다. 다시 말해, **T(n)**은 **g(n)**보다 느리게 증가한다는 의미이다. 이때 중요한 것은 **T(n)**이 항상 **c \cdot g(n)** (c는 상수)을 넘지 않는다는 점이다. 이 의미는 결국, **T(n)**이 **g(n)**보다 더 빨리 커지지 않으며, 두 함수의 관계가 **g(n)**이 더 크거나 같게 유지된다는 뜻이다.

## 1. Big O 소개
____

> **Big O 표기법의 형태**
> - O(1): 상수 시간, 입력 크기에 상관없이 항상 같은 시간이 걸린다.  
> - O(n): 입력 크기에 비례해서 시간이 걸린다.  
> - O(log n): 입력 크기가 증가할 때 실행 시간이 천천히 증가한다. 예를 들어, 이진 탐색 알고리즘이 이에 해당된다.  
> - O(n^2): 이중 반복문처럼, 입력 크기가 증가하면 실행 시간이 제곱으로 증가한다.  

빅오표기법(Big-O)은 알고리즘이 실행되는 시간이나 메모리 사용량이 입력 크기(데이터의 양)에 따라 어떻게 변하는지 표현하는 방법이다. 주로 시간 복잡도와 공간 복잡도를 측정하는데 사용된다.  

**시간 복잡도** 는 입력 크기가 커질 때 알고리즘이 얼마나 오래 걸리는지를 나타낸다. 예를 들어, 배열에서 특정 값을 찾는 알고리즘이 있다고 하자. 이때, 배열에 있는 모든 요소를 하나씩 비교해야 한다면, 배열의 크기가 클수록 시간이 더 오래 걸리게 된다. 이런 경우 시간 복잡도는 O(n)이다. 여기서 n은 배열의 크기다. 즉, 입력 크기 n에 비례해서 시간이 증가한다는 의미다.  

**공간 복잡도**는 알고리즘이 실행될 때 필요한 메모리 공간이 입력 크기에 따라 어떻게 변하는지 나타낸다. 예를 들어, 배열을 복사하는 알고리즘은 원본 배열과 같은 크기의 메모리가 추가로 필요하므로 공간 복잡도는 O(n)이다. 하지만 단순히 변수 하나만 사용한다면 O(1)로, 입력 크기와 무관하게 일정한 메모리만 필요하다는 의미다.  

시간 복잡도와 공간 복잡도를 함께 고려하는 이유는 효율적인 알고리즘을 찾기 위해서다. 알고리즘이 빠르게 실행되더라도 너무 많은 메모리를 사용하면 비효율적일 수 있고, 메모리를 적게 사용하더라도 너무 느리면 실용적이지 않기 때문이다. 빅오표기법에서 중요한 것은 정확한 실행 시간이 아니라, 입력 크기에 따라 어떻게 변화하는지의 경향이다. 즉, O(n), O(n^2), O(log n) 같은 표현으로 _"시간이 얼마나 급격히 늘어나는가"_ 를 나타낸다.  

<br>
<br>

## 1. Big-O
T(n) : n에 따른 내가 만든 알고리즘의 실행시간
g(n) : 참조를 위한 함수

이때 우리가 T(n)은 O(g(n)) 이라고 할때 이것의 뜻은 곧
n이 증가할때, g(n)이 최소한 T(n) 만큼은 빠르게 증가하는 경우, 곧 T(n)이 g(n)보다는 느리게 증가한다. 말이 좀 어려운데 결국

## 5. Reference
____
- https://www.geeksforgeeks.org/insertion-sort-algorithm/

<br>
<br>



### 점근적 접근 방법

**점근적 접근 방법**(asymptotic analysis)은 알고리즘의 성능을 입력 크기 \( n \)이 **매우 커질 때**(즉, 무한에 가까울 때) 어떻게 변하는지를 분석하는 방법입니다. 이는 작은 입력 크기에서 발생하는 미세한 차이들을 무시하고, 알고리즘이 **입력 크기가 커짐에 따라 성능이 어떻게 변화하는지**에 집중하는 방식입니다. 점근적 분석을 통해 상수 시간이나 작은 차이를 배제하고, 입력 크기와 관련된 **성능 경향**을 평가할 수 있습니다.

점근적 접근 방법의 목적은 알고리즘이 큰 입력 데이터에서도 성능을 유지할 수 있는지 확인하고, 다양한 알고리즘 간의 효율성을 공정하게 비교하는 데 있습니다.

### T(n)과 g(n)의 관계

점근적 분석에서 알고리즘의 성능을 표현할 때는 두 함수 \( T(n) \)과 \( g(n) \)의 관계를 사용합니다.

- **T(n)**: 입력 크기 \( n \)에 따라 알고리즘이 실행되는 **실제 시간** 또는 **실제 자원 사용량**을 나타내는 함수입니다. 이것은 알고리즘의 성능을 측정하는 실제 실행 시간이나 메모리 사용량일 수 있습니다.
  
- **g(n)**: 알고리즘의 성능을 설명하기 위해 사용하는 **비교 함수**입니다. 일반적으로는 알고리즘의 시간 복잡도 또는 공간 복잡도를 설명하기 위한 기준 함수로 사용되며, 이는 다양한 수학적 함수(예: \( n \), \( n^2 \), \( \log n \))로 표현됩니다.

### Big-O, 세타(Θ), 오메가(Ω)의 관계에서 T(n)과 g(n)

1. **Big-O (O)**:  
   - \( T(n) = O(g(n)) \)는 **T(n)**이 입력 크기 \( n \)이 커질 때 **g(n)**의 상한선 내에 있음을 의미합니다.
   - 즉, **T(n)**이 **g(n)**보다 **느리게 증가**하거나 **동일한 속도로 증가**한다는 뜻입니다. 이는 최악의 경우 성능을 나타냅니다.

   \[
   T(n) \leq c \cdot g(n) \quad \text{(for sufficiently large \( n \))}
   \]
   여기서 \( c \)는 상수입니다.

2. **세타 (Θ)**:  
   - \( T(n) = \Theta(g(n)) \)는 **T(n)**이 **g(n)**과 정확히 같은 비율로 증가한다는 의미입니다.
   - 상한선과 하한선이 동일할 때, 즉 **T(n)**이 **g(n)**과 정확히 일치하는 속도로 증가하는 경우를 나타냅니다.

   \[
   c_1 \cdot g(n) \leq T(n) \leq c_2 \cdot g(n) \quad \text{(for sufficiently large \( n \))}
   \]
   여기서 \( c_1 \)과 \( c_2 \)는 상수입니다.

3. **오메가 (Ω)**:  
   - \( T(n) = \Omega(g(n)) \)는 **T(n)**이 입력 크기 \( n \)이 커질 때 **g(n)**의 하한선 내에 있음을 의미합니다.
   - 즉, **T(n)**이 **g(n)**보다 **빠르게 증가**하거나 **동일한 속도로 증가**한다는 뜻입니다. 이는 최선의 경우 성능을 나타냅니다.

   \[
   T(n) \geq c \cdot g(n) \quad \text{(for sufficiently large \( n \))}
   \]

### 요약

점근적 접근 방법은 알고리즘이 입력 크기 \( n \)이 커질 때 어떻게 성능이 변하는지를 분석하는 방법입니다. 이를 통해 우리는 알고리즘의 효율성을 Big-O, 세타(Θ), 오메가(Ω) 표기법을 사용하여 상한선, 하한선, 그리고 평균 성능에 대해 설명할 수 있습니다. 이때 **T(n)**과 **g(n)**의 관계를 이용해 알고리즘이 얼마나 빠르게 또는 느리게 성능이 변하는지를 나타냅니다.

- **Big-O**는 상한선으로 최악의 경우를 평가하고,
- **세타(Θ)**는 평균적인 성능을 나타내며,
- **오메가(Ω)**는 하한선으로 최선의 경우 성능을 평가합니다.

이를 통해 다양한 알고리즘의 성능을 공정하고 일관된 방식으로 비교할 수 있습니다.


빅세타 - https://i.imgur.com/WcqkFTe.png


- https://www.geeksforgeeks.org/types-of-asymptotic-notations-in-complexity-analysis-of-algorithms/