+++
title = '[알고리즘] 알고리즘 분석'
date = 2024-09-20
featured_image = "https://ih1.redbubble.net/image.1502642451.8092/st,small,507x507-pad,600x600,f8f8f8.jpg"
tags = ['algorithm']
+++

{{<series title="📚 /algorithm" series="algorithm">}}

<br>

## 1. 알고리즘 분석
____

어떤 알고리즘이 있을 때, 우리는 이 알고리즘을 어떻게 분석하는게 좋을까? 바로 **구현 / 정확성 / 효율성** 세 가지 핵심 요소를 통해 대상 알고리즘을 효과적으로 분석할 수 있다.

#### 구현
구현은 알고리즘이 어떻게 구조화되고 작성되었는지를 의미하며, 코드 레벨에서의 설계와 구현 방식에 대한 부분이다.  

#### 정확성
정확성은 알고리즘이 기대한 대로 정확하게 동작하는지 평가하는 요소로, 원하는 결과를 항상 도출해낼 수 있는지 증명하는 것이다.  

#### 효율성
효율성은 알고리즘이 얼마나 빠르게 동작하는지를 나타내며, 이는 시간과 자원의 소비를 분석하는 중요한 지표이다.  

<br>
<br>

## 2. 복잡도
____

복잡도는 알고리즘이 자원을 얼마나 효율적으로 사용하는지를 나타내는 개념이다. 자원에는 주로 **시간**과 **공간**(메모리)이 포함되며, 복잡도는 이 자원들이 입력 크기(n)에 따라 어떻게 변하는지를 수학적으로 표현한다!

#### 시간 복잡도(Time Complexity)
시간 복잡도는 **알고리즘이 실행되는 데 걸리는 시간**이 입력 크기 n에 따라 어떻게 변하는지를 나타낸다. 입력 크기가 커질수록 알고리즘이 얼마나 더 많은 시간을 소모하는지를 분석한다.

#### 공간 복잡도(Space Complexity)
공간 복잡도는 **알고리즘이 사용하는 메모리의 양**이 입력 크기 n에 따라 어떻게 변하는지를 나타낸다. 입력 크기가 커질수록 알고리즘이 얼마나 많은 메모리를 차지하는지를 분석한다.

#### 복잡도 고려
시간 복잡도와 공간 복잡도는 모두 중요한 요소지만, 현대 컴퓨터 기술의 발전으로 **공간 복잡도**는 메모리 용량의 증가로 인해 비교적 아주 살짝 덜 신경 쓸 수 있게 되었다. 내가 중점적으로 볼 것은 바로 **시간 복잡도**이다. 이는 여전히 알고리즘 효율성의 핵심 관심사이며, 시간 복잡도를 평가할 떄는 세 가지 주요 경우를 고려해야 한다:  

- **Best Case**
    - 알고리즘이 가장 빠르게 동작하는 상황이다.
- **Average Case**
    - 일반적인 입력에서 알고리즘이 평균적으로 얼마나 효율적으로 동작하는지를 나타낸다.
- **Worst Case**
    - 알고리즘이 가장 느리게 동작할 때를 의미하며, **실제로 우리가 가장 중요하게 고려하는 부분**이다.  

대부분의 경우, **최악의 상황에서의 성능이 가장 중요한 평가 기준**이 된다. 이는 알고리즘이 가장 불리한 상황에서도 얼마나 성능을 유지할 수 있는지가 시스템의 안정성과 신뢰성에 중요한 영향을 미치기 때문이다.

<br>
<br>

## 3. 점근적 접근 방법
____

**점근적 접근 방법**(asymptotic analysis)은 알고리즘의 성능이 입력 크기 `n`이 **매우 커질 때**(즉, 무한에 가까울 때) 어떻게 변하는지를 분석하는 방법이다. 이는 작은 입력 크기에서 발생하는 미세한 차이들을 무시하고, 하드웨어, 언어 등의 특정 요인에서 벗어나 추상화하는 과정을 통해 알고리즘이 **입력 크기가 커짐에 따라 성능이 어떻게 변화하는지**에 집중한다. 점근적 분석을 통해 상수 시간이나 작은 차이를 배제하고, 입력 크기와 관련된 **성능 경향**을 평가할 수 있다! 물론 `n`이 큰 경우에만 의미가 있는 한계가 있다.  

#### T(n)과 g(n)
앞으로 점근적 분석에서 알고리즘의 성능을 표현할 때는 두 함수 `T(n)`과 `g(n)`의 관계를 사용하겠다!

`T(n)` 은 입력 크기 `n`에 따라 알고리즘이 실행되는 **실제 시간** 또는 **실제 자원 사용량**을 나타내는 함수다. 이것은 알고리즘의 성능을 측정하는 실제 실행 시간이나 메모리 사용량일 수 있다.
  
`g(n)` 은 알고리즘의 성능을 설명하기 위해 사용하는 **비교 함수**이다. 일반적으로는 알고리즘의 시간 복잡도 또는 공간 복잡도를 설명하기 위한 기준 함수로 사용되며, 이는 다양한 수학적 함수(`n`, `n^2`. `log n` 등)로 표현 가능하다.

그렇다면 이제 시간 복잡도에 집중해서, **알고리즘의 효율성을 표현하는 몇가지 기법**을 알아보자.

<br>

### 3-1. Big-O

<img src="https://i.imgur.com/WcqkFTe.png" width="700">

_`T(n)`, `g(n)`을 양의 정수 함수라고 하면, 우리는 `T(n)` 을 런타임이라고 생각할 수 있다._

**Big-O 표기법** 은 알고리즘의 실행 시간이 입력 크기에 따라 어떻게 변하는지를 나타내는 방법이다. 쉽게 말해, **알고리즘의 효율성** 을 평가하는 도구이다. 이를 통해 우리는 입력 데이터가 많아질 때 알고리즘이 얼마나 더 느려지거나, 메모리를 얼마나 많이 사용하는지 알 수 있다. Big-O 표기법에서 중요한 것은 정확한 실행 시간을 측정하는 것이 아니라, 입력 크기가 커짐에 따라 시간이 어떻게 변하는지를 보는 것이다. 예를 들어, O(n), O(n²), O(log n) 같은 표현을 통해 시간이 얼마나 급격히 늘어나는지를 나타낸다.

#### T(n) = O(g(n))
Big-O 표기법은 결국 `T(n)` 이 `g(n)` 보다 느리게 증가하거나, 최소한 같게 증가한다는 것을 의미한다. 이때 `T(n) = O(g(n))`은 `T(n)` 이 `g(n)` 보다 더 느리게 증가하거나, 최소한 동일한 비율로 증가한다는 의미이다. 즉, 입력 크기 **n** 이 커질 때, `T(n)`이 `g(n)`보다 더 빨리 커지지 않는다는 뜻이다. `g(n)`은 `T(n)`의 상한선인 셈이다. Big-O는 최악의 경우에 `T(n)`이 `g(n)`보다 더 빨리 증가하지 않는다는 것을 명시한다!!!  

`T(n) = O(g(n))` 라고 하기 위해서는 다음 조건을 만족해야 한다:  
1. 상수 **c** 와 **n'**가 존재해야 한다. 여기서 **c** 는 `T(n)` 이 `g(n)` 보다 얼마나 느리게 증가할 수 있는지를 나타내는 상수이다. **n'** 는 특정 최소 입력 크기이다.
2. **모든 n ≥ n'** 에 대해 `T(n) ≤ c * g(n)` 을 만족해야 한다. 즉, **n'** 이상의 입력 크기에서는 `T(n)`이 `g(n)`보다 더 빠르게 증가하지 않아야 한다.

#### **Big-O 표기법의 형태**
- `O(1)` : 상수 시간이다. 입력 크기가 얼마든지 상관없이, 항상 같은 시간이 걸린다. 예를 들어, 배열에서 첫 번째 요소를 찾는 연산은 입력 크기와 관계없이 한 번에 끝난다.
- `O(n)` : 입력 크기만큼 시간이 걸린다. 예를 들어, 배열 안에서 특정 값을 찾기 위해 처음부터 끝까지 하나씩 비교하는 경우, 배열이 길어질수록 시간이 더 오래 걸린다.
- `O(log n)` : 입력 크기가 커질수록 실행 시간이 천천히 증가한다. 예를 들어, **이진 탐색** 알고리즘이 이에 해당한다. 데이터가 두 배로 늘어나도, 탐색 횟수는 조금밖에 늘어나지 않는다.
- `O(n²)`: 이중 반복문처럼 입력 크기가 커지면 실행 시간이 제곱으로 증가한다. 예를 들어, 배열 안의 모든 쌍을 비교하는 알고리즘이 이에 속한다.

#### Big-O 표기법 예시
예를 들어, `T(n) = 3n + 2`라는 알고리즘을 생각해보자. 이 알고리즘이 `O(n)` 인지 확인해보자. 우선, `g(n) = n` 으로 두고 `T(n) = 3n + 2` 가 **n** 보다 더 느리게 증가하는지 살펴보자.

- 상수 **c** 를 4로, `n'` 를 1로 설정하면, 모든 `n ≥ 1` 에서 `3n + 2 ≤ 4n` 이 성립한다.
- 따라서 `T(n)` 은 **n** 보다 느리게 증가하므로 `T(n) = O(n)` 이라고 할 수 있다.

결국, Big-O 표기법은 **알고리즘이 특정 기준보다 빠르게 증가하지 않는다** 는 것을 표현하는 방법이다.

<br>
<br>

### 3-2. Big-Omega (Ω)

<img src="https://i.imgur.com/vcvF4yg.png" width="700">

알고리즘의 성능을 평가할 때, **Big-Omega (Ω)** 표기법은 **하한선** 을 나타내는 표기법이다. 즉, **최소한 이 정도는 걸린다**는 것을 보장해 주는 도구이다. **Big-O**가 알고리즘의 실행 시간이 최대 얼마나 걸리는지를 나타낸다면, **Big-Omega**는 최소 얼마나 걸리는지를 표현한다. 이는 주로 알고리즘의 **최적의 경우** 성능을 평가할 때 사용된다.

#### T(n) = Ω(g(n))
`T(n)` 을 알고리즘의 시간 복잡도라고 할 때, `T(n) = Ω(g(n))` 는 `T(n)` 이 `g(n)` 보다 더 느리게 증가할 수 없다는 것을 의미한다. 즉, 입력 크기 **n** 이 커질 때, `T(n)` 이 `g(n)` 보다 더 작거나 같은 비율로 증가한다는 뜻이다. **Big-Omega** 표기법을 적용하기 위해서는 다음 조건을 만족해야 한다:

1. 상수 **c** 와 `n'` 가 존재해야 한다. 여기서 **c** 는 `T(n)` 이 `g(n)` 보다 얼마나 빠르게 증가할 수 있는지를 나타내는 상수이다. `n'` 는 특정 최소 입력 크기이다.
2. 모든 `n ≥ n'` 에 대해 `T(n) ≥ c * g(n)` 을 만족해야 한다. 즉, `T(n)` 은 `g(n)` 보다 더 느리게 증가할 수 없다는 뜻이다.

#### Big-Omega 표기법의 의미
**Big-Omega** 는 알고리즘의 **최소 성능** 을 보장하므로, **최적의 경우** 에 알고리즘이 얼마나 빠르게 동작할 수 있는지를 나타낸다. 이를 통해 우리는 최선의 상황에서 알고리즘이 얼마나 성능을 발휘할 수 있는지 알 수 있다.

#### Big-Omega 표기법 예시
예를 들어, 알고리즘의 시간 복잡도가 `T(n) = 3n + 2` 라고 하자. 이 알고리즘이 `Ω(n)` 에 속하는지 확인해보자. 여기서 `g(n) = n` 으로 두고 `T(n) ≥ c * g(n)` 을 만족하는 상수 **c** 와 `n'` 를 찾아보자.

- 상수 **c** 를 2로, `n'` 을 1로 설정하면, 모든 `n ≥ 1` 에서 `3n + 2 ≥ 2n` 이 성립한다.
- 따라서 `T(n) = Ω(n)` 이라고 할 수 있다.

이처럼, **Big-Omega** 는 `T(n)` 이 `g(n)` 보다 더 느리게 증가할 수 없다는 것을 나타내므로, 알고리즘의 최소 성능을 평가할 때 매우 유용하다. 즉, Big-Omega 표기법은 **알고리즘의 성능이 이 정도 이상으로는 반드시 나온다** 는 보장을 제공하는 중요한 도구이다.

<br>
<br>

### 3-2. Big-Theta (Θ)

<img src="https://i.imgur.com/mLFzEoO.png" width="700">

알고리즘의 성능을 나타내는 또 다른 중요한 표기법은 **Big-Theta (Θ)** 표기법이다. **Big-O** 표기법이 성능의 상한, **Big-Omega (Ω)** 하한을 나타낸다면, **Big-Theta** 는 알고리즘의 성능이 상한과 하한 모두에서 특정 함수와 같은 비율로 성장함을 나타낸다. 즉, 알고리즘이 입력 크기가 커짐에 따라 **정확하게** 어느 정도의 시간이 걸리는지를 나타내는 더 엄밀한 평가 기준이다.

#### T(n) = Θ(g(n))
`T(n)`을 알고리즘의 시간 복잡도라고 할 때, `T(n) = Θ(g(n))` 는 `T(n)`이 `g(n)`과 같은 비율로 증가한다는 의미이다. 즉, 입력 크기 **n** 이 커질수록 `T(n)`이 `g(n)`보다 더 빠르게 증가하지 않으면서 동시에 더 느리게 증가하지 않는다는 뜻이다. **Big-Theta** 표기법을 적용하기 위해서는 다음 두 가지 조건을 만족해야 한다:

1. 상수 **c1, c2** 와 `n'` 가 존재해야 한다. 여기서 **c1** 과 **c2** 는 `T(n)`이 `g(n)`보다 얼마나 빠르게 또는 느리게 증가할 수 있는지를 나타내는 상수이다. `n'` 는 특정 최소 입력 크기이다.
2. 모든 `n ≥ n'` 에 대해 `c1 * g(n) ≤ T(n) ≤ c2 * g(n)` 을 만족해야 한다. 즉, 입력 크기 `n'` 이상의 모든 입력에서 `T(n)`은 `g(n)`과 동일한 비율로 증가해야 한다.

#### **Big-Theta 표기법의 의미**
**Big-Theta** 는 상한선과 하한선을 모두 포함하므로, 알고리즘의 실제 성능을 **정확하게 평가** 하는 데 사용된다. `T(n)`이 `g(n)`과 비슷한 비율로 성장한다는 것을 보장하므로, 성능을 평가할 때 Big-Theta는 더 엄격하고 명확한 기준을 제공한다.

#### Big-Theta 표기법 예시
예를 들어, 알고리즘의 시간 복잡도가 `T(n) = 3n + 2` 라면, 이 알고리즘이 `Θ(n)` 에 속하는지 확인해보자. 여기서 **g(n) = n**으로 가정하고, 두 상수 **c1**과 **c2**를 찾아보자.

- **c1**을 2로, **c2**를 4로 설정하고 **n'**을 1로 설정하면, 모든 **n ≥ 1**에서 **2n ≤ 3n + 2 ≤ 4n**이 성립한다.
- 따라서 **T(n) = Θ(n)**이라고 할 수 있다.

이처럼, Big-Theta는 알고리즘이 `g(n)`과 같은 속도로 증가한다는 것을 나타낸다. `T(n)`이 `g(n)`과 정확히 같은 비율로 증가할 때 **Big-Theta** 표기법을 사용한다.

## 3-4. Example

### Example01

> prove 



빅세타 - https://i.imgur.com/WcqkFTe.png


- https://www.geeksforgeeks.org/types-of-asymptotic-notations-in-complexity-analysis-of-algorithms/