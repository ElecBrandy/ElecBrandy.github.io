## 1. Big-O
____
<img src="https://i.imgur.com/vcvF4yg.png" width="700">

_`T(n)`, `g(n)`을 양의 정수 함수라고 하면, 우리는 `T(n)` 을 런타임이라고 생각할 수 있다._

**Big-O 표기법**은 알고리즘의 실행 시간이 입력 크기에 따라 어떻게 변하는지를 나타내는 방법이다. 쉽게 말해, **알고리즘의 효율성**을 평가하는 도구이다. 이를 통해 우리는 입력 데이터가 많아질 때 알고리즘이 얼마나 더 느려지거나, 메모리를 얼마나 많이 사용하는지 알 수 있다.

#### **Big-O 표기법의 형태**
- **O(1)**: 상수 시간이다. 입력 크기가 얼마든지 상관없이, 항상 같은 시간이 걸린다. 예를 들어, 배열에서 첫 번째 요소를 찾는 연산은 입력 크기와 관계없이 한 번에 끝난다.
- **O(n)**: 입력 크기만큼 시간이 걸린다. 예를 들어, 배열 안에서 특정 값을 찾기 위해 처음부터 끝까지 하나씩 비교하는 경우, 배열이 길어질수록 시간이 더 오래 걸린다.
- **O(log n)**: 입력 크기가 커질수록 실행 시간이 천천히 증가한다. 예를 들어, **이진 탐색** 알고리즘이 이에 해당한다. 데이터가 두 배로 늘어나도, 탐색 횟수는 조금밖에 늘어나지 않는다.
- **O(n²)**: 이중 반복문처럼 입력 크기가 커지면 실행 시간이 제곱으로 증가한다. 예를 들어, 배열 안의 모든 쌍을 비교하는 알고리즘이 이에 속한다.

#### **시간 복잡도와 공간 복잡도**
- **시간 복잡도**는 입력 크기가 커질 때 알고리즘이 얼마나 오래 걸리는지를 나타낸다. 예를 들어, 배열 안의 모든 값을 하나씩 비교하는 알고리즘은 입력 크기에 비례해서 시간이 늘어나므로 O(n)이다.
- **공간 복잡도**는 알고리즘이 실행되면서 얼마나 많은 메모리가 필요한지를 뜻한다. 배열을 복사하는 경우, 원본 배열 크기만큼의 메모리를 더 사용해야 하므로 공간 복잡도는 O(n)이다. 하지만 단순히 변수를 하나만 추가하는 경우라면 O(1)이다.

빅오 표기법에서 중요한 것은 정확한 실행 시간을 측정하는 것이 아니라, 입력 크기가 커짐에 따라 시간이 어떻게 변하는지를 보는 것이다. 예를 들어, O(n), O(n²), O(log n) 같은 표현을 통해 시간이 얼마나 급격히 늘어나는지를 나타낸다.

<br>

## 2. Big-O의 정의
____

Big-O 표기법은 **T(n)**이 **g(n)**보다 느리게 증가하거나, 최소한 같게 증가한다는 것을 의미한다. 여기서:

- **T(n)**: 입력 크기 **n**에 따른 알고리즘의 실행 시간이다.
- **g(n)**: 비교를 위한 기준 함수이다.

### **T(n) = O(g(n))의 의미**
T(n) = O(g(n))은 **T(n)**이 **g(n)**보다 더 느리게 증가하거나, 최소한 동일한 비율로 증가한다는 의미이다. 즉, 입력 크기 **n**이 커질 때, **T(n)**이 **g(n)**보다 더 빨리 커지지 않는다는 뜻이다.

### **T(n) = O(g(n)) 조건**
T(n) = O(g(n))라고 하기 위해서는 다음 조건을 만족해야 한다:

1. **상수 c**와 **n0**가 존재해야 한다. 여기서 **c**는 **T(n)**이 **g(n)**보다 얼마나 느리게 증가할 수 있는지를 나타내는 상수이다. **n0**는 특정 최소 입력 크기이다.
2. **모든 n ≥ n0**에 대해 T(n) ≤ c * g(n)**을 만족해야 한다. 즉, **n0** 이상의 입력 크기에서는 **T(n)**이 **g(n)**보다 더 빠르게 증가하지 않아야 한다.

<br>

## 3. 예시로 보는 Big-O
____

예를 들어, **T(n) = 3n + 2**라는 알고리즘을 생각해보자. 이 알고리즘이 **O(n)**인지 확인해보자.

우선, **g(n) = n**으로 두고 **T(n) = 3n + 2**가 **n**보다 더 느리게 증가하는지 살펴보자.

- 상수 **c**를 4로, **n0**를 1로 설정하면, 모든 **n ≥ 1**에서 **3n + 2 ≤ 4n**이 성립한다.
- 따라서 **T(n)**은 **n**보다 느리게 증가하므로 **T(n) = O(n)**이라고 할 수 있다.

결국, Big-O 표기법은 **알고리즘이 특정 기준보다 빠르게 증가하지 않는다**는 것을 표현하는 방법이다.




_____

# 점근적 분석: Big-O, Big-Ω, Big-Θ 표기법 이해하기

<img src="https://i.imgur.com/vcvF4yg.png" width="700">

알고리즘의 효율성을 평가할 때, 우리는 **점근적 분석**이라는 방법을 사용한다. 이는 입력 크기 \( n \)이 매우 커질 때, 알고리즘의 실행 시간이나 공간 복잡도가 어떻게 변하는지를 분석하는 것이다. 이 글에서는 **Big-O**, **Big-Ω**, **Big-Θ** 표기법을 통해 알고리즘의 복잡도를 표현하는 방법을 알아보고, 각 표기법에서 **\( T(n) \)**과 **\( g(n) \)**의 관계를 살펴보겠다.

<br>

## 1. Big-O 표기법

### 1-1. 정의

**Big-O 표기법**은 알고리즘의 **상한선**을 나타낸다. 즉, 최악의 경우 알고리즘이 얼마나 오래 걸릴지를 표현한다.

- \( T(n) = O(g(n)) \)이라 하면, **\( n \geq n_0 \)**인 모든 \( n \)에 대해
  \[ T(n) \leq c \cdot g(n) \]
  를 만족하는 상수 **\( c > 0 \)**와 **\( n_0 \geq 0 \)**가 존재한다.

### 1-2. \( T(n) \)과 \( g(n) \)의 관계

- **\( T(n) \)**: 입력 크기 \( n \)에 따른 알고리즘의 실제 실행 시간 또는 복잡도
- **\( g(n) \)**: 비교를 위한 기준 함수
- **Big-O**에서는 **\( T(n) \)**이 \( n \)이 커질수록 최대 \( g(n) \)의 속도로 증가함을 의미한다.

### 1-3. 예시

예를 들어, \( T(n) = 3n + 2 \)인 알고리즘이 있다고 하자.

- \( g(n) = n \)으로 설정하면,
- 상수 \( c = 4 \), \( n_0 = 1 \)로 두었을 때, 모든 \( n \geq 1 \)에 대해
  \[ 3n + 2 \leq 4n \]
  이 성립한다.
- 따라서 \( T(n) = O(n) \)이다.

<br>

## 2. Big-Ω 표기법

### 2-1. 정의

**Big-Ω 표기법**은 알고리즘의 **하한선**을 나타낸다. 즉, 최선의 경우에도 알고리즘이 최소 얼마나 오래 걸리는지를 표현한다.

- \( T(n) = \Omega(g(n)) \)이라 하면, **\( n \geq n_0 \)**인 모든 \( n \)에 대해
  \[ T(n) \geq c \cdot g(n) \]
  를 만족하는 상수 **\( c > 0 \)**와 **\( n_0 \geq 0 \)**가 존재한다.

### 2-2. \( T(n) \)과 \( g(n) \)의 관계

- **\( T(n) \)**이 \( n \)이 커질수록 최소한 \( g(n) \)의 속도로 증가함을 의미한다.
- 이는 알고리즘이 아무리 빨라도 \( g(n) \) 이상의 시간은 필요하다는 것을 나타낸다.

### 2-3. 예시

\( T(n) = 2n - 1 \)인 알고리즘을 생각해보자.

- \( g(n) = n \)으로 설정하면,
- 상수 \( c = 1 \), \( n_0 = 1 \)로 두었을 때, 모든 \( n \geq 1 \)에 대해
  \[ 2n - 1 \geq n \]
  이 성립한다.
- 따라서 \( T(n) = \Omega(n) \)이다.

<br>

## 3. Big-Θ 표기법

### 3-1. 정의

**Big-Θ 표기법**은 알고리즘의 **상한선과 하한선이 동일**함을 나타낸다. 즉, 알고리즘의 실행 시간이 \( g(n) \)에 정확히 비례한다는 것을 의미한다.

- \( T(n) = \Theta(g(n)) \)이라 하면, **\( n \geq n_0 \)**인 모든 \( n \)에 대해
  \[ c_1 \cdot g(n) \leq T(n) \leq c_2 \cdot g(n) \]
  를 만족하는 상수 **\( c_1, c_2 > 0 \)**와 **\( n_0 \geq 0 \)**가 존재한다.

### 3-2. \( T(n) \)과 \( g(n) \)의 관계

- **\( T(n) \)**이 \( n \)이 커질수록 \( g(n) \)과 정확히 같은 속도로 증가한다.
- 이는 알고리즘의 평균적인 경우를 표현하는 데 사용된다.

### 3-3. 예시

\( T(n) = 5n + 3 \)인 알고리즘을 보자.

- \( g(n) = n \)으로 설정하면,
- 상수 \( c_1 = 5 \), \( c_2 = 6 \), \( n_0 = 1 \)로 두었을 때, 모든 \( n \geq 1 \)에 대해
  \[ 5n \leq 5n + 3 \leq 6n \]
  이 성립한다.
- 따라서 \( T(n) = \Theta(n) \)이다.

<br>

## 4. 세 표기법의 비교

| 표기법     | 의미                              | 수식 관계                                              |
|------------|-----------------------------------|-------------------------------------------------------|
| **Big-O**  | 상한선 (최악의 경우)              | \( T(n) \leq c \cdot g(n) \)                          |
| **Big-Ω**  | 하한선 (최선의 경우)              | \( T(n) \geq c \cdot g(n) \)                          |
| **Big-Θ**  | 상한선과 하한선이 동일 (평균 경우) | \( c_1 \cdot g(n) \leq T(n) \leq c_2 \cdot g(n) \)    |

- **Big-O**는 알고리즘이 **최대 어느 정도로 느릴 수 있는지**를 나타낸다.
- **Big-Ω**는 알고리즘이 **최소 어느 정도의 시간은 필요**한지를 나타낸다.
- **Big-Θ**는 알고리즘의 **실행 시간이 정확히 이 정도로 증가**한다는 것을 의미한다.

<br>

## 5. 예시를 통한 이해

### 예시 1: 버블 정렬

- **시간 복잡도**: \( T(n) = O(n^2) \)
- **설명**: 최악의 경우 모든 요소를 비교해야 하므로 \( n^2 \)만큼 시간이 걸린다.

### 예시 2: 이진 탐색

- **시간 복잡도**: \( T(n) = O(\log n) \), \( T(n) = \Omega(1) \)
- **설명**: 최악의 경우 \( \log n \)번의 비교가 필요하지만, 최선의 경우 첫 번째 비교에서 찾을 수 있다.

### 예시 3: 합병 정렬

- **시간 복잡도**: \( T(n) = \Theta(n \log n) \)
- **설명**: 모든 경우에 걸쳐 \( n \log n \)의 시간이 걸린다.

<br>

## 6. 결론

점근적 분석은 알고리즘의 효율성을 평가하는 데 필수적인 도구이다. **Big-O**, **Big-Ω**, **Big-Θ** 표기법을 통해 우리는 알고리즘이 **최악의 경우**, **최선의 경우**, 그리고 **평균적인 경우**에 어떻게 동작하는지를 수학적으로 표현할 수 있다. 이를 통해 더 효율적인 알고리즘을 설계하고, 기존 알고리즘의 성능을 객관적으로 비교할 수 있다.

<br>

---

**참고**: 알고리즘의 실제 성능은 입력 데이터의 특성이나 환경에 따라 달라질 수 있다. 따라서 점근적 분석은 이론적인 근사치이며, 실제 성능 평가와 함께 고려되어야 한다.












빅세타 - https://i.imgur.com/WcqkFTe.png


- https://www.geeksforgeeks.org/types-of-asymptotic-notations-in-complexity-analysis-of-algorithms/