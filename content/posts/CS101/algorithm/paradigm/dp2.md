+++
title = '[42cursus] ft_printf'
date = 2023-11-15
featured_image = "http://t1.daumcdn.net/cfile/146B7E10B091A05214"
tags = ['c', '42cursus']
draft = true
+++

그래서 등장한게
## 벨만포드
- 다익스트라보다 느림
- 그런데 음수 가중치 엣지로 다둘 수 있음
- 가중치를 실시간 반영 가능
- 중요 ::: 음수 순환 서클이 있으면 안됨!!! 계속 코스트가 음수 무한으로 줄어들테니까

그래서 뭐가 차이점이면 모든 루프 마다 가장 작은것만 업데이트 해주는게 아니라 모든 노드 루트 업데이트를 다 해주는게 특징

수도코드를 보자.  
``` python
d[v] = INF for all v in V
d[s] = 0
for i=-,...,n-2:
    for u in V: # 여기가 차이점
        for v in u.neighbors:
            d[v] <- min(d[v], d[u] + edgeWeight(u,v))
```

``` c++
class Gragh {
    int V;
    list<pair<int, int>> *adj;
public:
    Graph(int V);
    void shorttestPath(int s)
}

void Graph::shorttestPath(int s) {
    vector<int> dist(V, INF);
    dist[src] = 0;

    for (int j = 0; j < V -1; j++) {
        for (int u = 0; u < V; u++) {
            list< pair<int, int>>::iterator i;
            for (i = adj[u].begin(); i != adj[u].end(); ++i) {
                int v = (*i).first;
                int weight = (*i).second;

                if (dist[u] != INF && dist[v] > dist[u] + weight)
                    dist[v] = dist[u] + weight;
            }
        }
    }

    for (int j = 0; j < V -1; j++) {
        for (int u = 0; u < V; u++) {
            list< pair<int, int>>::iterator i;
            for (i = adj[u].begin(); i != adj[u].end(); ++i) {
                int v = (*i).first;
                int weight = (*i).second;

                if (dist[u] != INF && dist[v] > dist[u] + weight)
                    printf("negative cycle\n");
                    return ;
            }
        }
    }
}
```

시간복잡도는 O(nm)


### 최종정리
다음은 이미지의 내용을 한국어로 깔끔하게 정리한 것입니다:

### 최단 경로 알고리즘 요약

#### 1. **BFS (너비 우선 탐색)**
- **장점**:
  - 시간 복잡도: O(n + m)
- **단점**:
  - 가중치가 없는 그래프에서만 사용 가능

---

#### 2. **다익스트라 알고리즘**
- **장점**:
  - 가중치가 있는 그래프에 사용 가능
  - 효율적으로 구현하면 시간 복잡도가 O(n \log(n) + m)
- **단점**:
  - 음수 간선(negative edge)을 처리할 수 없음
  - 매우 "중앙 집중적" 구조: 모든 정점 상태를 추적해야 함

---

#### 3. **벨만-포드 알고리즘**
- **장점**:
  - 음수 간선을 포함한 가중치 그래프에서도 사용 가능
  - 분산 방식으로 수행 가능: 각 정점이 이웃 정점의 정보만 사용
- **단점**:
  - 시간 복잡도: O(nm)


그럼 이제 벨만포드를 증명해보자.
1. 작동하는가?
2. 빠른가?
다음은 업로드한 **PPT 내용**을 기반으로 **벨만-포드 알고리즘의 증명**을 상세히 재구성한 것입니다. 요청하신 내용을 PPT의 구조를 최대한 반영해 깔끔히 정리했습니다.

---

### **벨만-포드 알고리즘의 귀납적 증명 (Proof by Induction)**

#### 1. **귀납 가설 (Inductive Hypothesis)**  
- i번째 반복 후, 모든 정점 v에 대해 d^{(i)}[v]는 시작점 s에서 v까지 **최대 i개의 간선**을 사용한 최단 경로 비용과 같다.

---

#### 2. **기저 사례 (Base Case)**  
- **반복 i = 0:**
  - d^{(0)}[s] = 0: 시작점의 거리는 0.
  - d^{(0)}[v] = \infty: 나머지 정점은 초기 상태에서 도달 불가능.
  - 이 때, **최대 0개의 간선을 사용한 최단 경로 비용**과 d^{(0)}[v]가 동일함.  
    **✅ 가설 성립!**

---

#### 3. **귀납 단계 (Inductive Step)**  
- i번째 반복 후 가설이 참이라고 가정. i+1번째 반복에서 확인:  
  - **그래프 상의 최단 경로 예시**:
    - s에서 v까지의 최단 경로는 i+1개 이하의 간선을 사용.
    - 이 경로에서 v 바로 직전의 정점을 u라고 가정.
    - 이 때, u까지의 최단 경로는 i개의 간선을 사용. (귀납 가설에 의해 확인됨)

  - **갱신 과정**:
    1. u에서 v로 가는 간선 w(u, v)를 추가.
    2. d^{(i+1)}[v] = \min(d^{(i+1)}[v], d^{(i)}[u] + w(u, v)).  
       (이 과정에서 최단 경로를 더 짧게 만들 수 있다면 갱신함)

  - **결론**:
    - d^{(i+1)}[v] \leq 최대 i+1개의 간선을 사용한 최단 경로 비용.

---

#### 4. **결론 (Conclusion)**  
- n-1번째 반복 후:
  - 모든 정점 v에 대해 d[v]는 시작점 s에서 v까지의 **최단 경로 비용**과 동일.
  - 단, **음수 가중치는 허용되지만 음수 사이클은 없을 경우**에만 정확히 동작.

---

### **PPT 내용의 주요 반영 포인트**  
1. **귀납 가설**: "최단 경로가 i개 이하의 간선을 사용할 때 성립한다"는 논리를 명확히 포함.
2. **기저 사례**: i = 0에서 초기 상태와 최단 경로 일치 여부 설명.
3. **귀납 단계**:
   - PPT의 "Thought Experiment"에 따라 u에서 v로의 최단 경로를 간선 추가로 갱신.
   - 갱신 조건: d^{(i+1)}[v] \leq d^{(i)}[u] + w(u, v)를 기반으로 논리 설명.
4. **결론**: PPT의 "d[v] = 최단 경로 비용 (단, 사이클 없음)"을 명시적으로 반영.

이 내용은 PPT와 매우 유사하게 귀납법에 기반한 논리를 충실히 재구성한 것입니다. 추가로 수정할 점이 있다면 말씀해주세요!

벨만포드는 동적 프로그래밍의 일부이다.
동적 프로그래밍의 예시를 하나 더 알아보자.

## 피보나치
보통을 아래처럼 짠다.
``` python
def function(n):
    if n == 0 or n == 1
        return 1
    return function(n-1) + function(n-2)
```
비슷하게 반복되는 로직을 계속 계산하다보니 효율적이지 않음.
그래서 반복되는 로직에 대한 결과를 좀 기록해놨다가 다시 참조하는게 dp라고 봐도딤

``` python
def function2(n):
    f = [1, 1, None, Nonem .., None] #f has length n
    for i = 2, ... , n:
        f[i] = f[i-1] + f[i-2]
    return f[n]; 
```

``` c++
#include <iostream>
#include <vector>

int fibonacci(int n) {
    // f 배열을 길이 n+1로 초기화 (0부터 시작하므로 n+1)
    std::vector<int> f(n + 1, 0); 
    f[0] = 1; // 첫 번째 피보나치 수
    f[1] = 1; // 두 번째 피보나치 수

    // 피보나치 계산
    for (int i = 2; i <= n; ++i) {
        f[i] = f[i - 1] + f[i - 2];
    }

    return f[n]; // n번째 피보나치 수 반환
}
```

dp는 부분문제의 해를 결합해 문제의 해를찾는 알고리즘. 이때 겹치는 부분문제의 비효율을 효과적으로 해결하는 방법을 초함. -> 분할정복법도 부분문제의 해를 결합해 해를 찾지만 머지소트만 봐도 알다시피 분할정복은 문제를 **겹치지 않는 부분 문제**로 분할함

어떻게 설계하느냐.
 일단 1. 최적 구분 구조 Optimal sub-structure 를 가져야함
 그리고 2. 반복적인 부분문제 Overlapping sub-problems을 가져야함.
 그리고 3. 2번에서 제시한 반복적인 부분문제를 해결할 방법도 가져야함. 보통 단계별 데이터를 저장해둠.

dp에는 크게 탑다운 방식과 바텀업 방식이 있다.

1. 바텀업 : main problem과 먼 subproblem부터 답을 구해서 기록해 나감.
- 피보나치 : 제일 작은 case를 찾고 늘려나감
- 벨만포드 : edge를 최대 n개 거쳐갈수있는 shortest span 찾기. 여기서 n의 범위가 점점 증가

2. 탑다운 : problem과 가까운 subproblem부터 "재귀로" 해결한다.
이때 재귀 돌리면 너무 비슷한 로직이 불필요하게 반복되는데 이것을 타개하기 위해 메모한다.->한번풀었던 문제는 두번다시풀지않는것이규ㅠ칙

- 피보나치 (탑다운dp버전)
``` python
def fibonacci(n):
    if F[n] != None:
        return F[n]
    else
        F[n] = fibonacci(n-1) + fibonacci(n-2)
    return F[n]
```

## 플로이드 워셜
dp의 또 하나의 일종
모든 starting vertice를  대상으로 shortest path를 찾는다.
그럼 2가지 방법이 있겠지?
1. 모든 노드를 대상으로 각각 벨만포드를 돌리고 기억하기 -> 이러면 O(n *nm) 정도임.
그러면 m이 n^2만큼 커지면 최악에 O(n^4)일듯.
그렇다면 조금 dp 스럽게 optimal substructure을 찾아보자.

k를 하나 더. ㅡㄹ렸을대는 고려해서 shortest path 찾기 반복

플로이드 워셜 알고리즘의 기본 개념을 초보자에게 설명하겠습니다. 슬라이드 내용을 기반으로 단계별로 정리해보겠습니다.

---

### **플로이드 워셜 알고리즘의 개념**
- **목표:** 그래프에서 모든 정점 쌍 간의 최단 경로를 찾는 알고리즘입니다.
- **아이디어:** 점진적으로 경유지를 추가하며 최단 경로를 갱신합니다.

---

### **단계별 설명**

#### **1. 정의**
- D^{(k)}[u, v]는 정점 u에서 v까지의 최단 경로 비용으로, **경로에 포함될 수 있는 내부 정점이 {1, ..., k}에 한정**됩니다.
- 알고리즘의 핵심은 D^{(k)}를 D^{(k-1)}을 기반으로 갱신하는 것입니다.

---

#### **2. 두 가지 경우의 분석**
D^{(k)}[u, v]를 계산하는 데 k번 정점이 필요한지 여부에 따라 두 가지 경우로 나뉩니다.

##### **Case 1: k번 정점이 필요 없는 경우**
- u에서 v까지의 경로는 이미 최단 경로입니다. 즉, 경로가 k번 정점을 거치지 않아도 됩니다.
- 이 경우, 최단 경로는 기존 값과 동일합니다:
  \[
  D^{(k)}[u, v] = D^{(k-1)}[u, v]
  \]
- **예시:** 슬라이드에서는 k를 거치지 않아도 u \to v가 최단 경로임을 보여줍니다.

---

##### **Case 2: k번 정점이 필요한 경우**
- u \to k \to v로 경유지를 갱신하는 경우입니다.
- 이 경우 최단 경로 비용은 다음과 같습니다:
  \[
  D^{(k)}[u, v] = \min(D^{(k-1)}[u, v], D^{(k-1)}[u, k] + D^{(k-1)}[k, v])
  \]
- 즉, 이전 상태에서 **u \to v**와 **u \to k \to v** 중 더 작은 값을 선택합니다.
- **예시:** 슬라이드에서는 u \to k와 k \to v를 연결해 더 짧은 경로를 만드는 모습을 보여줍니다.

---

#### **3. 반복적인 갱신**
- k를 1부터 n까지 늘려가며 모든 정점 쌍의 최단 경로를 갱신합니다.
- 초기값은 D^{(0)}, 즉 경유지를 사용하지 않은 상태에서 직접 연결된 비용으로 시작합니다.


``` c++
void floydWarshall(int dist[][V]) {
    int i, j, k;

    for (k = 0; k < V; k++) {
        for (i = 0; i < V; i++) {
            for (j = 0; j < V; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }
    // 음수 판별 추가 필요
}
```