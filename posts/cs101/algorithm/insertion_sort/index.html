<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<link rel="stylesheet" href="/css/reset.css">
<title>[알고리즘] 선택 정렬 | home</title>

      <link rel="stylesheet" href="/css/main.min.0ce01787cd4bc0759f98b56377f962e02878ce8fb515cc49af5cb83db6a3edfc.css" integrity="sha256-DOAXh81LwHWfmLVjd/li4Ch4zo&#43;1FcxJr1y4Pbaj7fw=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/min700.min.c55885430d625813d1a6770ef6712b8534781fdd318699edd1bb9c6f62907507.css" integrity="sha256-xViFQw1iWBPRpncO9nErhTR4H90xhpnt0bucb2KQdQc=" crossorigin="anonymous">



<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding:wght@400;700&display=swap" rel="stylesheet">



<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZL1NP5K5CJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZL1NP5K5CJ');
</script>


</head>
<body>
    <header class="main-header">
	<nav>
	  <li><a href="/">/home</a></li>
	  <li><a href="/tags">/tags</a></li>
	  <li><a href="/about">/about</a></li>
	  <li id="theme-toggle" style="cursor: pointer;">/todark</li>
	</nav>
  </header>
  
  <script>
	document.addEventListener('DOMContentLoaded', function() {
	  const themeToggle = document.getElementById('theme-toggle');
	  
	  
	  let currentTheme = localStorage.getItem('theme') || 'light';
  
	  
	  document.body.setAttribute('data-theme', currentTheme);
	  themeToggle.textContent = currentTheme === 'dark' ? '/tolight' : '/todark';
  
	  
	  function toggleTheme() {
		
		const newTheme = document.body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
  
		
		document.body.setAttribute('data-theme', newTheme);
  
		
		localStorage.setItem('theme', newTheme);
  
		
		themeToggle.textContent = newTheme === 'dark' ? '/tolight' : '/todark';
	  }
  
	  
	  themeToggle.addEventListener('click', toggleTheme);
	});
  </script>
  
    
  <aside class="toc">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-insertion-sort">1. Insertion sort</a></li>
    <li><a href="#2-구현-분석">2. 구현 분석</a>
      <ul>
        <li><a href="#2-1-루프-1">2-1. 루프 [1]</a></li>
        <li><a href="#2-2-루프-2">2-2. 루프 [2]</a></li>
      </ul>
    </li>
    <li><a href="#3-정확성-분석">3. 정확성 분석</a>
      <ul>
        <li><a href="#3-1-명제-설정">3-1. 명제 설정</a></li>
        <li><a href="#3-2-귀납적-증명의-구성-요소">3-2. 귀납적 증명의 구성 요소</a></li>
        <li><a href="#3-3-귀납적-증명">3-3. 귀납적 증명</a></li>
      </ul>
    </li>
    <li><a href="#4-효율성-분석">4. 효율성 분석</a></li>
    <li><a href="#5-reference">5. Reference</a></li>
  </ul>
</nav>
  </aside>
  <div class="featured-container">
    
      <div class="featured-image">
        <img src="https://upload.wikimedia.org/wikipedia/commons/e/ef/Sorting_shaker_sort_anim.gif" alt="Featured Image for [알고리즘] 선택 정렬">
      </div>
    
    <div class="overlay-text">
      <small>2024.09.09</small>
      <div class="singleTitle">[알고리즘] 선택 정렬</div>
    </div>
  </div>
  <div class="series">
  <details>
    <summary>📚 /algorithm</summary>
    <ul>
      
      
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/list/">list</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/stack/">stack</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/queue/">queue</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/heap/">heap</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/tree/">tree</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/graph/">graph</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/">hashTable</a></li>
      
    </ul>
  </details>
</div>

<br>
<blockquote>
<p><strong>구현</strong> : 해당 알고리즘은 어떻게 구현 되었나?</p>
<p><strong>정확성</strong> : 해당 알고리즘이 실제로 동작하는가?</p>
<p><strong>효율성</strong> : 해당 알고리즘이 빠른가?</p>
</blockquote>
<br>
<h2 id="1-insertion-sort">1. Insertion sort</h2>
<hr>
<img src="https://i.imgur.com/sW8twRl.png" width="700">
<p><code>Insertion sort</code>(삽입 정렬)는 말 그대로 정렬된 배열에 새로운 요소를 삽입하여 정렬을 확장해 나가는 알고리즘이다. 배열을 처리할 때, 전체 배열 중 왼쪽 부분은 이미 정렬된 상태이고, 오른쪽 부분은 아직 정렬되지 않은 상태로 남아 있다. 삽입 정렬은 이 정렬되지 않은 부분에서 하나씩 요소를 가져와서, 정렬된 배열의 어느 위치에 삽입해야 할지 결정하는 방식으로 동작한다.</p>
<p>이 알고리즘에서 두 개의 주요 루프가 존재한다. <strong>첫 번째 루프</strong> 는 정렬되지 않은 부분에서 인덱스를 하나씩 선택하는 루프로, 인덱스 1부터 배열의 끝(n-1)까지 반복된다. <strong>두 번째 루프</strong> 는 선택된 인덱스를 정렬된 부분에서 어디에 삽입할지를 결정하는 과정이다. 이 과정에서 선택된 값과 정렬된 배열의 값들을 비교하여 적절한 위치를 찾아 삽입하게 된다.</p>
<br>
<br>
<h2 id="2-구현-분석">2. 구현 분석</h2>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insertionSort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr, <span style="color:#66d9ef">int</span> N) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 루프_1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> key <span style="color:#f92672">=</span> arr[i];
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> arr[j] <span style="color:#f92672">&gt;</span> key) { <span style="color:#75715e">// 루프_2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			arr[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> arr[j];
</span></span><span style="display:flex;"><span>			j<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		arr[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> key;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><br>
<h3 id="2-1-루프-1">2-1. 루프 [1]</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>)
</span></span></code></pre></div><p>이 부분은 정렬되지 않은 배열의 인덱스를 하나씩 선택하는 루프이다. 정렬되지 않은 부분에서 하나씩 가져와서 처리할 것이기 때문에, 이 루프는 결국 인덱스 <code>1</code> 부터 <code>N - 1</code> 까지 모든 인덱스를 순차적으로 처리하게 된다. 선택한 인덱스 <code>int key</code> 에 저장한다. 여기서 선택된 <code>int key</code>를 가지고 다음으로 넘어가 <code>while</code> 루프에서 지금 선택한 인덱스가 정렬된 부분에서 어느 위치에 들어가야 정렬 상태가 유지될지 결정한다.</p>
<p>이때, 왜 인덱스를 <code>1</code>부터 시작하는지 궁금할 수 있다. 사실, <code>0</code>번 인덱스부터 시작해도 문제는 없다. 하지만 처음 상황에서, 아직 정렬을 시작하지 않은 상태에서는 굳이 <code>0</code>번 인덱스부터 처리할 필요가 없다. <code>0</code>번 인덱스는 이미 하나의 요소로만 이루어졌기 때문에, 크기가 1인 배열은 정렬된 상태라고 가정할 수 있다. 따라서, 굳이 <code>0</code>번부터 시작하지 않고, <code>1</code>번 인덱스부터 정렬을 시작하면 된다.</p>
<br>
<h3 id="2-2-루프-2">2-2. 루프 [2]</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> arr[j] <span style="color:#f92672">&gt;</span> key) {
</span></span><span style="display:flex;"><span>		arr[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> arr[j];
</span></span><span style="display:flex;"><span>		j<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	arr[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> key;
</span></span></code></pre></div><p>이 부분은 선택된 요소가 정렬된 배열의 어느 위치에 삽입될지 결정하는 루프이다. 여기서 정렬된 부분을 탐색하는 인덱스는 <code>j</code>로, <code>i - 1</code>에서 시작한다. 즉, <code>j</code>는 현재 정렬해야 할 요소(<code>i</code>)의 바로 왼쪽에 있는 값부터 비교를 시작하는데, 이 말은 <code>j</code>가 <code>i - 1</code>에서 0까지 거꾸로 탐색하며, 정렬된 배열에서 적절한 위치를 찾아가게 된다는 의미이다. 코드를 더 자세히 분석해보자.</p>
<ul>
<li>
<p><strong><code>j &gt;= 0</code></strong>:
<code>j</code>가 0보다 작아지면 배열의 범위를 벗어나게 되므로, 배열을 넘어가는 것을 방지하기 위해 이 조건이 필요하다.</p>
</li>
<li>
<p><strong><code>arr[j] &gt; key</code></strong>:
이 조건은 현재 비교 중인 요소 <code>arr[j]</code>가 <code>key</code>보다 큰지 확인한다. 만약 크다면, <code>key</code>가 <code>arr[j]</code>보다 왼쪽에 위치해야 하므로, <code>arr[j]</code>를 오른쪽으로 이동시킨다. 이 과정이 반복되면서 <code>key</code>의 올바른 위치가 결정된다.</p>
</li>
<li>
<p><strong><code>arr[j + 1] = arr[j];</code></strong>:
이 줄은 <code>arr[j]</code>를 오른쪽으로 한 칸 이동시키는 역할을 한다. 즉, <code>arr[j]</code> 값을 <code>arr[j + 1]</code>에 복사하여, <code>arr[j]</code>가 있던 자리는 비워지게 된다. 이 자리가 나중에 <code>key</code>가 들어갈 자리가 될 수 있다.</p>
</li>
<li>
<p><strong><code>j--;</code></strong>:
<code>j</code> 값을 1 줄여 왼쪽으로 이동하면서 계속해서 <code>key</code>보다 큰 값들을 오른쪽으로 밀어낸다. 이 과정을 반복해 <code>key</code>가 들어갈 적절한 위치를 찾는다.</p>
</li>
<li>
<p><strong><code>arr[j + 1] = key;</code></strong>:
<code>while</code> 루프가 끝난 후에는 <code>key</code>가 들어갈 자리가 정해진다. 이때 <code>arr[j + 1]</code> 위치가 <code>key</code>가 삽입될 정확한 위치이다. <code>while</code> 루프가 종료되는 시점에서는 <code>arr[j]</code>가 <code>key</code>보다 작거나 같거나, <code>j</code>가 배열을 벗어난 상태이므로, <code>key</code>는 그 다음 위치인 <code>j + 1</code>에 삽입된다.</p>
</li>
</ul>
<br>
<br>
<h2 id="3-정확성-분석">3. 정확성 분석</h2>
<hr>
<p><code>Insertion sort</code>은 결국 리스트를 순차적으로 하나씩 살펴보며, 현재 요소를 이미 정렬된 부분에 알맞은 위치에 삽입하여 전체 리스트를 정렬하는 알고리즘이다. 예를 들어, 카드 게임에서 손에 카드를 한 장씩 추가하면서 이미 정렬된 손에 새로운 카드를 올바른 위치에 끼워 넣는 과정과 같다. 이제 귀납법을 통해 <code>Insertion sort</code> 알고리즘이 항상 입력된 리스트를 올바르게 정렬하는지 그 <strong>정확성</strong> 을 증명해보자.</p>
<br>
<h3 id="3-1-명제-설정">3-1. 명제 설정</h3>
<p><strong>명제 P(i)</strong>: <em>반복문이 i번째 반복 후에 리스트의 앞부분 A[0&hellip;i−1]은 정렬되어 있다.</em></p>
<p>증명을 위해 위와 같은 명제를 설정하자. 즉, 알고리즘이 <code>i</code>번째 요소까지 처리했을 때, 처음부터 <code>i</code>번째 요소까지의 부분 리스트가 정렬되어있음을 나타낸다.</p>
<br>
<h3 id="3-2-귀납적-증명의-구성-요소">3-2. 귀납적 증명의 구성 요소</h3>
<p>귀납법은 다음 네 가지 단계로 이루어진다.</p>
<ol>
<li><strong>기저 사례(Base Case):</strong> P(0)이 참임을 보인다.</li>
<li><strong>귀납 가정(Inductive Hypothesis):</strong> 임의의 자연수 k에 대해 P(k)가 참이라고 가정한다.</li>
<li><strong>귀납 단계(Inductive Step):</strong> P(k)가 참일 때 P(k+1)도 참임을 보인다.</li>
<li><strong>종료성(Termination):</strong> 알고리즘이 유한한 단계 내에 종료함을 보인다.</li>
</ol>
<br>
<h3 id="3-3-귀납적-증명">3-3. 귀납적 증명</h3>
<h4 id="기저-사례">기저 사례</h4>
<ul>
<li><em>P(0)이 참임을 보이자.</em></li>
</ul>
<p>반복문이 시작하기 전에 리스트의 앞부분 <code>A[0...-1]</code>은 정렬되어 있다. <code>A[0...-1]</code>은 요소가 없는 빈 리스트이므로, 빈 리스트는 이미 정렬된 상태이다. 따라서 P(0)은 참이다.</p>
<br>
<h4 id="귀납-가정">귀납 가정</h4>
<ul>
<li><em>P(k)가 참이라고 가정하자</em></li>
</ul>
<p>임의의 자연수 k에 대해 P(k)가 참이다. 즉, 리스트의 앞부분 <code>A[0...k-1]</code>은 정렬되어 있다.</p>
<br>
<h4 id="귀납-단계">귀납 단계</h4>
<ul>
<li><em>P(k)가 참일 때, P(k+1)도 참임을 보이자.</em></li>
</ul>
<p>P(k)가 참일 때, P(k+1)도 참이라는 것은 곧 <code>A[0...k]</code>이 정렬되어 있음을 보여야 하는 것! 알고리즘은 k번째 요소 <code>A[k]</code>를 고려해보자. 이미 정렬된 리스트 <code>A[0...k-1]</code>에서 <code>A[k]</code>의 적절한 위치를 찾는다. <code>A[k]</code>를 해당 위치에 삽입한다. 즉, 정렬된 리스트에 새로운 요소를 올바른 위치에 삽입하면, 리스트는 여전히 정렬된 상태를 유지한다. 따라서 <code>A[0...k]</code>은 정렬되어 있으며, P(k+1)은 참이다.</p>
<br>
<h4 id="종료성">종료성</h4>
<ul>
<li><em>알고리즘이 유한한 단계 내에 종료함을 보이자.</em></li>
</ul>
<p>인덱스 <code>i</code>가 리스트의 길이 n보다 작을 때까지 반복한다. 각 반복마다 <code>i</code>는 1씩 증가한다. <code>i</code>가 n에 도달하면 반복문이 종료된다. 알고리즘은 유한한 단계 내에 반드시 종료한다.</p>
<br>
<h4 id="결론">결론</h4>
<ul>
<li>P(0)이 참이고, P(k) ⇒ P(k+1)이 참이므로, 수학적 귀납법에 의해 모든 자연수 n에 대해 P(n)이 참이다.</li>
<li>따라서 반복문이 종료된 후 리스트의 전체 부분 <code>A[0...n-1]</code>은 정렬되어 있다.</li>
<li>또한 알고리즘이 유한한 단계 내에 종료하므로, 알고리즘은 정확하게 동작한다.</li>
</ul>
<br>
<br>
<h2 id="4-효율성-분석">4. 효율성 분석</h2>
<hr>
<p>~(작성중)</p>
<br>
<br>
<h2 id="5-reference">5. Reference</h2>
<hr>
<ul>
<li><a href="https://www.geeksforgeeks.org/insertion-sort-algorithm/">https://www.geeksforgeeks.org/insertion-sort-algorithm/</a></li>
</ul>
<br>
<br>

    

<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  backgroundColor: 'rgb(255, 83, 176)',
  textColor: '#fff'
})</script>

</body>
</html>
