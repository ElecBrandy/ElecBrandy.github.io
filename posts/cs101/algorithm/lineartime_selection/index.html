<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '\\(', right: '\\)', display: false},
                {left: '$', right: '$', display: false}
            ]
        });"></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<link rel="stylesheet" href="/css/reset.css">
<title>[알고리즘] Linear-time selection | home</title>

      <link rel="stylesheet" href="/css/main.min.0ce01787cd4bc0759f98b56377f962e02878ce8fb515cc49af5cb83db6a3edfc.css" integrity="sha256-DOAXh81LwHWfmLVjd/li4Ch4zo&#43;1FcxJr1y4Pbaj7fw=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/min700.min.c55885430d625813d1a6770ef6712b8534781fdd318699edd1bb9c6f62907507.css" integrity="sha256-xViFQw1iWBPRpncO9nErhTR4H90xhpnt0bucb2KQdQc=" crossorigin="anonymous">



<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding:wght@400;700&display=swap" rel="stylesheet">



<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZL1NP5K5CJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZL1NP5K5CJ');
</script>


</head>
<body>
    <header class="main-header">
	<nav>
	  <li><a href="/">/home</a></li>
	  <li><a href="/tags">/tags</a></li>
	  <li><a href="/about">/about</a></li>
	  <li id="theme-toggle" style="cursor: pointer;">/todark</li>
	</nav>
  </header>
  
  <script>
	document.addEventListener('DOMContentLoaded', function() {
	  const themeToggle = document.getElementById('theme-toggle');
	  
	  
	  let currentTheme = localStorage.getItem('theme') || 'light';
  
	  
	  document.body.setAttribute('data-theme', currentTheme);
	  themeToggle.textContent = currentTheme === 'dark' ? '/tolight' : '/todark';
  
	  
	  function toggleTheme() {
		
		const newTheme = document.body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
  
		
		document.body.setAttribute('data-theme', newTheme);
  
		
		localStorage.setItem('theme', newTheme);
  
		
		themeToggle.textContent = newTheme === 'dark' ? '/tolight' : '/todark';
	  }
  
	  
	  themeToggle.addEventListener('click', toggleTheme);
	});
  </script>
  
    
  <aside class="toc">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-선형-시간-선택-알고리즘-linear-time-selection">1. 선형 시간 선택 알고리즘 (Linear-Time Selection)</a>
      <ul>
        <li><a href="#1-1-아이디어-분석">1-1. 아이디어 분석</a></li>
      </ul>
    </li>
    <li><a href="#2-구현-분석">2. 구현 분석</a>
      <ul>
        <li><a href="#2-1-함수-select">2-1. 함수 <code>select</code></a></li>
        <li><a href="#2-2-함수-partition">2-2. 함수 <code>partition</code></a></li>
      </ul>
    </li>
    <li><a href="#3-정확성-분석">3. 정확성 분석</a>
      <ul>
        <li><a href="#3-1-명제-설정">3-1. 명제 설정</a></li>
        <li><a href="#3-2-귀납적-증명의-구성-요소">3-2. 귀납적 증명의 구성 요소</a></li>
        <li><a href="#3-3-귀납적-증명">3-3. 귀납적 증명</a></li>
      </ul>
    </li>
    <li><a href="#4-효율성-분석">4. 효율성 분석</a>
      <ul>
        <li><a href="#4-1-평균-시간-복잡도">4-1. 평균 시간 복잡도</a></li>
        <li><a href="#4-2-최악-시간-복잡도">4-2. 최악 시간 복잡도</a></li>
        <li><a href="#4-3-최선-시간-복잡도">4-3. 최선 시간 복잡도</a></li>
        <li><a href="#4-4-개선-방안">4-4. 개선 방안</a></li>
      </ul>
    </li>
    <li><a href="#5-결론">5. 결론</a></li>
  </ul>
</nav>
  </aside>
  <div class="featured-container">
    
      <div class="featured-image">
        <img src="https://upload.wikimedia.org/wikipedia/commons/e/ef/Sorting_shaker_sort_anim.gif" alt="Featured Image for [알고리즘] Linear-time selection">
      </div>
    
    <div class="overlay-text">
      <small>2024.10.10</small>
      <div class="singleTitle">[알고리즘] Linear-time selection</div>
    </div>
  </div>
  <div class="series">
  <details>
    <summary>📚 /algorithm</summary>
    <ul>
      
      
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/list/">list</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/stack/">stack</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/queue/">queue</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/heap/">heap</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/tree/">tree</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/graph/">graph</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/">hashTable</a></li>
      
    </ul>
  </details>
</div>

<br>
<h2 id="1-선형-시간-선택-알고리즘-linear-time-selection">1. 선형 시간 선택 알고리즘 (Linear-Time Selection)</h2>
<hr>
<img src="https://i.imgur.com/sW8twRl.png" width="700">
<p><code>선형 시간 선택 알고리즘</code>은 정렬되지 않은 데이터에서 원하는 순서의 요소(예: k번째로 작은 요소)를 선형 시간 내에 찾는 알고리즘이다. 일반적으로 정렬 알고리즘을 사용하여 데이터를 정렬한 후 원하는 요소를 찾을 수 있지만, 이는 보통 $O(n log n)$ 의 시간 복잡도를 갖는다. 그러나 선형 시간 선택 알고리즘은 정렬되지 않은 상태에서 $O(n)$ 의 시간 복잡도로 원하는 요소를 찾을 수 있다.</p>
<h3 id="1-1-아이디어-분석">1-1. 아이디어 분석</h3>
<p>이 알고리즘은 <code>퀵 정렬(Quick Sort)</code>의 분할 방식을 활용한다. 주어진 배열에서 임의의 <code>피벗(pivot)</code>을 선택하고, 이 피벗을 기준으로 배열을 분할한다. 피벗보다 작은 요소들은 왼쪽 부분 배열에, 큰 요소들은 오른쪽 부분 배열에 위치시킨다. 이때 피벗의 정확한 위치(인덱스)를 알 수 있으며, 이를 통해 원하는 k번째 요소가 피벗의 위치와 비교하여 어느 부분 배열에 존재하는지 판단할 수 있다.</p>
<ul>
<li>만약 피벗의 위치가 k와 같다면, 피벗이 바로 k번째로 작은 요소이다.</li>
<li>피벗의 위치가 k보다 크다면, 원하는 요소는 왼쪽 부분 배열에 있다.</li>
<li>피벗의 위치가 k보다 작다면, 원하는 요소는 오른쪽 부분 배열에 있으며, 이때는 새로운 k 값을 조정하여 탐색을 계속한다.</li>
</ul>
<br>
<br>
<h2 id="2-구현-분석">2. 구현 분석</h2>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">select</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr, <span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> k <span style="color:#f92672">&lt;</span> right <span style="color:#f92672">-</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> right <span style="color:#f92672">-</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> arr[left <span style="color:#f92672">+</span> rand() <span style="color:#f92672">%</span> n];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 분할 과정
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> pivot_idx <span style="color:#f92672">=</span> partition(arr, left, right, pivot);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 피벗의 위치와 k 비교
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (pivot_idx <span style="color:#f92672">-</span> left <span style="color:#f92672">==</span> k)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> arr[pivot_idx];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (pivot_idx <span style="color:#f92672">-</span> left <span style="color:#f92672">&gt;</span> k)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> select(arr, left, pivot_idx <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, k);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> select(arr, pivot_idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, right, k <span style="color:#f92672">-</span> (pivot_idx <span style="color:#f92672">-</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> INT_MAX; <span style="color:#75715e">// 오류 처리
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><br>
<h3 id="2-1-함수-select">2-1. 함수 <code>select</code></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> select(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr, <span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right, <span style="color:#66d9ef">int</span> k)
</span></span></code></pre></div><p>이 함수는 배열 <code>arr</code>에서 <code>left</code>부터 <code>right</code>까지의 범위에서 k번째로 작은 요소를 찾는 함수이다.</p>
<ul>
<li>
<p><strong>매개변수:</strong></p>
<ul>
<li><code>arr</code>: 대상 배열</li>
<li><code>left</code>: 탐색 범위의 시작 인덱스</li>
<li><code>right</code>: 탐색 범위의 끝 인덱스</li>
<li><code>k</code>: 찾고자 하는 순서 (0-based index)</li>
</ul>
</li>
<li>
<p><strong>기본 조건 검사:</strong></p>
<ul>
<li><code>if (k &gt;= 0 &amp;&amp; k &lt; right - left + 1)</code>를 통해 k의 유효성을 확인한다.</li>
<li>k가 현재 배열 범위 내에 있는지 검사하여 그렇지 않으면 오류를 반환한다.</li>
</ul>
</li>
<li>
<p><strong>피벗 선택:</strong></p>
<ul>
<li><code>int n = right - left + 1;</code>을 통해 현재 부분 배열의 크기를 계산한다.</li>
<li><code>int pivot = arr[left + rand() % n];</code>을 사용하여 부분 배열 내에서 임의의 피벗을 선택한다.</li>
</ul>
</li>
<li>
<p><strong>분할 과정:</strong></p>
<ul>
<li><code>int pivot_idx = partition(arr, left, right, pivot);</code>을 호출하여 배열을 피벗을 기준으로 분할하고, 피벗의 최종 위치를 얻는다.</li>
</ul>
</li>
<li>
<p><strong>재귀 호출 및 반환:</strong></p>
<ul>
<li><code>if (pivot_idx - left == k)</code>:
<ul>
<li>피벗의 위치가 k와 같다면, <code>arr[pivot_idx]</code>가 k번째로 작은 요소이다.</li>
</ul>
</li>
<li><code>else if (pivot_idx - left &gt; k)</code>:
<ul>
<li>피벗의 위치가 k보다 크다면, 왼쪽 부분 배열에서 다시 탐색한다.</li>
</ul>
</li>
<li><code>else</code>:
<ul>
<li>피벗의 위치가 k보다 작다면, 오른쪽 부분 배열에서 새로운 k 값을 조정하여 탐색한다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>오류 처리:</strong></p>
<ul>
<li>만약 k가 유효한 범위가 아니라면 <code>INT_MAX</code>를 반환하여 오류를 나타낸다.</li>
</ul>
</li>
</ul>
<br>
<h3 id="2-2-함수-partition">2-2. 함수 <code>partition</code></h3>
<p><code>partition</code> 함수는 퀵 정렬에서 사용하는 분할 함수로, 피벗을 기준으로 배열을 재배열한다. 코드 구현은 다음과 같다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr, <span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right, <span style="color:#66d9ef">int</span> pivot) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (left <span style="color:#f92672">&lt;=</span> right) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (arr[left] <span style="color:#f92672">&lt;</span> pivot)
</span></span><span style="display:flex;"><span>            left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (arr[right] <span style="color:#f92672">&gt;</span> pivot)
</span></span><span style="display:flex;"><span>            right<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">&lt;=</span> right) {
</span></span><span style="display:flex;"><span>            swap(arr[left], arr[right]);
</span></span><span style="display:flex;"><span>            left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            right<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> left <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p><strong>기능:</strong></p>
<ul>
<li>피벗보다 작은 값들은 왼쪽으로, 큰 값들은 오른쪽으로 이동시킨다.</li>
<li>피벗의 최종 위치를 반환한다.</li>
</ul>
</li>
<li>
<p><strong>작동 원리:</strong></p>
<ul>
<li>두 개의 인덱스 <code>left</code>와 <code>right</code>를 사용하여 배열의 양 끝에서부터 탐색한다.</li>
<li><code>arr[left] &lt; pivot</code>인 동안 <code>left</code>를 증가시킨다.</li>
<li><code>arr[right] &gt; pivot</code>인 동안 <code>right</code>를 감소시킨다.</li>
<li>두 인덱스가 유효하면 두 요소를 교환하고, <code>left</code>와 <code>right</code>를 각각 이동시킨다.</li>
</ul>
</li>
</ul>
<br>
<br>
<h2 id="3-정확성-분석">3. 정확성 분석</h2>
<hr>
<p>선형 시간 선택 알고리즘은 퀵 정렬의 분할 방식을 활용하여 원하는 순서의 요소를 찾는다. 이제 수학적 귀납법을 통해 알고리즘의 정확성을 증명해보자.</p>
<br>
<h3 id="3-1-명제-설정">3-1. 명제 설정</h3>
<p><strong>명제 P(n):</strong> <em>배열 크기가 n일 때, <code>select</code> 함수는 k번째로 작은 요소를 정확히 찾아낸다.</em></p>
<br>
<h3 id="3-2-귀납적-증명의-구성-요소">3-2. 귀납적 증명의 구성 요소</h3>
<ol>
<li><strong>기저 사례(Base Case):</strong> n = 1일 때, 명제가 참임을 보인다.</li>
<li><strong>귀납 가정(Inductive Hypothesis):</strong> 배열 크기가 n보다 작은 모든 경우에 대해 명제가 참이라고 가정한다.</li>
<li><strong>귀납 단계(Inductive Step):</strong> 배열 크기가 n인 경우에도 명제가 참임을 보인다.</li>
<li><strong>종료성(Termination):</strong> 알고리즘이 유한한 단계 내에 종료함을 보인다.</li>
</ol>
<br>
<h3 id="3-3-귀납적-증명">3-3. 귀납적 증명</h3>
<h4 id="기저-사례">기저 사례</h4>
<ul>
<li><strong>n = 1인 경우:</strong>
<ul>
<li>배열에 요소가 하나뿐이므로, k = 0일 때 해당 요소를 반환한다.</li>
<li><code>select</code> 함수는 즉시 해당 요소를 반환하므로 명제 P(1)은 참이다.</li>
</ul>
</li>
</ul>
<br>
<h4 id="귀납-가정">귀납 가정</h4>
<ul>
<li><strong>배열 크기가 n보다 작은 경우, 즉 모든 m &lt; n에 대해 명제 P(m)이 참이라고 가정한다.</strong></li>
</ul>
<br>
<h4 id="귀납-단계">귀납 단계</h4>
<ul>
<li>
<p><strong>배열 크기가 n인 경우:</strong></p>
<ol>
<li>
<p><strong>피벗 선택 및 분할:</strong></p>
<ul>
<li>임의의 피벗을 선택하고, <code>partition</code> 함수를 통해 배열을 분할한다.</li>
<li>분할 후 피벗의 위치 <code>pivot_idx</code>를 얻는다.</li>
</ul>
</li>
<li>
<p><strong>피벗의 위치와 k 비교:</strong></p>
<ul>
<li><code>pivot_idx - left == k</code>인 경우, 피벗이 k번째로 작은 요소이므로 반환한다.</li>
<li><code>pivot_idx - left &gt; k</code>인 경우, 왼쪽 부분 배열에서 탐색한다.</li>
<li><code>pivot_idx - left &lt; k</code>인 경우, 오른쪽 부분 배열에서 새로운 k 값을 조정하여 탐색한다.</li>
</ul>
</li>
<li>
<p><strong>재귀 호출의 유효성:</strong></p>
<ul>
<li>재귀 호출되는 배열의 크기는 항상 n보다 작다.</li>
<li>귀납 가정에 의해, 재귀 호출은 올바른 결과를 반환한다.</li>
</ul>
</li>
<li>
<p>**따라서, 배열 크기가 n인 경우에도 <code>select</code> 함수는 정확한 결과를 반환한다.</p>
</li>
</ol>
</li>
</ul>
<br>
<h4 id="종료성">종료성</h4>
<ul>
<li><strong>알고리즘의 종료성:</strong>
<ul>
<li>각 재귀 호출마다 배열의 크기가 감소한다.</li>
<li>최악의 경우에도 배열의 크기가 1씩 줄어들어 결국 n = 1인 기저 사례에 도달한다.</li>
<li>따라서 알고리즘은 유한한 단계 내에 종료한다.</li>
</ul>
</li>
</ul>
<br>
<h4 id="결론">결론</h4>
<ul>
<li>기저 사례와 귀납 단계를 통해 모든 자연수 n에 대해 명제 P(n)이 참임을 증명하였다.</li>
<li>따라서 <code>select</code> 알고리즘은 항상 k번째로 작은 요소를 정확히 찾아낸다.</li>
</ul>
<br>
<br>
<h2 id="4-효율성-분석">4. 효율성 분석</h2>
<hr>
<p>선형 시간 선택 알고리즘의 시간 복잡도를 분석해보자.</p>
<br>
<h3 id="4-1-평균-시간-복잡도">4-1. 평균 시간 복잡도</h3>
<ul>
<li><strong>평균적으로 알고리즘은 <code>O(n)</code>의 시간 복잡도를 갖는다.</strong>
<ul>
<li>피벗이 배열을 균등하게 분할할 경우, 각 재귀 호출에서 처리해야 할 배열의 크기는 절반으로 줄어든다.</li>
<li>따라서 다음과 같은 재귀 관계를 얻는다.
$$
T(n) = T\left(\frac{n}{2}\right) + O(n)
$$</li>
<li>이를 풀면 $T(n) = O(n)$이 된다.</li>
</ul>
</li>
</ul>
<br>
<h3 id="4-2-최악-시간-복잡도">4-2. 최악 시간 복잡도</h3>
<ul>
<li><strong>최악의 경우, 알고리즘의 시간 복잡도는 <code>O(n^2)</code>이다.</strong>
<ul>
<li>피벗이 배열을 극단적으로 불균형하게 분할할 경우, 예를 들어 항상 가장 큰 또는 가장 작은 값을 피벗으로 선택하면, 각 재귀 호출에서 배열의 크기가 1씩만 줄어든다.</li>
<li>이때 재귀 호출의 깊이는 n이 되고, 전체 시간 복잡도는 다음과 같다.
$$
T(n) = T(n - 1) + O(n)
$$</li>
<li>이를 풀면 $T(n) = O(n^2)$이 된다.</li>
</ul>
</li>
</ul>
<br>
<h3 id="4-3-최선-시간-복잡도">4-3. 최선 시간 복잡도</h3>
<ul>
<li><strong>최선의 경우에도 평균 시간 복잡도와 동일하게 <code>O(n)</code>이다.</strong></li>
</ul>
<br>
<h3 id="4-4-개선-방안">4-4. 개선 방안</h3>
<ul>
<li>
<p><strong>무작위 피벗 선택:</strong></p>
<ul>
<li>피벗을 무작위로 선택함으로써 평균적으로 균형 잡힌 분할을 기대할 수 있다.</li>
<li>이는 최악의 경우를 발생시킬 확률을 낮춘다.</li>
</ul>
</li>
<li>
<p><strong>Median of Medians 알고리즘:</strong></p>
<ul>
<li>항상 좋은 피벗을 선택하기 위해 <code>Median of Medians</code> 알고리즘을 사용하면 최악의 경우에도 <code>O(n)</code>의 시간 복잡도를 보장할 수 있다.</li>
<li>그러나 상수 계수가 커서 실제로는 무작위 피벗 선택이 더 효율적일 수 있다.</li>
</ul>
</li>
</ul>
<br>
<br>
<h2 id="5-결론">5. 결론</h2>
<hr>
<p><code>선형 시간 선택 알고리즘</code>은 퀵 정렬의 분할 방식을 활용하여 정렬되지 않은 배열에서 원하는 순서의 요소를 효율적으로 찾을 수 있다. 평균적으로 <code>O(n)</code>의 시간 복잡도를 가지며, 추가적인 메모리 공간을 필요로 하지 않는다. 무작위 피벗 선택을 통해 최악의 경우를 피할 수 있으며, 큰 데이터 집합에서 효율적으로 동작한다. 그러나 최악의 경우 <code>O(n^2)</code>의 시간 복잡도를 가질 수 있으므로, 이러한 상황을 방지하기 위한 추가적인 전략이 필요할 수 있다.</p>


    

<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  backgroundColor: 'rgb(255, 83, 176)',
  textColor: '#fff'
})</script>

</body>
</html>
