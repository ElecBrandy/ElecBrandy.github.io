<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<link rel="stylesheet" href="/css/reset.css">
<title>[자료구조] List | home</title>

      <link rel="stylesheet" href="/css/main.min.0ce01787cd4bc0759f98b56377f962e02878ce8fb515cc49af5cb83db6a3edfc.css" integrity="sha256-DOAXh81LwHWfmLVjd/li4Ch4zo&#43;1FcxJr1y4Pbaj7fw=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/min700.min.c55885430d625813d1a6770ef6712b8534781fdd318699edd1bb9c6f62907507.css" integrity="sha256-xViFQw1iWBPRpncO9nErhTR4H90xhpnt0bucb2KQdQc=" crossorigin="anonymous">



<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding:wght@400;700&display=swap" rel="stylesheet">



<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZL1NP5K5CJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZL1NP5K5CJ');
</script>


</head>
<body>
    <header class="main-header">
	<nav>
	  <li><a href="/">/home</a></li>
	  <li><a href="/tags">/tags</a></li>
	  <li><a href="/about">/about</a></li>
	  <li id="theme-toggle" style="cursor: pointer;">/todark</li>
	</nav>
  </header>
  
  <script>
	document.addEventListener('DOMContentLoaded', function() {
	  const themeToggle = document.getElementById('theme-toggle');
	  
	  
	  let currentTheme = localStorage.getItem('theme') || 'light';
  
	  
	  document.body.setAttribute('data-theme', currentTheme);
	  themeToggle.textContent = currentTheme === 'dark' ? '/tolight' : '/todark';
  
	  
	  function toggleTheme() {
		
		const newTheme = document.body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
  
		
		document.body.setAttribute('data-theme', newTheme);
  
		
		localStorage.setItem('theme', newTheme);
  
		
		themeToggle.textContent = newTheme === 'dark' ? '/tolight' : '/todark';
	  }
  
	  
	  themeToggle.addEventListener('click', toggleTheme);
	});
  </script>
  
    
  <aside class="toc">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-소개">1. 소개</a></li>
    <li><a href="#2-array-list">2. Array List</a></li>
    <li><a href="#3-linked-list">3. Linked List</a></li>
    <li><a href="#4-linked-list의-구현">4. Linked List의 구현</a>
      <ul>
        <li><a href="#3-1-1-with-c">3-1-1. with C</a></li>
        <li><a href="#3-1-2-stllinked-list">3-1-2. STL::Linked List</a></li>
      </ul>
    </li>
    <li><a href="#5-reference">5. Reference</a></li>
  </ul>
</nav>
  </aside>
  <div class="featured-container">
    
      <div class="featured-image">
        <img src="https://programmercave.com/assets/images/Memes-Linkedlist/llmeme1.jpg" alt="Featured Image for [자료구조] List">
      </div>
    
    <div class="overlay-text">
      <small>2024.09.09</small>
      <div class="singleTitle">[자료구조] List</div>
    </div>
  </div>
  <div class="series">
  <details>
    <summary>📚 /dataStructure</summary>
    <ul>
      
      
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/list/">list</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/stack/">stack</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/queue/">queue</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/heap/">heap</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/tree/">tree</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/graph/">graph</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/cs101/datastructure/hashtable/">hashTable</a></li>
      
    </ul>
  </details>
</div>

<br>
<h2 id="1-소개">1. 소개</h2>
<hr>
<p>List는 순서가 있는 데이터의 집합을 나타내는 가장 기초적인 자료구조 중 하나로, 배열(array)과의 근본적인 차이는 동적 크기 변화와 복잡한 데이터 구조를 지원하는 것이다. List는 CS에서 다양한 형태로 존재하며, 대표적으로 배열 리스트(Array List)와 연결 리스트(Linked List)가 존재한다.</p>
<br>
<br>
<h2 id="2-array-list">2. Array List</h2>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec;  <span style="color:#75715e">// 동적 크기를 갖는 배열 리스트
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vec.push_back(<span style="color:#ae81ff">1</span>);      <span style="color:#75715e">// 새로운 요소 추가
</span></span></span></code></pre></div><p><strong>Array List</strong>는 연속적인 메모리 공간에 데이터를 저장하는 방식이다. 이는 인덱스를 통한 빠른 접근 속도(시간 복잡도 <code>O(1)</code>)가 특징이지만, 크기를 미리 지정해야 하는 제약이 있다. 만약 리스트가 가득 차면 새로운 더 큰 메모리 공간을 할당하고, 기존 요소를 복사하는 과정을 거쳐야하며 이 복사 작업의 평균 시간 복잡도는 <code>O(n)</code>이다. 대표적인 예시로 <code>vector</code>를 들 수 있다.</p>
<p>기존 크기가 10인 Array list에 요소를 한가지 더 추가한다면, 내부적으로 11의 공간을 할당한 후, 기존 데이터를 복사한 다음 요소를 추가하는 작업이 존재한다. 물론 일반적으로는 배열 크기를 증가 시킬 때 10 -&gt; 11 처럼 좀좀따리가 아니라 두배정도 증가시켜 추가 연산을 어느정도 제한하고 있다.</p>
<br>
<br>
<h2 id="3-linked-list">3. Linked List</h2>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20220829110944/LLdrawio.png" width="700">
<p><strong>Linked List</strong>는 선형 데이터 구조로, 요소가 연속된 메모리 위치에 저장되어있지 않다. 즉, 일반 배열 처럼 <code>a[i]</code>의 다음 주소에 <code>a[i + 1]</code>이 무조건적으로 존재하지 않는다. 이 각 요소는 포인터를 사용해서 연결되어 있다.</p>
<p>보통 각 요소를 하나의 노드라고 칭하며, 각 노드는 <strong>데이터</strong>부분과 다음 노드의 주소가 담긴 <strong>포인터</strong>부분으로 구성되어 있다. 이때 각 노드가 다음 노드 뿐만 아니라 이전 노드의 주소도 담고 있게 만들어 활용할 수 있다. 혹은 마지막 노드가 첫번째 노드의 주소를 담고 있게 하면 Circular Linked List(원형 연결 리스트)로도 구현이 가능하다.</p>
<p>첫번째 노드의 주소가 담긴 HEAD의 경우 노드 구조와 별개로 포인터를 따로 두거나, 더미노드(데이터 부분이 비어있는 노드)로 만드는 방법이 존재한다.</p>
<p>전체적으로 활용도가 높기 때문에, Linked List를 이용해서 여러가지 자료구조를 구현할 수 있다. <code>C++</code>의 STL의 경우 다양한 자료구조를 Linked List를 이용해 구현해놓았다!</p>
<p>Linked List는 노드의 포인터를 통해 연결을 관리하기 때문에 자료의 추가나 삭제가 매우 용이하다. 그러나 자료 조회 측면에서는 배열에 비해 많은 자원이 소모된다. 배열은 인덱스를 통해 원하는 정보에 바로 접근할 수 있지만, Linked List는 조회를 위해 처음 노드부터 하나하나 순회하면서 조건에 맞는 노드를 찾아야하기 때문이다.</p>
<p>이러한 Linked List를 적절히 잘 사용하기 위해서라면&hellip; 응당 무언가의 연산을 가져야 할 것이다. 예를 들어 노드를 생성 한다던가 삭제한다던가. <strong>자료구조를 구축</strong>하기 위한 연산, <strong>자료구조에 저장된 데이터를 활용</strong>하기 위한 연산 모두 필요하다.</p>
<br>
<br>
<h2 id="4-linked-list의-구현">4. Linked List의 구현</h2>
<hr>
<p>사실 Linked List는 42 과정의 처음부터 끝까지 정말 자주 사용하는 자료구조 중 하나이다. 하물며 본과정 첫 과제인 <code>Libft</code>에서 명세에 따르면 Linked List의 구현과 연산 함수를 작성해야한다! 우선그때의 기억을 떠올려서 간단하게 <code>C</code>언어를 통해 Linked List를 구현해본 후, <code>C++</code>의 STL에 속한 Linked List 자료구조 사용법을 알아보자.</p>
<br>
<h3 id="3-1-1-with-c">3-1-1. with C</h3>
<h4 id="노드-구조">노드 구조</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> s_node {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>	t_node <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>} t_node
</span></span></code></pre></div><p>위 구조체는 Linked List의 한 노드의 구성이다. 한 노드는 데이터 영역과, 다음 노드의 주소 정보를 담고있는 포인터 영역으로 구분된다.</p>
<br>
<h4 id="할당과-해제">할당과 해제</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>t_node <span style="color:#f92672">*</span><span style="color:#a6e22e">create_node</span>(<span style="color:#66d9ef">int</span> data) {
</span></span><span style="display:flex;"><span>	t_node <span style="color:#f92672">*</span>new_node <span style="color:#f92672">=</span> (node <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(node));    <span style="color:#75715e">// 1. 메모리 할당
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	new_node<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> data;                              <span style="color:#75715e">// 2. 데이터 입력
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	new_node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL<span style="color:#f92672">:</span>                              <span style="color:#75715e">// 3. next 초기화
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> new_node;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">free_node</span>(t_node <span style="color:#f92672">*</span>node) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">free</span>(node);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>우선, 힙 영역에 노드 크기만큼 메모리를 할당한다. 그 다음 인자로 입력받은 int 값을 통해 data를 초기화하고, 다음 노드를 가리키는 포인터 변수를 <code>NULL</code>로 초기화한다. 아직 어디에 연결할지는 모르는 상태이기 때문.</p>
<br>
<h4 id="추가-연산">추가 연산</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">append_node</span>(t_node <span style="color:#f92672">**</span>head, t_node <span style="color:#f92672">*</span>new_node) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ((<span style="color:#f92672">*</span>head) <span style="color:#f92672">==</span> NULL) {                  <span style="color:#75715e">// head가 NULL일 경우 new_node가 새로운 head로!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#f92672">*</span>head <span style="color:#f92672">=</span> new_node;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		node <span style="color:#f92672">*</span>cur_node <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>head);          <span style="color:#75715e">// list를 순회하자.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">while</span> (cur_node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {   <span style="color:#75715e">// next를 통해 타고타고 넘어가 맨 마지막 노드에 도달한다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		cur_node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> new_node           <span style="color:#75715e">// 마지막 노드의 next를 new_node로 설정
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><br>
<h4 id="탐색-연산">탐색 연산</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// 노드 탐색_1 (n번째 순서의)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>t_node <span style="color:#f92672">*</span><span style="color:#a6e22e">get_node_n</span>(t_node <span style="color:#f92672">*</span>head, <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>	t_node <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">--</span>n <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> cur;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 노드 탐색_2 (data 탐색)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>t_node <span style="color:#f92672">*</span><span style="color:#a6e22e">get_node_n</span>(t_node <span style="color:#f92672">*</span>head, <span style="color:#66d9ef">int</span> data) {
</span></span><span style="display:flex;"><span>	t_node <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (cur<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">==</span> data) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span> ;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> cur;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><br>
<h4 id="삭제-연산">삭제 연산</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove_node</span>(t_node <span style="color:#f92672">**</span>head, <span style="color:#66d9ef">int</span> data) {
</span></span><span style="display:flex;"><span>	t_node <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span>	t_node <span style="color:#f92672">*</span>prev <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 첫 번째 노드가 삭제할 노드일 경우
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (cur<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">==</span> data) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>head <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;  <span style="color:#75715e">// 헤드를 다음 노드로 변경
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">free</span>(cur);          <span style="color:#75715e">// 메모리 해제
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 삭제할 노드를 찾기 위한 순회
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> cur<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">!=</span> data) {
</span></span><span style="display:flex;"><span>		prev <span style="color:#f92672">=</span> cur;         <span style="color:#75715e">// 이전 노드 저장
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;    <span style="color:#75715e">// 다음 노드로 이동
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 삭제할 노드를 찾지 못한 경우
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 이전 노드의 next가 삭제할 노드의 다음 노드를 가리키게 함
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">free</span>(cur);  <span style="color:#75715e">// 삭제할 노드의 메모리 해제
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><br>
<h4 id="삽입-연산">삽입 연산</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert_node</span>(t_node <span style="color:#f92672">**</span>head, t_node <span style="color:#f92672">*</span>new_node, <span style="color:#66d9ef">int</span> position) {
</span></span><span style="display:flex;"><span>	t_node <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span>	t_node <span style="color:#f92672">*</span>prev <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 리스트가 비어있으면 new_node를 첫 노드로 삽입
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> position <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		new_node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>head <span style="color:#f92672">=</span> new_node;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 리스트 순회하여 삽입할 위치 이전 노드를 찾음
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">--</span>position <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		prev <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>		cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 새로운 노드를 삽입할 위치에 연결
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (prev <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> new_node;
</span></span><span style="display:flex;"><span>		new_node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>특정 함수에서 <code>head</code>를 이중 포인터 형식으로 전달하는 이유는 <strong>리스트의 첫 번째 노드 자체를 수정해야 할 가능성</strong>이 있기 때문이다.</p>
<p><code>head</code>는 보통 리스트의 첫 번째 노드를 가리키는 포인터다. 만약 리스트의 첫 번째 위치에 새로운 노드를 추가하거나, 첫 번째 노드를 삭제할 때는 <strong>첫 번째 노드가 변경</strong>되어야 한다. 이때, <code>head</code>가 새로운 노드를 가리키게 하려면 <strong>함수 내부에서 head 자체를 수정</strong>해야 한다.</p>
<p>하지만, C 언어에서 함수는 인자로 받은 값을 복사해서 처리한다. 그래서 단순히 <code>head</code>를 함수에 넘기면, 함수 내부에서 아무리 수정해도 <strong>함수 밖의 실제 <code>head</code>는 바뀌지 않는다.</strong> 즉, 리스트의 첫 번째 노드를 바꿔야 하는 상황에서는 원하는 수정이 이루어지지 않는다.</p>
<p>이 문제를 해결하기 위해 <strong>이중 포인터</strong>를 사용한다. 이중 포인터는 <code>head</code>를 가리키는 포인터를 함수로 넘기는 방식이다. 그러면 함수 내부에서 <code>head</code>가 가리키는 위치를 직접 바꿀 수 있다. 이를 통해 <strong>리스트의 첫 번째 노드를 수정</strong>할 수 있게 된다.</p>
<p>예를 들어, 리스트의 맨 앞에 노드를 삽입하는 함수에서 이중 포인터가 필요한 이유는, 새로 삽입된 노드를 리스트의 첫 번째 노드로 설정해야 하기 때문이다. 이 작업을 하기 위해서는 <code>head</code> 자체를 수정해야 하므로, 이중 포인터로 <code>head</code>를 전달하는 것이 필요하다.</p>
<p>쉽게 말해, <strong>리스트의 첫 번째 노드를 수정해야 할 때는 이중 포인터를 사용</strong>해서, 함수 안에서 실제 <code>head</code>가 바뀌도록 만들어야 한다.</p>
<br>
<br>
<h3 id="3-1-2-stllinked-list">3-1-2. STL::Linked List</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// std::list 선언 및 초기화
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> myList;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 요소 추가 (push_back: 리스트의 끝에 추가)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	myList.push_back(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>	myList.push_back(<span style="color:#ae81ff">20</span>);
</span></span><span style="display:flex;"><span>	myList.push_back(<span style="color:#ae81ff">30</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 요소 추가 (push_front: 리스트의 앞에 추가)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	myList.push_front(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 특정 위치에 요소 삽입 (iterator를 이용해 20 뒤에 25 삽입)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> myList.begin();
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>advance(it, <span style="color:#ae81ff">3</span>);  <span style="color:#75715e">// iterator를 세 번째 위치로 이동 (20 위치)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	myList.insert(it, <span style="color:#ae81ff">25</span>);  <span style="color:#75715e">// 20 뒤에 25 삽입
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 다시 출력
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;After inserting 25: &#34;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> val : myList) {
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> val <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;  <span style="color:#75715e">// 0 10 20 25 30 출력
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 요소 삭제 (pop_front: 앞에서 삭제, pop_back: 뒤에서 삭제)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	myList.pop_front();  <span style="color:#75715e">// 앞의 0을 삭제
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	myList.pop_back();   <span style="color:#75715e">// 뒤의 30을 삭제
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 최종 리스트 출력
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;After popping front and back: &#34;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> val : myList) {
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> val <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;  <span style="color:#75715e">// 10 20 25 출력
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>C++</code>의 <strong>STL</strong>에서는 std::list라는 자료구조를 제공하여 Linked List를 쉽게 사용할 수 있다. std::list는 이중 연결 리스트로 구현되어 있으며, 삽입, 삭제 연산이 매우 효율적임! 이 자료구조는 앞쪽과 뒤쪽 양방향으로 노드를 탐색할 수 있다.</p>
<p>노드 하나에 int 뿐만 아니라 다양한 자료를 담고 싶다면, 원하는 구성의 구조체를 자료형으로 만들고, 그 자료형으로 list를 활용하면 된다.</p>
<br>
<br>
<h2 id="5-reference">5. Reference</h2>
<hr>
<ul>
<li><a href="https://www.geeksforgeeks.org/linked-list-data-structure/">https://www.geeksforgeeks.org/linked-list-data-structure/</a></li>
<li><a href="https://code-lab1.tistory.com/2">https://code-lab1.tistory.com/2</a></li>
<li><a href="https://www.dotnetnote.com/docs/c-language/c-single-linked-list/">https://www.dotnetnote.com/docs/c-language/c-single-linked-list/</a></li>
</ul>
<br>
<br>

    

<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  backgroundColor: 'rgb(255, 83, 176)',
  textColor: '#fff'
})</script>

</body>
</html>
