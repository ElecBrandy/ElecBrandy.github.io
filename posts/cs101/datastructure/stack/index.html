<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>[자료구조] Stack | Elecbrandy</title>

      <link rel="stylesheet" href="/css/main.min.354dee9209e140b5a30068642042c47f9c24a67414df1372513601840a6a69e0.css" integrity="sha256-NU3ukgnhQLWjAGhkIELEf5wkpnQU3xNyUTYBhApqaeA=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/min700.min.2bcf847d60d198d878bbf49b39374a02cdc7cd4e66411bfa42ada12fe8b580ba.css" integrity="sha256-K8&#43;EfWDRmNh4u/SbOTdKAs3HzU5mQRv6Qq2hL&#43;i1gLo=" crossorigin="anonymous">


      <script src="/js/main.0740a53bb4495dfc0d897c89f56fe801f29d1ad0d7e20f51491e421debb12f67.js" integrity="sha256-B0ClO7RJXfwNiXyJ9W/oAfKdGtDX4g9RSR5CHeuxL2c=" crossorigin="anonymous"></script>

<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" integrity="sha384-k6vP0kLaVwmS/tB1lCew8HlB/iMDmD4B9Vq3OU9bfXjMWmWrARyAZF9a3F7sKwDx" crossorigin="anonymous">



</head>
<body>
  <header>
    <header class="header-other">
	<div class="header-container">
		<div class="header-title">
			<a href="https://elecbrandy.github.io/">Elecbrandy</a>
	  	</div>
	  	<ul class="header-menu">
			<li><a href="https://elecbrandy.github.io//tags">TAGS</a></li>
			<li><a href="https://elecbrandy.github.io//about">ABOUT</a></li>
			<button id="theme-toggle" aria-label="Toggle theme">
				<img src="/dark.svg" alt="Dark mode" id="dark-icon">
				<img src="/light.svg" alt="Light mode" id="light-icon">
			  </button>
		</ul>
	</div>
	
		<div class="progress-bar"></div>
  	
</header>

  </header>
  
    
        <div class="pre-content" style="background-image: url('https://image.fnnews.com/resource/media/image/2012/11/04/201211041607219413_l.jpg');"></div>
        <div class="pre-title">
            
            
            <time datetime="2024-09-11T00:00:00&#43;00:00">September 11, 2024</time>
            <h1>[자료구조] Stack</h1>
        </div>
    


  <div class="content">
    
  <p><strong>📂 : 자료구조</strong></p>
<hr>
<blockquote>
<p><a href="https://elecbrandy.github.io/tags/dataStructure/list"> <strong>[0]</strong> List </a></p>
</blockquote>
<blockquote>
<p><a href="https://elecbrandy.github.io/tags/dataStructure/stack"> <strong>[1]</strong> Stack </a></p>
</blockquote>
<blockquote>
<p><a href="https://elecbrandy.github.io/tags/dataStructure/queue"> <strong>[2]</strong> Queue </a></p>
</blockquote>
<blockquote>
<p><a href="https://elecbrandy.github.io/tags/dataStructure/heap"> <strong>[3]</strong> Heap </a></p>
</blockquote>
<blockquote>
<p><a href="https://elecbrandy.github.io/tags/dataStructure/tree"> <strong>[4]</strong> Tree </a></p>
</blockquote>
<blockquote>
<p><a href="https://elecbrandy.github.io/tags/dataStructure/graph"> <strong>[5]</strong> Graph </a></p>
</blockquote>
<blockquote>
<p><a href="https://elecbrandy.github.io/tags/dataStructure/hashtable"> <strong>[6]</strong> HashTable </a></p>
</blockquote>
<br>
<br>
<h1 id="stack">Stack</h1>
<hr>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240606180735/Stack-representation-in-Data-Structures-(1).webp" width="700">
<p>Stack은 <strong>LIFO(Last in, First Out)</strong> 방식으로 작동하는 선형 자료구조이다. 즉, 가장 마지막에 삽입된 데이터가 가장 먼저 삭제되는 구조인 것! Stack의 입/출력은 오로지 Stack의 꼭대기에서만 이루어진다. 갑자기 중간에 있는 데이터를 삭제하거나 끼워넣을 수 없으며, 맨 아래 데이터에 접근하기 위해서는 그 위에 있는 데이터를 모두 걷어내야한다.</p>
<br>
<br>
<h1 id="stack의-구현">StacK의 구현</h1>
<hr>
<p>여러 환경에서 이미 Stack은 구현되어있는 자료구조이지만, 공부를 위해서 직접 구현해보자. 일단은 <code>C</code>를 이용해 Array로 구현해보고, <code>C++</code>의 STL에 속한 Stack 자료구조 사용법을 익혀보자. Linked List를 통해서도 Stack을 구현할 수 있으며, 전체용량을 관리하기 쉽다는 이점이 있다. <a href="https://elecbrandy.github.io/tags/dataStructure/list"> Linked List </a> 의 여러 규칙에 규칙을 더해주기만 하면 만들 수 있다.</p>
<br>
<h2 id="c로-구현한-stackarray">C로 구현한 Stack(Array)</h2>
<h3 id="노드-구조">노드 구조</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> s_node {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>} t_node;
</span></span></code></pre></div><br>
<h3 id="스택-구조">스택 구조</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> s_stack {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> capacity;   <span style="color:#75715e">// 해당 Stack이 얼마만큼의 노드를 가질 수 있는지 알기 위해
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> top;		<span style="color:#75715e">// 삽입, 제거 연산 시 필요한 최상위 노드의 위치
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	t_node <span style="color:#f92672">*</span>nodes;	<span style="color:#75715e">// 노드 배열
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} t_stack;
</span></span></code></pre></div><p>Stack을 배열로 구현할 경우 용량, 최상위 노드의 위치, 노드 배열 이렇게 세 가지 정보를 가지고 있어야 한다. 이제 이어서 Stack을 할당하고 해제하는 함수를 만들어보자.</p>
<br>
<h3 id="할당과-해제">할당과 해제</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">create_stack</span>(t_stack <span style="color:#f92672">**</span>stack, <span style="color:#66d9ef">int</span> capacity) {
</span></span><span style="display:flex;"><span>	(<span style="color:#f92672">*</span>stack) j<span style="color:#f92672">=</span> (t_stack <span style="color:#f92672">*</span>a)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(t_stack));				<span style="color:#75715e">// 1. Stack을 할당하고
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	(<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>nodes <span style="color:#f92672">=</span> (node <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(node) <span style="color:#f92672">*</span> capacity) 	<span style="color:#75715e">// 2. size 만큼의 노드를 추가
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	(<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>capacity <span style="color:#f92672">=</span> capacity;								<span style="color:#75715e">// 3. capacity 초기화
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	(<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;											<span style="color:#75715e">// 4. top 초기화
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">free_stack</span>(t_stack <span style="color:#f92672">*</span>stack) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">free</span>(stack<span style="color:#f92672">-&gt;</span>nodes);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">free</span>(stack);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>이때 컴퓨터 배열 인덱스 상 첫번쨰 요소를 0으로 사용하므로, 비어있는 Stack의 최상위는 이보다 작아야한다. 따라서 <code>top</code>을 <code>-1</code>로 초기화한다. 이어서 삽입과 제거 연산도 만들어보자.</p>
<br>
<h3 id="stack-연산">Stack 연산</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_push</span>(t_stack <span style="color:#f92672">*</span>stack, <span style="color:#66d9ef">int</span> insert_data) {
</span></span><span style="display:flex;"><span>	stack<span style="color:#f92672">-&gt;</span>top<span style="color:#f92672">++</span>;									<span style="color:#75715e">// 1. 최상위 인덱스 업데이트 (증가)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	stack<span style="color:#f92672">-&gt;</span>nodes[stack<span style="color:#f92672">-&gt;</span>top].data <span style="color:#f92672">=</span> insert_data;	<span style="color:#75715e">// 2. 업데이트 된 최상위 인덱스의 노드에 data 입력
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">do_pop</span>(t_stack <span style="color:#f92672">*</span>stack) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> stack<span style="color:#f92672">-&gt;</span>top<span style="color:#f92672">--</span>; 						<span style="color:#75715e">// 1. 최상위 인덱스 업데이트 (감소)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> stack<span style="color:#f92672">-&gt;</span>nodes[tmp].data; 					<span style="color:#75715e">// 2. pop, 즉 Stack에서 제거한 노드의 data를 호출자에게 반환해주자.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>이 외에도 Stack이 비어있는지 검사하거나, 최상위 노드 데이터만 반환하는 함수 등을 만들어 사용할 수 있다.</p>
<br>
<br>
<h2 id="stlstack">STL::Stack</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> myStack;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 요소 삽입
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    myStack.push(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>    myStack.push(<span style="color:#ae81ff">20</span>);
</span></span><span style="display:flex;"><span>    myStack.push(<span style="color:#ae81ff">30</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 최상위 요소 출력 및 제거
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Top element: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> myStack.top() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    myStack.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;After pop, top element: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> myStack.top() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>C++</code>의 <strong>STL</strong>에서는 std::list라는 자료구조를 제공하여 Stack을 쉽게 사용할 수 있다.</p>
<br>
<br>
<h1 id="reference">Reference</h1>
<hr>
<ul>
<li><a href="https://www.geeksforgeeks.org/stack-data-structure/">https://www.geeksforgeeks.org/stack-data-structure/</a></li>
<li><a href="https://www.w3schools.com/dsa/dsa_data_stacks.php">https://www.w3schools.com/dsa/dsa_data_stacks.php</a></li>
</ul>
<br>
<div class="alert">
    <span><a href="https://elecbrandy.github.io/tags/datastructure/"> 자료구조 </a></span>
</div>

<br>


  </div>
  <footer>
    

<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  backgroundColor: 'rgb(255, 83, 176)',
  textColor: '#fff'
})</script>

  </footer>
</body>
</html>
