<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<link rel="stylesheet" href="/css/reset.css">
<title>[42cursus] ft_printf | home</title>

      <link rel="stylesheet" href="/css/main.min.0ce01787cd4bc0759f98b56377f962e02878ce8fb515cc49af5cb83db6a3edfc.css" integrity="sha256-DOAXh81LwHWfmLVjd/li4Ch4zo&#43;1FcxJr1y4Pbaj7fw=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/min700.min.c55885430d625813d1a6770ef6712b8534781fdd318699edd1bb9c6f62907507.css" integrity="sha256-xViFQw1iWBPRpncO9nErhTR4H90xhpnt0bucb2KQdQc=" crossorigin="anonymous">



<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <header class="main-header">
	<nav>
	  <li><a href="/">/home</a></li>
	  <li><a href="/tags">/tags</a></li>
	  <li><a href="/about">/about</a></li>
	  <li id="theme-toggle" style="cursor: pointer;">/todark</li>
	</nav>
  </header>
  
  <script>
	document.addEventListener('DOMContentLoaded', function() {
	  const themeToggle = document.getElementById('theme-toggle');
	  
	  
	  let currentTheme = localStorage.getItem('theme') || 'light';
  
	  
	  document.body.setAttribute('data-theme', currentTheme);
	  themeToggle.textContent = currentTheme === 'dark' ? '/tolight' : '/todark';
  
	  
	  function toggleTheme() {
		
		const newTheme = document.body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
  
		
		document.body.setAttribute('data-theme', newTheme);
  
		
		localStorage.setItem('theme', newTheme);
  
		
		themeToggle.textContent = newTheme === 'dark' ? '/tolight' : '/todark';
	  }
  
	  
	  themeToggle.addEventListener('click', toggleTheme);
	});
  </script>
  
    
  <aside class="toc">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-소개">1. 소개</a></li>
    <li><a href="#2-ft_printf-명세서">2. ft_printf 명세서</a></li>
    <li><a href="#3-개념-정리">3. 개념 정리</a>
      <ul>
        <li><a href="#3-1-가변인자">3-1. 가변인자</a></li>
        <li><a href="#3-2-바이트-패딩">3-2. 바이트 패딩</a></li>
      </ul>
    </li>
    <li><a href="#4-mandatory">4. Mandatory</a>
      <ul>
        <li></li>
        <li><a href="#4-1-구현">4-1. 구현</a></li>
      </ul>
    </li>
    <li><a href="#5-reference">5. Reference</a></li>
  </ul>
</nav>
  </aside>
  <div class="featured-container">
    
      <div class="featured-image">
        <img src="http://t1.daumcdn.net/cfile/146B7E10B091A05214" alt="Featured Image for [42cursus] ft_printf">
      </div>
    
    <div class="overlay-text">
      <small>2023.11.11</small>
      <div class="singleTitle">[42cursus] ft_printf</div>
    </div>
  </div>
  <div class="series">
  <details>
    <summary>📚 /42cursus</summary>
    <ul>
      
      
      
      <li>-<a href="https://elecbrandy.github.io/posts/42cursus/circle_0/libft/">libft</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/42cursus/circle_1/ft_printf/">ft_printf</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/42cursus/circle_1/get_next_line/">get_next_line</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/42cursus/circle_1/born2beroot/">born2beroot</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/42cursus/circle_2/pipex/">pipex</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/42cursus/circle_2/fdf/">fdf</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/42cursus/circle_2/push_swap/">push_swap</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/42cursus/circle_3/minishell/">minishell</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/42cursus/circle_3/philosopher/">philosopher</a></li>
      
      <li>-<a href="https://elecbrandy.github.io/posts/42cursus/circle_4/netpractice/">netpractice</a></li>
      
    </ul>
  </details>
</div>

<br>
<h2 id="1-소개">1. 소개</h2>
<hr>
<blockquote>
<p>putnbr and putstr aren’t enough</p>
</blockquote>
<p>42서울 본과정 입과 후 두번째로 수행한 과제로, 말 그대로 C언어의 <code>printf</code> 함수를 재현하는 과제이다. bonus는 수행하지 않았고, 기본적인 내용만 구현하다보니 생각보다 난이도가 쉬웠던 것 같다. libc의 <code>printf</code> 함수를 재구현해야 하며, 실제 <code>printf</code>처럼 버퍼 관리를 수행해서는 안 된다. 서식 지정자 <code>cspdiuxX%</code>를 구현해야한다.</p>
<br>
<br>
<h2 id="2-ft_printf-명세서">2. ft_printf 명세서</h2>
<hr>
<ul>
<li><strong>PROTOTYPE</strong>
<ul>
<li><code>int ft_printf(const char *str, ...);</code></li>
</ul>
</li>
<li><strong>PARAMETER</strong>
<ul>
<li><code>const char *str</code> : format 이라는 이름의 문자열 상수 (서식 문자열)</li>
<li><code>...</code> : 생략 기호로, 두번째 이후 인수부터는 인수의 개수와 타입을 점검하지 않으며, 컴파일러는 이후의 인수에 대해서 개수, 타입에 상관없이 그대로 함수에 넘겨줌</li>
</ul>
</li>
<li><strong>DESCRIPTION</strong>
<ul>
<li><code>%c</code> 단일 문자를 인쇄</li>
<li><code>%s</code> 문자열을 인쇄</li>
<li><code>%p</code> void * 포인터 인수는 16진수 형식으로 인쇄</li>
<li><code>%d</code> 십진수(기본 10)를 인쇄</li>
<li><code>%i</code> 기본 10의 정수를 인쇄</li>
<li><code>%u</code> 부호 없는 10진수(베이스 10)를 인쇄</li>
<li><code>%x</code> 16진수(베이스 16) 소문자 형식으로 숫자를 인쇄</li>
<li><code>%X</code> 16진수(베이스 16) 대문자 형식으로 숫자를 인쇄</li>
<li><code>%%</code> 백분율 기호를 인쇄</li>
<li><code>External functs</code>
<ul>
<li>malloc, free, write</li>
<li>va_start, va_arg, va_copy, va_end</li>
</ul>
</li>
</ul>
</li>
<li><strong>RETURN VALUES</strong>
<ul>
<li><em>Upon successful return, these functions return the number of characters printed (excluding the null byte used to end output to strings).</em></li>
<li>성공적으로 반환되면, 이 함수들은 인쇄된 문자 수를 반환합니다.(출력을 끝내는 데 사용되는 널 바이트 제외) 문자열을 반환함</li>
</ul>
</li>
</ul>
<br>
<br>
<h2 id="3-개념-정리">3. 개념 정리</h2>
<hr>
<h3 id="3-1-가변인자">3-1. 가변인자</h3>
<p>가변인자 다루는 것에 중점을 둔 과제인 만큼, <code>va_</code> 함수를 통해 가변인자를 통제하는 방법을 알아야한다.</p>
<br>
<h3 id="3-2-바이트-패딩">3-2. 바이트 패딩</h3>
<p>우리는 왜 char형을 읽는 순간 <code>(char)va_arg(ap, int);</code> 을 사용하는가? char형 자료를 읽는데 왜 int형 만큼 읽어오는 것인가?
바이트 패딩은 CPU가 데이터를 효율적으로 처리하게 하는 데 중요한 역할을 하며, 당연하게도 이는 32비트와 64비트 운영 체제 간의 데이터 처리 방식에 차이를 가져온다.</p>
<p>그러나 바이트 패딩만으로 설명할 수 있을까?
다만 바이트 패딩만으로 위 질문에 답하기 애매한것은 운영체제의 비트에 따라 데이터 처리 단위가 상이하기 때문이다.</p>
<p>32비트 운영 체제는 4바이트, 64비트 운영 체제는 8바이트 단위로 데이터를 처리하기 때문에, 카뎃의 의도가 정말 바이트 패딩을 통해 데이터를 효율적으로 처리하기 위함이었다면 운영체제의 종류를 고민한 흔적이 코드에 들어있어야 할 것 이다.</p>
<p>그렇지만 대부분 <code>(char)va_arg(ap, int);</code> 을 명시적으로 사용하곤 한다.</p>
<p>유력한 다른 이유는 원시 C언어 시절에는 함수 프로토타입이 존재하지 않았기 때문에, 함수로 전달되는 인자의 정확한 자료형을 알 수 없었다. 따라서 모든 인자는 int로 처리되었고, 이러한 관행의 흔적이라고 보는 것이 좀 더 타당해보인다.</p>
<br>
<h2 id="4-mandatory">4. Mandatory</h2>
<hr>
<img src="https://imgur.com/Ghuekwt.png" width="700">
<br>
<h4 id="step-01">step 01</h4>
<p><code>ft_isformat</code>을 통해 지정된 포맷인지 확인하며 문자열을 읽어나간다.</p>
<h4 id="step-02">step 02</h4>
<p>지정된 포맷을 만났을 경우, <code>ft_parse_format</code> 함수를 통해 가변인자를 읽어 각 포맷에 맞게 변환한다.</p>
<h4 id="step-03">step 03</h4>
<p>지정된 포맷이 아닌 경우, 문자 하나 하나 <code>write</code> 함수를 통해 출력한다.</p>
<br>
<h3 id="4-1-구현">4-1. 구현</h3>
<h4 id="ft_printf">ft_printf</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span>	<span style="color:#a6e22e">ft_printf</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>format, ...)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span>		print_cnt;
</span></span><span style="display:flex;"><span>	va_list	ap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">va_start</span>(ap, format);
</span></span><span style="display:flex;"><span>	print_cnt <span style="color:#f92672">=</span> <span style="color:#a6e22e">ft_print_format</span>(format, ap);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">va_end</span>(ap);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (print_cnt);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>우선 <code>printf</code>의 return 값은 print된 문자의 수이므로 <code>printf_cnt</code> 함수에 담았다가 return 하는 방식을 선택했다.</p>
<br>
<h4 id="ft_printf_format">ft_printf_format</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span>	<span style="color:#a6e22e">ft_print_format</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str, va_list ap)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span>	print_cnt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	print_cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">*</span>str)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>str <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;%&#39;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">ft_isformat</span>(<span style="color:#f92672">*</span>(str <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)))
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ft_parse_format</span>(<span style="color:#f92672">*</span>(str <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), ap, <span style="color:#f92672">&amp;</span>print_cnt);
</span></span><span style="display:flex;"><span>			str<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ft_putchar_fd</span>(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">*</span>str, <span style="color:#f92672">&amp;</span>print_cnt);
</span></span><span style="display:flex;"><span>		str<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (print_cnt);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>함수 <code>ft_printf_format</code>은 인자로 받은 <code>const char *fortmat</code>을 문자 <code>%</code>가 나올 때까지 탐색한다. 문자 <code>%</code>을 발견하면, <code>%</code> 바로 뒤의 포맷을 확인해서 해당하는 포맷과 알맞은 출력을 진행한다.</p>
<br>
<h4 id="ft_putbase">ft_putbase</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ft_putbase</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>base, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> number, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>cnt)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>cnt <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">/</span> number <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ft_putbase</span>(n <span style="color:#f92672">/</span> number, base, number, cnt);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ft_putchar_fd</span>(<span style="color:#ae81ff">1</span>, base[n <span style="color:#f92672">%</span> number], cnt);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>진법에 맞는 숫자로 출력을 원할 때, 재귀를 사용하면 생각보다 코드가 깔끔해진다.</p>
<br>
<br>
<h2 id="5-reference">5. Reference</h2>
<hr>
<ul>
<li><a href="https://jangsalt.tistory.com/entry/%EA%B0%80%EB%B3%80-%EC%9D%B8%EC%88%98-vastart-vaend-vaarg-valist">https://jangsalt.tistory.com/entry/%EA%B0%80%EB%B3%80-%EC%9D%B8%EC%88%98-vastart-vaend-vaarg-valist</a></li>
<li><a href="https://jhnyang.tistory.com/293">https://jhnyang.tistory.com/293</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_node/Argument-Macros.html">https://www.gnu.org/software/libc/manual/html_node/Argument-Macros.html</a></li>
<li><a href="https://azrael.digipen.edu/~mmead/www/Courses/CS120/VariadicFunctions.html#STACKS">https://azrael.digipen.edu/~mmead/www/Courses/CS120/VariadicFunctions.html#STACKS</a></li>
</ul>
<br>
<br>

    

<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  backgroundColor: 'rgb(255, 83, 176)',
  textColor: '#fff'
})</script>

</body>
</html>
