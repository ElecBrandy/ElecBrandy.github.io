<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>[42cursus] get_next_line | Elecbrandy</title>

      <link rel="stylesheet" href="/css/main.min.9c532356e1ba5b0b453a018f05594f84ad70b41e35d2d6dffd715560f3dd0b8a.css" integrity="sha256-nFMjVuG6WwtFOgGPBVlPhK1wtB410tbf/XFVYPPdC4o=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/min700.min.2bcf847d60d198d878bbf49b39374a02cdc7cd4e66411bfa42ada12fe8b580ba.css" integrity="sha256-K8&#43;EfWDRmNh4u/SbOTdKAs3HzU5mQRv6Qq2hL&#43;i1gLo=" crossorigin="anonymous">


      <script src="/js/main.0740a53bb4495dfc0d897c89f56fe801f29d1ad0d7e20f51491e421debb12f67.js" integrity="sha256-B0ClO7RJXfwNiXyJ9W/oAfKdGtDX4g9RSR5CHeuxL2c=" crossorigin="anonymous"></script>

<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" integrity="sha384-k6vP0kLaVwmS/tB1lCew8HlB/iMDmD4B9Vq3OU9bfXjMWmWrARyAZF9a3F7sKwDx" crossorigin="anonymous">



</head>
<body>
  <header>
    <header class="header-other">
	<div class="header-container">
		<div class="header-title">
			<a href="https://elecbrandy.github.io/">Elecbrandy</a>
	  	</div>
	  	<ul class="header-menu">
			<li><a href="https://elecbrandy.github.io//tags">TAGS</a></li>
			<li><a href="https://elecbrandy.github.io//about">ABOUT</a></li>
			<button id="theme-toggle" aria-label="Toggle theme">
				<img src="/dark.svg" alt="Dark mode" id="dark-icon">
				<img src="/light.svg" alt="Light mode" id="light-icon">
			  </button>
		</ul>
	</div>
	
		<div class="progress-bar"></div>
  	
</header>

  </header>
  
    
        <div class="pre-content" style="background-image: url('http://t1.daumcdn.net/cfile/15110210A8445BF80D');"></div>
        <div class="pre-title">
            
            
            <time datetime="2023-12-18T00:00:00&#43;00:00">December 18, 2023</time>
            <h1>[42cursus] get_next_line</h1>
        </div>
    


  <div class="content">
    
  <blockquote>
<p>Reading a line on a fd is way too tedious</p>
</blockquote>
<br>
<h1 id="01-소개">01 소개</h1>
<p>42서울 본과정 입과 후 세번째로 수행한 과제로, 파일 디스크립터로부터 읽혀진 - 개행으로 끝나는 한 줄을 반환하는 함수를 만드는 과제이다. 즉 파일 하나를 연 다음, 파일 내용에서 개행으로 끝나는 줄 하나를 반환해야한다. 파일을 열고, 지정된 <strong>BUFFER_SIZE</strong> 만큼 <code>read</code>함수를 통해 파일을 읽다가 개행문자 <code>\n</code>이 나타나면 개행문자 전까지만 반환한다.</p>
<br>
<h1 id="02-get_next_line-명세서">02 <code>GET_NEXT_LINE</code> 명세서</h1>
<ul>
<li><strong>PROTOTYPE</strong>
<ul>
<li><code>char *get_next_line(int fd);</code></li>
</ul>
</li>
<li><strong>PARAMETER</strong>
<ul>
<li><code>int fd</code> : 읽어들일 파일의 디스크립터</li>
</ul>
</li>
<li><strong>DESCRIPTION</strong>
<ul>
<li><strong>Mandatory part</strong>
<ul>
<li>호출마다 한 번에 한 줄씩 파일 디스크립터가 가리키는 파일을 읽어온다.</li>
<li>더 이상 읽어올 것이 없거나 에러가 발생하면 <code>NULL</code>을 반환한다.</li>
<li>파일 끝에 도달하였고, 개행문자 <code>\n</code>이 존재하지 않을 때를 제외하고 반환하는 문자열에는 <code>\n</code>이 포함되어야 한다.</li>
</ul>
</li>
<li><strong>Bonus part</strong>
<ul>
<li>정적 변수를 하나만 사용하여 개발해야한다.</li>
<li><code>get_next_line()</code> 이 여러 개의 파일 디스크립터를 한번에 관리해야 한다.</li>
<li>한번 호출하여 3, 4, 5 그 이후 다시 4, 5 등등을 읽을 수 있어야 한다.</li>
</ul>
</li>
<li><strong>External functs</strong>
<ul>
<li>read, malloc, free</li>
</ul>
</li>
</ul>
</li>
<li><strong>RETURN VALUES</strong>
<ul>
<li>한 줄을 제대로 읽은 정상작동의 경우 읽은 라인을 반환한다.</li>
<li>비정상작동의 경우 <code>NULL</code>을 반환한다.</li>
</ul>
</li>
</ul>
<br>
<h1 id="03-mandatory">03 Mandatory</h1>
<h2 id="madatory-로직">Madatory 로직</h2>
<h3 id="1-파싱">1. 파싱</h3>
<img src="https://imgur.com/2R4ZmUq.png" width="700">
<p>파일을 열고, 지정된 <strong>BUFFER_SIZE</strong> 만큼 <code>read</code>함수를 통해 파일을 읽다가 개행문자 <code>\n</code>이 나타나면 개행문자 전까지만 반환한다.</p>
<br>
<h3 id="2-get_next_line">2. get_next_line</h3>
<img src="https://imgur.com/w1qsdXS.png" width="700">
<h3 id="step-01">step 01</h3>
<p>개행문자 <code>\n</code>을 만날 때까지 또는 <code>EOF</code>에 도달할 때까지 <strong>BUFFER_SIZE</strong> 만큼 읽어나간다.</p>
<h3 id="step-02">step 02</h3>
<p>개행문자 전까지만 따로 분리해서 return을 준비한다.</p>
<h3 id="step-03">step 03</h3>
<p>추후 <strong>BUFFER_SIZE</strong> 실행을 위해서 <code>main_buf</code>에 나머지 남은 문자열을 저장한다.</p>
<br>
<h2 id="mandatory-구현">Mandatory 구현</h2>
<h3 id="get_next_line"><code>get_next_line</code></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">get_next_line</span>(<span style="color:#66d9ef">int</span> fd)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span>	<span style="color:#f92672">*</span>main_buf;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span>		<span style="color:#f92672">*</span>line;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	line <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (fd <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> BUFFER_SIZE <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> (NULL);
</span></span><span style="display:flex;"><span>	main_buf <span style="color:#f92672">=</span> <span style="color:#a6e22e">read_line_fd</span>(fd, main_buf);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>main_buf)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> (NULL);
</span></span><span style="display:flex;"><span>	line <span style="color:#f92672">=</span> <span style="color:#a6e22e">extract_line</span>(main_buf);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>line)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">ft_free</span>(<span style="color:#f92672">&amp;</span>main_buf));
</span></span><span style="display:flex;"><span>	main_buf <span style="color:#f92672">=</span> <span style="color:#a6e22e">ready_main_buf</span>(main_buf);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (line);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>main_buf</code> 변수는 <strong>static</strong> 변수이기 때문에, 프로그램 실행 시 단 한 번 초기화 되며, 이후에 <code>get_next_line</code> 함수가 호출되어도 초기화되지 않고 이전에 저장된 값을 유지한다.
<code>read_line_fd</code>를 통해 개행 또는 EOF 전까지 <strong>BUFFER_SIZE</strong>만큼씩 파일을 읽는다.
읽은 내용은 <code>main_buf</code>에 저장되며, <code>extrac_line</code> 함수를 통해 개행 전까지 잘라 <code>line</code>에 담는다.
<code>read_main_buf</code>를 통해 <code>main_buf</code>를 정리(잘라낸 line을 없애고 나머지만 남김)하여 다음 호출을 대비한다.</p>
<br>
<h1 id="04-bonus">04 BONUS</h1>
<h2 id="bonus-구현">BONUS 구현</h2>
<h3 id="get_next_line_bonus"><code>get_next_line_bonus</code></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">get_next_line</span>(<span style="color:#66d9ef">int</span> fd)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span>	<span style="color:#f92672">*</span>main_buf[OPEN_MAX];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span>		<span style="color:#f92672">*</span>line;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	line <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (fd <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> BUFFER_SIZE <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> (NULL);
</span></span><span style="display:flex;"><span>	main_buf[fd] <span style="color:#f92672">=</span> <span style="color:#a6e22e">read_line_fd</span>(fd, main_buf[fd]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>main_buf[fd])
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> (NULL);
</span></span><span style="display:flex;"><span>	line <span style="color:#f92672">=</span> <span style="color:#a6e22e">extract_line</span>(main_buf[fd]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>line)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">ft_free</span>(<span style="color:#f92672">&amp;</span>(main_buf[fd])));
</span></span><span style="display:flex;"><span>	main_buf[fd] <span style="color:#f92672">=</span> <span style="color:#a6e22e">ready_main_buf</span>(main_buf[fd]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (line);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>BONUS</strong>의 경우 여러가지 파일 디스크립터를 다룰 수 있게 만들어야 하기 때문에 대비가 필요하다.
<code>OPEN_MAX</code>를 통해 디스크립터 테이블만큼 배열을 만들어 정적 배열을 통해 여러 파일 디스크립터를 다루는 방법을 선택했다.</p>
<br>
<h1 id="05-get_next_line-주의사항">05 <code>GET_NEXT_LINE</code> 주의사항</h1>
<h2 id="연결리스트와-open_max">연결리스트와 OPEN_MAX</h2>
<p>본 과제의 <strong>BONUS</strong>를 수행한다면, 즉 동시에 여러 파일 디스크립터를 감안하는 프로그램을 만들고 싶다면 크게 두가지 방법이 존재한다. 첫번째는 연결리스트로 구현하는 것이고 두번째는 OPEN_MAX로 구현하는 것. 전자의 경우 사용자가 얼마나 파일을 열지 모르기 때문에 연결리스트 구조를 통해 생성되는 파일 디스크립터를 담은 노드를 계속 뒤에 이어 붙이는 것을 의미한다. 후자의 경우 해당 시스템에서 용인하는 최대 파일 디스크립터 수를 정의한 <code>OPEN_MAX</code>를 통해 정적 배열로 관리하는 것이다.
이 두가지 방법을 두고 평가 기준에 다른 카뎃들의 여러가지 논의가 있는 것은 맞으나! 평가자를 납득시킬 수 있는 설명(또는 노력)을 통해 원하는 방법으로 보너스까지 노려보자.</p>
<br>
<h3 id="open_max">OPEN_MAX</h3>
<p>나는 <code>OPEN_MAX</code>를 통해 보너스를 구현했다. 그 이유는 본 과제에서 중요하게 배워야하는 것은 파일 디스크립터라는 생소한 개념과 파일을 열고 read하고 닫고, 동적할당한 메모리를 적절하게 해제하는 것이라고 생각하기 때문이다. 때문에 연결리스트로 분명히 구현은 가능하지만, 굳이 공수를 더 들일 필요 또한 없다고 생각했다.</p>
<p><code>OPEN_MAX</code>의 경우 한계점이 존재하는 것은 사실이다. <code>limits.h</code>에 정의된 <code>OPEN_MAX</code>는 단순 정의일 뿐이고, 리눅스 버전에 따라 다르기도 하다. 또한 컴퓨터 환경에 따라 달라지는 실질적인 파일 디스크립터 수를 반영하지 못하며 bash 환경과 vscode의 터미널 상에서 파일 디스크립터 값을 확인했을 때 차이가 존재하는 것을 알 수 있다. 그렇지만 최종적으로 이 과제에서 더 중점으로 다뤄야 하는 것은 따로 있다고 생각하기 때문에 <code>OPEN_MAX</code>로 구현하더라도 그 한계지점과 그 한계지점을 찾기 위한 본인의 노력을 평가 시에 함께 어필한다면 충분히 통과할 수 있다고 생각한다.(개인적인 기준)</p>
<br>
<h2 id="동적할당과-해제">동적할당과 해제</h2>
<p>메모리 누수를 막기위해서 동적으로 할당한 힙 영역의 메모리는 사용이 끝난 경우 해제해야 하는 것이 당연하다.
이때 아래 함수를 통해서 free를 조금 더 안전하고 유용하게 사용할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span>	<span style="color:#a6e22e">ft_free</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>target)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (target <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">*</span>target) <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">free</span>(<span style="color:#f92672">*</span>target);
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>target <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>메모리 해제 후 포인터를 NULL로 설정함으로써, 포인터의 Dangling Pointer 상태(해제된 메모리를 가르키는 상태)를 방지한다. 또한 이 과정을 통해 이미 할당 해제된 메모리 주소에 다시 접근하는 것을 방지할 수 있다.</p>
<br>
<h1 id="05-reference">05 Reference</h1>
<ul>
<li><a href="https://man7.org/linux/man-pages/man2/read.2.html">https://man7.org/linux/man-pages/man2/read.2.html</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_node/Streams-and-File-Descriptors.html">https://www.gnu.org/software/libc/manual/html_node/Streams-and-File-Descriptors.html</a></li>
<li><a href="https://code-lab1.tistory.com/65">https://code-lab1.tistory.com/65</a></li>
</ul>
<br>
<div class="alert">
    <span><a href="https://elecbrandy.github.io/tags/42cursus"> 42cursus </a></span>
</div>

<br>


  </div>
  <footer>
    

<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  backgroundColor: 'rgb(255, 83, 176)',
  textColor: '#fff'
})</script>

  </footer>
</body>
</html>
